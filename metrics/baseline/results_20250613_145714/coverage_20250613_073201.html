
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>demo: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/pay-theory/streamer/demo/generate_jwt.go (0.0%)</option>
				
				<option value="file1">github.com/pay-theory/streamer/internal/protocol/message.go (100.0%)</option>
				
				<option value="file2">github.com/pay-theory/streamer/internal/protocol/validation.go (98.5%)</option>
				
				<option value="file3">github.com/pay-theory/streamer/internal/store/connection_store.go (83.3%)</option>
				
				<option value="file4">github.com/pay-theory/streamer/internal/store/dynamorm/connection_store.go (98.7%)</option>
				
				<option value="file5">github.com/pay-theory/streamer/internal/store/dynamorm/factory.go (0.0%)</option>
				
				<option value="file6">github.com/pay-theory/streamer/internal/store/dynamorm/models.go (100.0%)</option>
				
				<option value="file7">github.com/pay-theory/streamer/internal/store/dynamorm/request_queue.go (85.0%)</option>
				
				<option value="file8">github.com/pay-theory/streamer/internal/store/errors.go (100.0%)</option>
				
				<option value="file9">github.com/pay-theory/streamer/internal/store/migrations.go (0.0%)</option>
				
				<option value="file10">github.com/pay-theory/streamer/internal/store/request_queue.go (94.9%)</option>
				
				<option value="file11">github.com/pay-theory/streamer/lambda/connect/auth.go (86.0%)</option>
				
				<option value="file12">github.com/pay-theory/streamer/lambda/connect/handler.go (93.3%)</option>
				
				<option value="file13">github.com/pay-theory/streamer/lambda/connect/main.go (0.0%)</option>
				
				<option value="file14">github.com/pay-theory/streamer/lambda/disconnect/handler.go (96.9%)</option>
				
				<option value="file15">github.com/pay-theory/streamer/lambda/disconnect/main.go (0.0%)</option>
				
				<option value="file16">github.com/pay-theory/streamer/lambda/processor/executor/executor.go (90.1%)</option>
				
				<option value="file17">github.com/pay-theory/streamer/lambda/processor/handlers.go (0.0%)</option>
				
				<option value="file18">github.com/pay-theory/streamer/lambda/processor/handlers/data_processor.go (57.3%)</option>
				
				<option value="file19">github.com/pay-theory/streamer/lambda/processor/handlers/echo_async.go (0.0%)</option>
				
				<option value="file20">github.com/pay-theory/streamer/lambda/processor/handlers/report_async.go (81.2%)</option>
				
				<option value="file21">github.com/pay-theory/streamer/lambda/processor/main.go (0.0%)</option>
				
				<option value="file22">github.com/pay-theory/streamer/lambda/router/handlers.go (91.1%)</option>
				
				<option value="file23">github.com/pay-theory/streamer/lambda/router/main.go (77.0%)</option>
				
				<option value="file24">github.com/pay-theory/streamer/lambda/shared/auth.go (88.0%)</option>
				
				<option value="file25">github.com/pay-theory/streamer/lambda/shared/logging.go (87.9%)</option>
				
				<option value="file26">github.com/pay-theory/streamer/lambda/shared/metrics.go (29.4%)</option>
				
				<option value="file27">github.com/pay-theory/streamer/lambda/shared/tracing.go (26.4%)</option>
				
				<option value="file28">github.com/pay-theory/streamer/pkg/connection/api_gateway.go (100.0%)</option>
				
				<option value="file29">github.com/pay-theory/streamer/pkg/connection/api_gateway_adapter.go (45.7%)</option>
				
				<option value="file30">github.com/pay-theory/streamer/pkg/connection/errors.go (100.0%)</option>
				
				<option value="file31">github.com/pay-theory/streamer/pkg/connection/interfaces.go (100.0%)</option>
				
				<option value="file32">github.com/pay-theory/streamer/pkg/connection/manager.go (87.6%)</option>
				
				<option value="file33">github.com/pay-theory/streamer/pkg/connection/mocks.go (21.2%)</option>
				
				<option value="file34">github.com/pay-theory/streamer/pkg/connection/testing.go (79.5%)</option>
				
				<option value="file35">github.com/pay-theory/streamer/pkg/progress/batcher.go (96.5%)</option>
				
				<option value="file36">github.com/pay-theory/streamer/pkg/progress/reporter.go (100.0%)</option>
				
				<option value="file37">github.com/pay-theory/streamer/pkg/streamer/adapters.go (96.8%)</option>
				
				<option value="file38">github.com/pay-theory/streamer/pkg/streamer/handler.go (100.0%)</option>
				
				<option value="file39">github.com/pay-theory/streamer/pkg/streamer/router.go (97.1%)</option>
				
				<option value="file40">github.com/pay-theory/streamer/pkg/streamer/streamer.go (100.0%)</option>
				
				<option value="file41">github.com/pay-theory/streamer/pkg/types/messages.go (100.0%)</option>
				
				<option value="file42">github.com/pay-theory/streamer/scripts/create_tables.go (0.0%)</option>
				
				<option value="file43">github.com/pay-theory/streamer/scripts/demo/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "flag"
        "fmt"
        "io/ioutil"
        "log"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

func main() <span class="cov0" title="0">{
        var (
                userID      = flag.String("user-id", "demo-user", "User ID for the JWT")
                tenantID    = flag.String("tenant-id", "demo-tenant", "Tenant ID for the JWT")
                permissions = flag.String("permissions", "read,write", "Comma-separated permissions")
                expired     = flag.Bool("expired", false, "Generate an expired token")
                privateKey  = flag.String("private-key", "demo/private.pem", "Path to RSA private key")
                issuer      = flag.String("issuer", "https://auth.pay-theory.com", "JWT issuer")
        )
        flag.Parse()

        // Generate or load private key
        key, err := loadOrGeneratePrivateKey(*privateKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load/generate private key: %v", err)
        }</span>

        // Create claims
        <span class="cov0" title="0">claims := jwt.MapClaims{
                "sub":         *userID,
                "tenant_id":   *tenantID,
                "iss":         *issuer,
                "iat":         time.Now().Unix(),
                "permissions": strings.Split(*permissions, ","),
        }

        if *expired </span><span class="cov0" title="0">{
                // Set expiration to 1 hour ago
                claims["exp"] = time.Now().Add(-1 * time.Hour).Unix()
        }</span> else<span class="cov0" title="0"> {
                // Set expiration to 24 hours from now
                claims["exp"] = time.Now().Add(24 * time.Hour).Unix()
        }</span>

        // Create token
        <span class="cov0" title="0">token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)

        // Sign token
        tokenString, err := token.SignedString(key)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to sign token: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println(tokenString)</span>
}

func loadOrGeneratePrivateKey(path string) (*rsa.PrivateKey, error) <span class="cov0" title="0">{
        // Try to load existing key
        keyData, err := ioutil.ReadFile(path)
        if err == nil </span><span class="cov0" title="0">{
                // Parse existing key
                block, _ := pem.Decode(keyData)
                if block == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to decode PEM block")
                }</span>

                <span class="cov0" title="0">key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse private key: %w", err)
                }</span>

                <span class="cov0" title="0">return key, nil</span>
        }

        // Generate new key
        <span class="cov0" title="0">key, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate key: %w", err)
        }</span>

        // Save private key
        <span class="cov0" title="0">privateKeyPEM := &amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(key),
        }

        privateKeyFile, err := ioutil.TempFile("", "private-*.pem")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create private key file: %w", err)
        }</span>
        <span class="cov0" title="0">defer privateKeyFile.Close()

        if err := pem.Encode(privateKeyFile, privateKeyPEM); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write private key: %w", err)
        }</span>

        // Save public key
        <span class="cov0" title="0">publicKeyPEM := &amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: x509.MarshalPKCS1PublicKey(&amp;key.PublicKey),
        }

        publicKeyFile, err := ioutil.TempFile("", "public-*.pem")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create public key file: %w", err)
        }</span>
        <span class="cov0" title="0">defer publicKeyFile.Close()

        if err := pem.Encode(publicKeyFile, publicKeyPEM); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write public key: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Generated new key pair:\n")
        fmt.Printf("Private key: %s\n", privateKeyFile.Name())
        fmt.Printf("Public key: %s\n", publicKeyFile.Name())

        return key, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package protocol

import (
        "encoding/json"
        "time"
)

// MessageType represents the type of WebSocket message
type MessageType string

const (
        // Incoming message types
        MessageTypeRequest = "request"

        // Outgoing message types
        MessageTypeResponse       = "response"
        MessageTypeAcknowledgment = "acknowledgment"
        MessageTypeProgress       = "progress"
        MessageTypeError          = "error"
)

// IncomingMessage represents a message received from a WebSocket client
type IncomingMessage struct {
        Type     MessageType            `json:"type"`
        ID       string                 `json:"id,omitempty"`
        Action   string                 `json:"action"`
        Payload  json.RawMessage        `json:"payload,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// OutgoingMessage represents a message sent to a WebSocket client
type OutgoingMessage struct {
        Type      MessageType `json:"type"`
        RequestID string      `json:"request_id,omitempty"`
        Timestamp time.Time   `json:"timestamp"`
}

// ResponseMessage represents a response to a request
type ResponseMessage struct {
        OutgoingMessage
        Success  bool                   `json:"success"`
        Data     interface{}            `json:"data,omitempty"`
        Error    *ErrorData             `json:"error,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// AcknowledgmentMessage represents an acknowledgment of an async request
type AcknowledgmentMessage struct {
        OutgoingMessage
        Status  string `json:"status"`
        Message string `json:"message"`
}

// ProgressMessage represents a progress update for an async operation
type ProgressMessage struct {
        OutgoingMessage
        Percentage float64                `json:"percentage"`
        Message    string                 `json:"message"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// ErrorMessage represents an error message
type ErrorMessage struct {
        OutgoingMessage
        Error *ErrorData `json:"error"`
}

// ErrorData contains error details
type ErrorData struct {
        Code    string                 `json:"code"`
        Message string                 `json:"message"`
        Details map[string]interface{} `json:"details,omitempty"`
}

// NewResponseMessage creates a new response message
func NewResponseMessage(requestID string, success bool, data interface{}, err *ErrorData) *ResponseMessage <span class="cov8" title="3">{
        return &amp;ResponseMessage{
                OutgoingMessage: OutgoingMessage{
                        Type:      MessageTypeResponse,
                        RequestID: requestID,
                        Timestamp: time.Now(),
                },
                Success: success,
                Data:    data,
                Error:   err,
        }
}</span>

// NewAcknowledgmentMessage creates a new acknowledgment message
func NewAcknowledgmentMessage(requestID, status, message string) *AcknowledgmentMessage <span class="cov8" title="3">{
        return &amp;AcknowledgmentMessage{
                OutgoingMessage: OutgoingMessage{
                        Type:      MessageTypeAcknowledgment,
                        RequestID: requestID,
                        Timestamp: time.Now(),
                },
                Status:  status,
                Message: message,
        }
}</span>

// NewProgressMessage creates a new progress message
func NewProgressMessage(requestID string, percentage float64, message string) *ProgressMessage <span class="cov10" title="4">{
        return &amp;ProgressMessage{
                OutgoingMessage: OutgoingMessage{
                        Type:      MessageTypeProgress,
                        RequestID: requestID,
                        Timestamp: time.Now(),
                },
                Percentage: percentage,
                Message:    message,
        }
}</span>

// NewErrorMessage creates a new error message
func NewErrorMessage(err *ErrorData) *ErrorMessage <span class="cov8" title="3">{
        return &amp;ErrorMessage{
                OutgoingMessage: OutgoingMessage{
                        Type:      MessageTypeError,
                        Timestamp: time.Now(),
                },
                Error: err,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package protocol

import (
        "encoding/json"
        "fmt"
        "strings"
)

// ValidationError represents a validation error
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// ValidationErrors represents multiple validation errors
type ValidationErrors []ValidationError

// Error implements the error interface
func (ve ValidationErrors) Error() string <span class="cov4" title="17">{
        if len(ve) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov4" title="16">var messages []string
        for _, e := range ve </span><span class="cov5" title="32">{
                messages = append(messages, fmt.Sprintf("%s: %s", e.Field, e.Message))
        }</span>
        <span class="cov4" title="16">return strings.Join(messages, "; ")</span>
}

// ValidateIncomingMessage validates an incoming WebSocket message
func ValidateIncomingMessage(data []byte) (*IncomingMessage, error) <span class="cov4" title="24">{
        var msg IncomingMessage
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov1" title="2">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>

        <span class="cov4" title="22">var errors ValidationErrors

        // Validate message type
        if msg.Type == "" </span><span class="cov4" title="18">{
                msg.Type = MessageTypeRequest // Default to request
        }</span> else<span class="cov2" title="4"> if msg.Type != MessageTypeRequest </span><span class="cov1" title="2">{
                errors = append(errors, ValidationError{
                        Field:   "type",
                        Message: fmt.Sprintf("invalid message type: %s", msg.Type),
                })
        }</span>

        // Validate action
        <span class="cov4" title="22">if msg.Action == "" </span><span class="cov2" title="4">{
                errors = append(errors, ValidationError{
                        Field:   "action",
                        Message: "action is required",
                })
        }</span> else<span class="cov4" title="18"> {
                // Action must be alphanumeric with dots, dashes, and underscores
                if !isValidAction(msg.Action) </span><span class="cov2" title="3">{
                        errors = append(errors, ValidationError{
                                Field:   "action",
                                Message: "action must contain only alphanumeric characters, dots, dashes, and underscores",
                        })
                }</span>
        }

        // Validate ID if provided
        <span class="cov4" title="22">if msg.ID != "" &amp;&amp; len(msg.ID) &gt; 128 </span><span class="cov1" title="2">{
                errors = append(errors, ValidationError{
                        Field:   "id",
                        Message: "id must not exceed 128 characters",
                })
        }</span>

        // Validate payload if provided
        <span class="cov4" title="22">if msg.Payload != nil &amp;&amp; len(msg.Payload) &gt; 0 </span><span class="cov3" title="8">{
                var temp interface{}
                if err := json.Unmarshal(msg.Payload, &amp;temp); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Field:   "payload",
                                Message: "payload must be valid JSON",
                        })
                }</span>
        }

        <span class="cov4" title="22">if len(errors) &gt; 0 </span><span class="cov3" title="9">{
                return nil, errors
        }</span>

        <span class="cov4" title="13">return &amp;msg, nil</span>
}

// isValidAction checks if an action string is valid
func isValidAction(action string) bool <span class="cov5" title="50">{
        if action == "" </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov5" title="49">for _, ch := range action </span><span class="cov9" title="1284">{
                if !isAlphaNumeric(ch) &amp;&amp; ch != '.' &amp;&amp; ch != '-' &amp;&amp; ch != '_' </span><span class="cov5" title="26">{
                        return false
                }</span>
        }

        <span class="cov4" title="23">return true</span>
}

// isAlphaNumeric checks if a rune is alphanumeric
func isAlphaNumeric(ch rune) bool <span class="cov10" title="1302">{
        return (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
}</span>

// ValidateHandler provides validation for specific handler payloads
type ValidateHandler interface {
        ValidatePayload(payload json.RawMessage) error
}

// PayloadValidator provides common payload validation functions
type PayloadValidator struct{}

// RequireFields checks that required fields exist in the payload
func (pv *PayloadValidator) RequireFields(payload json.RawMessage, fields ...string) error <span class="cov3" title="7">{
        var data map[string]interface{}
        if err := json.Unmarshal(payload, &amp;data); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid payload format: %w", err)
        }</span>

        <span class="cov3" title="6">var errors ValidationErrors
        for _, field := range fields </span><span class="cov4" title="11">{
                if _, exists := data[field]; !exists </span><span class="cov2" title="4">{
                        errors = append(errors, ValidationError{
                                Field:   field,
                                Message: "field is required",
                        })
                }</span>
        }

        <span class="cov3" title="6">if len(errors) &gt; 0 </span><span class="cov1" title="2">{
                return errors
        }</span>

        <span class="cov2" title="4">return nil</span>
}

// ValidateString validates a string field
func (pv *PayloadValidator) ValidateString(data map[string]interface{}, field string, minLen, maxLen int) error <span class="cov3" title="8">{
        value, exists := data[field]
        if !exists </span><span class="cov1" title="1">{
                return nil // Field is optional
        }</span>

        <span class="cov3" title="7">str, ok := value.(string)
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("%s must be a string", field)
        }</span>

        <span class="cov3" title="6">if minLen &gt; 0 &amp;&amp; len(str) &lt; minLen </span><span class="cov1" title="1">{
                return fmt.Errorf("%s must be at least %d characters", field, minLen)
        }</span>

        <span class="cov3" title="5">if maxLen &gt; 0 &amp;&amp; len(str) &gt; maxLen </span><span class="cov1" title="1">{
                return fmt.Errorf("%s must not exceed %d characters", field, maxLen)
        }</span>

        <span class="cov2" title="4">return nil</span>
}

// ValidateNumber validates a numeric field
func (pv *PayloadValidator) ValidateNumber(data map[string]interface{}, field string, min, max float64) error <span class="cov3" title="10">{
        value, exists := data[field]
        if !exists </span><span class="cov1" title="1">{
                return nil // Field is optional
        }</span>

        <span class="cov3" title="9">num, ok := value.(float64)
        if !ok </span><span class="cov2" title="4">{
                // Try to convert from int
                if intVal, ok := value.(int); ok </span><span class="cov2" title="3">{
                        num = float64(intVal)
                }</span> else<span class="cov1" title="1"> {
                        return fmt.Errorf("%s must be a number", field)
                }</span>
        }

        <span class="cov3" title="8">if min != 0 &amp;&amp; num &lt; min </span><span class="cov1" title="1">{
                return fmt.Errorf("%s must be at least %f", field, min)
        }</span>

        <span class="cov3" title="7">if max != 0 &amp;&amp; num &gt; max </span><span class="cov1" title="1">{
                return fmt.Errorf("%s must not exceed %f", field, max)
        }</span>

        <span class="cov3" title="6">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package store

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// connectionStore implements ConnectionStore using DynamoDB
type connectionStore struct {
        client    *dynamodb.Client
        tableName string
}

// NewConnectionStore creates a new DynamoDB-backed connection store
func NewConnectionStore(client *dynamodb.Client, tableName string) ConnectionStore <span class="cov1" title="1">{
        if tableName == "" </span><span class="cov0" title="0">{
                tableName = ConnectionsTable
        }</span>
        <span class="cov1" title="1">return &amp;connectionStore{
                client:    client,
                tableName: tableName,
        }</span>
}

// Save creates or updates a connection
func (s *connectionStore) Save(ctx context.Context, conn *Connection) error <span class="cov10" title="18">{
        if err := s.validateConnection(conn); err != nil </span><span class="cov6" title="5">{
                return err
        }</span>

        // Set TTL to 24 hours from now if not set
        <span class="cov8" title="13">if conn.TTL == 0 </span><span class="cov8" title="13">{
                conn.TTL = time.Now().Add(24 * time.Hour).Unix()
        }</span>

        // Marshal connection to DynamoDB attribute values
        <span class="cov8" title="13">item, err := attributevalue.MarshalMap(conn)
        if err != nil </span><span class="cov0" title="0">{
                return NewStoreError("Save", s.tableName, conn.ConnectionID, fmt.Errorf("failed to marshal connection: %w", err))
        }</span>

        // Put item in DynamoDB
        <span class="cov8" title="13">input := &amp;dynamodb.PutItemInput{
                TableName: aws.String(s.tableName),
                Item:      item,
        }

        _, err = s.client.PutItem(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return NewStoreError("Save", s.tableName, conn.ConnectionID, fmt.Errorf("failed to save connection: %w", err))
        }</span>

        <span class="cov8" title="13">return nil</span>
}

// Get retrieves a connection by ID
func (s *connectionStore) Get(ctx context.Context, connectionID string) (*Connection, error) <span class="cov7" title="7">{
        if connectionID == "" </span><span class="cov1" title="1">{
                return nil, NewValidationError("connectionID", "cannot be empty")
        }</span>

        <span class="cov6" title="6">input := &amp;dynamodb.GetItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "ConnectionID": &amp;types.AttributeValueMemberS{Value: connectionID},
                },
        }

        result, err := s.client.GetItem(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewStoreError("Get", s.tableName, connectionID, fmt.Errorf("failed to get connection: %w", err))
        }</span>

        <span class="cov6" title="6">if result.Item == nil </span><span class="cov4" title="3">{
                return nil, NewStoreError("Get", s.tableName, connectionID, ErrNotFound)
        }</span>

        <span class="cov4" title="3">var conn Connection
        err = attributevalue.UnmarshalMap(result.Item, &amp;conn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewStoreError("Get", s.tableName, connectionID, fmt.Errorf("failed to unmarshal connection: %w", err))
        }</span>

        <span class="cov4" title="3">return &amp;conn, nil</span>
}

// Delete removes a connection
func (s *connectionStore) Delete(ctx context.Context, connectionID string) error <span class="cov4" title="3">{
        if connectionID == "" </span><span class="cov0" title="0">{
                return NewValidationError("connectionID", "cannot be empty")
        }</span>

        <span class="cov4" title="3">input := &amp;dynamodb.DeleteItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "ConnectionID": &amp;types.AttributeValueMemberS{Value: connectionID},
                },
        }

        _, err := s.client.DeleteItem(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return NewStoreError("Delete", s.tableName, connectionID, fmt.Errorf("failed to delete connection: %w", err))
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// ListByUser returns all connections for a user
func (s *connectionStore) ListByUser(ctx context.Context, userID string) ([]*Connection, error) <span class="cov1" title="1">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, NewValidationError("userID", "cannot be empty")
        }</span>

        <span class="cov1" title="1">input := &amp;dynamodb.QueryInput{
                TableName:              aws.String(s.tableName),
                IndexName:              aws.String("UserIndex"),
                KeyConditionExpression: aws.String("UserID = :userID"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":userID": &amp;types.AttributeValueMemberS{Value: userID},
                },
        }

        return s.queryConnections(ctx, input)</span>
}

// ListByTenant returns all connections for a tenant
func (s *connectionStore) ListByTenant(ctx context.Context, tenantID string) ([]*Connection, error) <span class="cov1" title="1">{
        if tenantID == "" </span><span class="cov0" title="0">{
                return nil, NewValidationError("tenantID", "cannot be empty")
        }</span>

        <span class="cov1" title="1">input := &amp;dynamodb.QueryInput{
                TableName:              aws.String(s.tableName),
                IndexName:              aws.String("TenantIndex"),
                KeyConditionExpression: aws.String("TenantID = :tenantID"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":tenantID": &amp;types.AttributeValueMemberS{Value: tenantID},
                },
        }

        return s.queryConnections(ctx, input)</span>
}

// UpdateLastPing updates the last ping timestamp
func (s *connectionStore) UpdateLastPing(ctx context.Context, connectionID string) error <span class="cov3" title="2">{
        if connectionID == "" </span><span class="cov0" title="0">{
                return NewValidationError("connectionID", "cannot be empty")
        }</span>

        <span class="cov3" title="2">now := time.Now()
        input := &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "ConnectionID": &amp;types.AttributeValueMemberS{Value: connectionID},
                },
                UpdateExpression: aws.String("SET LastPing = :now, #ttl = :ttl"),
                ExpressionAttributeNames: map[string]string{
                        "#ttl": "TTL", // TTL is a reserved word in DynamoDB
                },
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":now": &amp;types.AttributeValueMemberS{Value: now.Format(time.RFC3339Nano)},
                        ":ttl": &amp;types.AttributeValueMemberN{Value: fmt.Sprintf("%d", now.Add(24*time.Hour).Unix())},
                },
                ConditionExpression: aws.String("attribute_exists(ConnectionID)"),
        }

        _, err := s.client.UpdateItem(ctx, input)
        if err != nil </span><span class="cov1" title="1">{
                var cfe *types.ConditionalCheckFailedException
                if errors.As(err, &amp;cfe) </span><span class="cov1" title="1">{
                        return NewStoreError("UpdateLastPing", s.tableName, connectionID, ErrNotFound)
                }</span>
                <span class="cov0" title="0">return NewStoreError("UpdateLastPing", s.tableName, connectionID, fmt.Errorf("failed to update last ping: %w", err))</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// DeleteStale removes connections older than the specified time
func (s *connectionStore) DeleteStale(ctx context.Context, before time.Time) error <span class="cov1" title="1">{
        // In production, this would be handled by DynamoDB TTL
        // This method is primarily for testing and manual cleanup

        // Scan for old connections
        input := &amp;dynamodb.ScanInput{
                TableName:        aws.String(s.tableName),
                FilterExpression: aws.String("LastPing &lt; :before"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":before": &amp;types.AttributeValueMemberS{Value: before.Format(time.RFC3339Nano)},
                },
        }

        paginator := dynamodb.NewScanPaginator(s.client, input)

        var deleteCount int
        for paginator.HasMorePages() </span><span class="cov1" title="1">{
                page, err := paginator.NextPage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return NewStoreError("DeleteStale", s.tableName, "", fmt.Errorf("failed to scan stale connections: %w", err))
                }</span>

                // Delete each stale connection
                <span class="cov1" title="1">for _, item := range page.Items </span><span class="cov1" title="1">{
                        if connID, ok := item["ConnectionID"].(*types.AttributeValueMemberS); ok </span><span class="cov1" title="1">{
                                if err := s.Delete(ctx, connID.Value); err != nil </span><span class="cov0" title="0">{
                                        // Log error but continue with other deletions
                                        fmt.Printf("Failed to delete stale connection %s: %v\n", connID.Value, err)
                                }</span> else<span class="cov1" title="1"> {
                                        deleteCount++
                                }</span>
                        }
                }
        }

        <span class="cov1" title="1">return nil</span>
}

// queryConnections executes a query and returns connections
func (s *connectionStore) queryConnections(ctx context.Context, input *dynamodb.QueryInput) ([]*Connection, error) <span class="cov3" title="2">{
        var connections []*Connection

        paginator := dynamodb.NewQueryPaginator(s.client, input)
        for paginator.HasMorePages() </span><span class="cov3" title="2">{
                page, err := paginator.NextPage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to query connections: %w", err)
                }</span>

                <span class="cov3" title="2">for _, item := range page.Items </span><span class="cov6" title="6">{
                        var conn Connection
                        if err := attributevalue.UnmarshalMap(item, &amp;conn); err != nil </span><span class="cov0" title="0">{
                                // Skip invalid items
                                continue</span>
                        }
                        <span class="cov6" title="6">connections = append(connections, &amp;conn)</span>
                }
        }

        <span class="cov3" title="2">return connections, nil</span>
}

// validateConnection validates a connection before saving
func (s *connectionStore) validateConnection(conn *Connection) error <span class="cov10" title="18">{
        if conn == nil </span><span class="cov1" title="1">{
                return NewValidationError("connection", "cannot be nil")
        }</span>
        <span class="cov9" title="17">if conn.ConnectionID == "" </span><span class="cov1" title="1">{
                return NewValidationError("ConnectionID", "cannot be empty")
        }</span>
        <span class="cov9" title="16">if conn.UserID == "" </span><span class="cov1" title="1">{
                return NewValidationError("UserID", "cannot be empty")
        }</span>
        <span class="cov9" title="15">if conn.TenantID == "" </span><span class="cov1" title="1">{
                return NewValidationError("TenantID", "cannot be empty")
        }</span>
        <span class="cov9" title="14">if conn.Endpoint == "" </span><span class="cov1" title="1">{
                return NewValidationError("Endpoint", "cannot be empty")
        }</span>
        <span class="cov8" title="13">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package dynamorm

import (
        "context"
        "fmt"
        "time"

        "github.com/pay-theory/dynamorm/pkg/core"
        "github.com/pay-theory/streamer/internal/store"
)

// connectionStore implements ConnectionStore using DynamORM
type connectionStore struct {
        db core.DB
}

// NewConnectionStore creates a new DynamORM-backed connection store
func NewConnectionStore(db core.DB) store.ConnectionStore <span class="cov10" title="30">{
        return &amp;connectionStore{
                db: db,
        }
}</span>

// Save creates or updates a connection
func (s *connectionStore) Save(ctx context.Context, conn *store.Connection) error <span class="cov6" title="8">{
        if err := s.validateConnection(conn); err != nil </span><span class="cov5" title="5">{
                return err
        }</span>

        // Set TTL to 24 hours from now if not set
        <span class="cov3" title="3">if conn.TTL == 0 </span><span class="cov3" title="3">{
                conn.TTL = time.Now().Add(24 * time.Hour).Unix()
        }</span>

        // Convert to DynamORM model
        <span class="cov3" title="3">dynamormConn := &amp;Connection{}
        dynamormConn.FromStoreModel(conn)

        // Create or update the connection
        if err := s.db.Model(dynamormConn).Create(); err != nil </span><span class="cov1" title="1">{
                return store.NewStoreError("Save", dynamormConn.TableName(), conn.ConnectionID, fmt.Errorf("failed to save connection: %w", err))
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// Get retrieves a connection by ID
func (s *connectionStore) Get(ctx context.Context, connectionID string) (*store.Connection, error) <span class="cov4" title="4">{
        if connectionID == "" </span><span class="cov1" title="1">{
                return nil, store.NewValidationError("connectionID", "cannot be empty")
        }</span>

        // Create model with keys
        <span class="cov3" title="3">conn := &amp;Connection{ConnectionID: connectionID}
        conn.SetKeys()

        // Find the connection using composite key
        if err := s.db.Model(conn).
                Where("pk", "=", conn.PK).
                Where("sk", "=", conn.SK).
                First(conn); err != nil </span><span class="cov2" title="2">{
                if err.Error() == "item not found" </span><span class="cov1" title="1">{
                        return nil, store.NewStoreError("Get", conn.TableName(), connectionID, store.ErrNotFound)
                }</span>
                <span class="cov1" title="1">return nil, store.NewStoreError("Get", conn.TableName(), connectionID, fmt.Errorf("failed to get connection: %w", err))</span>
        }

        <span class="cov1" title="1">return conn.ToStoreModel(), nil</span>
}

// Delete removes a connection
func (s *connectionStore) Delete(ctx context.Context, connectionID string) error <span class="cov5" title="5">{
        if connectionID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("connectionID", "cannot be empty")
        }</span>

        // Create model with keys
        <span class="cov4" title="4">conn := &amp;Connection{ConnectionID: connectionID}
        conn.SetKeys()

        // Delete the connection
        if err := s.db.Model(conn).Delete(); err != nil </span><span class="cov1" title="1">{
                return store.NewStoreError("Delete", conn.TableName(), connectionID, fmt.Errorf("failed to delete connection: %w", err))
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// ListByUser returns all connections for a user
func (s *connectionStore) ListByUser(ctx context.Context, userID string) ([]*store.Connection, error) <span class="cov4" title="4">{
        if userID == "" </span><span class="cov1" title="1">{
                return nil, store.NewValidationError("userID", "cannot be empty")
        }</span>

        <span class="cov3" title="3">var connections []Connection

        // Query using the user index with v1.0.9 API
        if err := s.db.Model(&amp;Connection{}).
                Index("user-index").
                Where("user_id", "=", userID).
                All(&amp;connections); err != nil </span><span class="cov1" title="1">{
                return nil, store.NewStoreError("ListByUser", store.ConnectionsTable, userID, fmt.Errorf("failed to list connections by user: %w", err))
        }</span>

        // Convert to store models
        <span class="cov2" title="2">result := make([]*store.Connection, len(connections))
        for i := range connections </span><span class="cov2" title="2">{
                result[i] = connections[i].ToStoreModel()
        }</span>

        <span class="cov2" title="2">return result, nil</span>
}

// ListByTenant returns all connections for a tenant
func (s *connectionStore) ListByTenant(ctx context.Context, tenantID string) ([]*store.Connection, error) <span class="cov3" title="3">{
        if tenantID == "" </span><span class="cov1" title="1">{
                return nil, store.NewValidationError("tenantID", "cannot be empty")
        }</span>

        <span class="cov2" title="2">var connections []Connection

        // Query using the tenant index with v1.0.9 API
        if err := s.db.Model(&amp;Connection{}).
                Index("tenant-index").
                Where("tenant_id", "=", tenantID).
                All(&amp;connections); err != nil </span><span class="cov1" title="1">{
                return nil, store.NewStoreError("ListByTenant", store.ConnectionsTable, tenantID, fmt.Errorf("failed to list connections by tenant: %w", err))
        }</span>

        // Convert to store models
        <span class="cov1" title="1">result := make([]*store.Connection, len(connections))
        for i := range connections </span><span class="cov2" title="2">{
                result[i] = connections[i].ToStoreModel()
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// UpdateLastPing updates the last ping timestamp
func (s *connectionStore) UpdateLastPing(ctx context.Context, connectionID string) error <span class="cov4" title="4">{
        if connectionID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("connectionID", "cannot be empty")
        }</span>

        // Create model with keys
        <span class="cov3" title="3">conn := &amp;Connection{ConnectionID: connectionID}
        conn.SetKeys()

        now := time.Now()

        // Update using DynamORM's update builder
        err := s.db.Model(conn).
                UpdateBuilder().
                Set("last_ping", now).
                Set("ttl", now.Add(24*time.Hour).Unix()).
                Execute()

        if err != nil </span><span class="cov2" title="2">{
                if err.Error() == "item not found" </span><span class="cov1" title="1">{
                        return store.NewStoreError("UpdateLastPing", conn.TableName(), connectionID, store.ErrNotFound)
                }</span>
                <span class="cov1" title="1">return store.NewStoreError("UpdateLastPing", conn.TableName(), connectionID, fmt.Errorf("failed to update last ping: %w", err))</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// DeleteStale removes connections older than the specified time
func (s *connectionStore) DeleteStale(ctx context.Context, before time.Time) error <span class="cov3" title="3">{
        // In production, this would be handled by DynamoDB TTL
        // This method is primarily for testing and manual cleanup

        var connections []Connection

        // Scan for old connections using v1.0.9 API
        if err := s.db.Model(&amp;Connection{}).
                Where("last_ping", "&lt;", before).
                Scan(&amp;connections); err != nil </span><span class="cov1" title="1">{
                return store.NewStoreError("DeleteStale", store.ConnectionsTable, "", fmt.Errorf("failed to scan stale connections: %w", err))
        }</span>

        // Delete each stale connection
        <span class="cov2" title="2">deleteCount := 0
        for i := range connections </span><span class="cov2" title="2">{
                if err := s.Delete(ctx, connections[i].ConnectionID); err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other deletions
                        fmt.Printf("Failed to delete stale connection %s: %v\n", connections[i].ConnectionID, err)
                }</span> else<span class="cov2" title="2"> {
                        deleteCount++
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// validateConnection validates a connection before saving
func (s *connectionStore) validateConnection(conn *store.Connection) error <span class="cov6" title="8">{
        if conn == nil </span><span class="cov1" title="1">{
                return store.NewValidationError("connection", "cannot be nil")
        }</span>
        <span class="cov6" title="7">if conn.ConnectionID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("ConnectionID", "cannot be empty")
        }</span>
        <span class="cov5" title="6">if conn.UserID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("UserID", "cannot be empty")
        }</span>
        <span class="cov5" title="5">if conn.TenantID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("TenantID", "cannot be empty")
        }</span>
        <span class="cov4" title="4">if conn.Endpoint == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("Endpoint", "cannot be empty")
        }</span>
        <span class="cov3" title="3">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dynamorm

import (
        "context"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/pay-theory/dynamorm"
        "github.com/pay-theory/dynamorm/pkg/session"
        "github.com/pay-theory/streamer/internal/store"
)

// StoreFactory creates all the necessary stores using DynamORM
type StoreFactory struct {
        db                *dynamorm.DB
        connectionStore   store.ConnectionStore
        requestQueue      store.RequestQueue
        subscriptionStore store.SubscriptionStore
}

// NewStoreFactory creates a new DynamORM store factory
func NewStoreFactory(config session.Config) (*StoreFactory, error) <span class="cov0" title="0">{
        // Initialize DynamORM
        db, err := dynamorm.New(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize DynamORM: %w", err)
        }</span>

        // Type assert to get the correct DB type
        <span class="cov0" title="0">dynamormDB, ok := db.(*dynamorm.DB)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get DynamORM DB instance")
        }</span>

        // Create stores
        <span class="cov0" title="0">factory := &amp;StoreFactory{
                db:              dynamormDB,
                connectionStore: NewConnectionStore(dynamormDB),
                requestQueue:    NewRequestQueue(dynamormDB),
                // TODO: Implement subscription store
                // subscriptionStore: NewSubscriptionStore(dynamormDB),
        }

        return factory, nil</span>
}

// NewStoreFactoryFromClient creates a new factory from an existing DynamoDB client
// This is useful for Lambda functions that already have a client configured
func NewStoreFactoryFromClient(client *dynamodb.Client, region string) (*StoreFactory, error) <span class="cov0" title="0">{
        // For now, we'll create a new DynamORM instance with the region
        // In production, you might want to reuse the existing client configuration
        config := session.Config{
                Region: region,
        }

        return NewStoreFactory(config)
}</span>

// ConnectionStore returns the connection store
func (f *StoreFactory) ConnectionStore() store.ConnectionStore <span class="cov0" title="0">{
        return f.connectionStore
}</span>

// RequestQueue returns the request queue
func (f *StoreFactory) RequestQueue() store.RequestQueue <span class="cov0" title="0">{
        return f.requestQueue
}</span>

// SubscriptionStore returns the subscription store
func (f *StoreFactory) SubscriptionStore() store.SubscriptionStore <span class="cov0" title="0">{
        return f.subscriptionStore
}</span>

// DB returns the underlying DynamORM database instance
func (f *StoreFactory) DB() *dynamorm.DB <span class="cov0" title="0">{
        return f.db
}</span>

// EnsureTables creates the required DynamoDB tables if they don't exist
// This should only be used in development/testing environments
func (f *StoreFactory) EnsureTables(ctx context.Context) error <span class="cov0" title="0">{
        // Connection table
        connTable := &amp;Connection{}
        if err := f.db.AutoMigrate(connTable); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure connections table: %w", err)
        }</span>

        // Request table
        <span class="cov0" title="0">reqTable := &amp;AsyncRequest{}
        if err := f.db.AutoMigrate(reqTable); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure requests table: %w", err)
        }</span>

        // Subscription table
        <span class="cov0" title="0">subTable := &amp;Subscription{}
        if err := f.db.AutoMigrate(subTable); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure subscriptions table: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package dynamorm

import (
        "fmt"
        "time"

        "github.com/pay-theory/streamer/internal/store"
)

// Connection represents a WebSocket connection with DynamORM
type Connection struct {
        // DynamORM composite key pattern
        PK string `dynamorm:"pk"`
        SK string `dynamorm:"sk"`

        // Connection data
        ConnectionID string    `dynamorm:"connection_id"`
        UserID       string    `dynamorm:"user_id" dynamorm-index:"user-index,pk"`
        TenantID     string    `dynamorm:"tenant_id" dynamorm-index:"tenant-index,pk"`
        Endpoint     string    `dynamorm:"endpoint"`
        ConnectedAt  time.Time `dynamorm:"connected_at"`
        LastPing     time.Time `dynamorm:"last_ping"`

        // Metadata for storing additional information
        Metadata map[string]string `dynamorm:"metadata,omitempty"`

        // TTL for automatic cleanup
        TTL int64 `dynamorm:"ttl,omitempty"`
}

// TableName returns the DynamoDB table name
func (c *Connection) TableName() string <span class="cov5" title="7">{
        return store.ConnectionsTable
}</span>

// SetKeys sets the composite keys for the connection
func (c *Connection) SetKeys() <span class="cov7" title="19">{
        c.PK = fmt.Sprintf("CONN#%s", c.ConnectionID)
        c.SK = "METADATA"
}</span>

// ToStoreModel converts to the store.Connection model
func (c *Connection) ToStoreModel() *store.Connection <span class="cov5" title="6">{
        return &amp;store.Connection{
                ConnectionID: c.ConnectionID,
                UserID:       c.UserID,
                TenantID:     c.TenantID,
                Endpoint:     c.Endpoint,
                ConnectedAt:  c.ConnectedAt,
                LastPing:     c.LastPing,
                Metadata:     c.Metadata,
                TTL:          c.TTL,
        }
}</span>

// FromStoreModel converts from the store.Connection model
func (c *Connection) FromStoreModel(conn *store.Connection) <span class="cov4" title="4">{
        c.ConnectionID = conn.ConnectionID
        c.UserID = conn.UserID
        c.TenantID = conn.TenantID
        c.Endpoint = conn.Endpoint
        c.ConnectedAt = conn.ConnectedAt
        c.LastPing = conn.LastPing
        c.Metadata = conn.Metadata
        c.TTL = conn.TTL
        c.SetKeys()
}</span>

// AsyncRequest represents a queued async request with DynamORM
type AsyncRequest struct {
        // DynamORM composite key pattern
        PK string `dynamorm:"pk"`
        SK string `dynamorm:"sk"`

        // Request data
        RequestID    string                 `dynamorm:"request_id"`
        ConnectionID string                 `dynamorm:"connection_id" dynamorm-index:"connection-index,pk"`
        Status       store.RequestStatus    `dynamorm:"status" dynamorm-index:"status-index,sk"`
        CreatedAt    time.Time              `dynamorm:"created_at"`
        Action       string                 `dynamorm:"action"`
        Payload      map[string]interface{} `dynamorm:"payload,omitempty"`

        // Processing information
        ProcessingStarted *time.Time `dynamorm:"processing_started,omitempty"`
        ProcessingEnded   *time.Time `dynamorm:"processing_ended,omitempty"`

        // Result or error
        Result map[string]interface{} `dynamorm:"result,omitempty"`
        Error  string                 `dynamorm:"error,omitempty"`

        // Progress tracking
        Progress        float64                `dynamorm:"progress"`
        ProgressMessage string                 `dynamorm:"progress_message,omitempty"`
        ProgressDetails map[string]interface{} `dynamorm:"progress_details,omitempty"`

        // Retry information
        RetryCount int       `dynamorm:"retry_count"`
        MaxRetries int       `dynamorm:"max_retries"`
        RetryAfter time.Time `dynamorm:"retry_after,omitempty"`

        // User and tenant for querying
        UserID   string `dynamorm:"user_id" dynamorm-index:"user-index,sk"`
        TenantID string `dynamorm:"tenant_id" dynamorm-index:"tenant-index,sk"`

        // TTL for automatic cleanup
        TTL int64 `dynamorm:"ttl,omitempty"`
}

// TableName returns the DynamoDB table name
func (r *AsyncRequest) TableName() string <span class="cov4" title="5">{
        return store.RequestsTable
}</span>

// SetKeys sets the composite keys for the request
func (r *AsyncRequest) SetKeys() <span class="cov10" title="48">{
        r.PK = fmt.Sprintf("REQ#%s", r.RequestID)
        r.SK = fmt.Sprintf("STATUS#%s", r.Status)
}</span>

// ToStoreModel converts to the store.AsyncRequest model
func (r *AsyncRequest) ToStoreModel() *store.AsyncRequest <span class="cov7" title="17">{
        return &amp;store.AsyncRequest{
                RequestID:         r.RequestID,
                ConnectionID:      r.ConnectionID,
                Status:            r.Status,
                CreatedAt:         r.CreatedAt,
                Action:            r.Action,
                Payload:           r.Payload,
                ProcessingStarted: r.ProcessingStarted,
                ProcessingEnded:   r.ProcessingEnded,
                Result:            r.Result,
                Error:             r.Error,
                Progress:          r.Progress,
                ProgressMessage:   r.ProgressMessage,
                ProgressDetails:   r.ProgressDetails,
                RetryCount:        r.RetryCount,
                MaxRetries:        r.MaxRetries,
                RetryAfter:        r.RetryAfter,
                UserID:            r.UserID,
                TenantID:          r.TenantID,
                TTL:               r.TTL,
        }
}</span>

// FromStoreModel converts from the store.AsyncRequest model
func (r *AsyncRequest) FromStoreModel(req *store.AsyncRequest) <span class="cov5" title="7">{
        r.RequestID = req.RequestID
        r.ConnectionID = req.ConnectionID
        r.Status = req.Status
        r.CreatedAt = req.CreatedAt
        r.Action = req.Action
        r.Payload = req.Payload
        r.ProcessingStarted = req.ProcessingStarted
        r.ProcessingEnded = req.ProcessingEnded
        r.Result = req.Result
        r.Error = req.Error
        r.Progress = req.Progress
        r.ProgressMessage = req.ProgressMessage
        r.ProgressDetails = req.ProgressDetails
        r.RetryCount = req.RetryCount
        r.MaxRetries = req.MaxRetries
        r.RetryAfter = req.RetryAfter
        r.UserID = req.UserID
        r.TenantID = req.TenantID
        r.TTL = req.TTL
        r.SetKeys()
}</span>

// Subscription represents a real-time update subscription with DynamORM
type Subscription struct {
        // DynamORM composite key pattern
        PK string `dynamorm:"pk"`
        SK string `dynamorm:"sk"`

        // Subscription data
        SubscriptionID string    `dynamorm:"subscription_id"`
        ConnectionID   string    `dynamorm:"connection_id" dynamorm-index:"connection-index,pk"`
        RequestID      string    `dynamorm:"request_id" dynamorm-index:"request-index,pk"`
        EventTypes     []string  `dynamorm:"event_types,stringset"`
        CreatedAt      time.Time `dynamorm:"created_at"`

        // TTL for automatic cleanup
        TTL int64 `dynamorm:"ttl,omitempty"`
}

// TableName returns the DynamoDB table name
func (s *Subscription) TableName() string <span class="cov1" title="1">{
        return store.SubscriptionsTable
}</span>

// SetKeys sets the composite keys for the subscription
func (s *Subscription) SetKeys() <span class="cov4" title="4">{
        s.PK = fmt.Sprintf("CONN#%s", s.ConnectionID)
        s.SK = fmt.Sprintf("SUB#%s", s.RequestID)
        s.SubscriptionID = fmt.Sprintf("%s#%s", s.ConnectionID, s.RequestID)
}</span>

// ToStoreModel converts to the store.Subscription model
func (s *Subscription) ToStoreModel() *store.Subscription <span class="cov1" title="1">{
        return &amp;store.Subscription{
                SubscriptionID: s.SubscriptionID,
                ConnectionID:   s.ConnectionID,
                RequestID:      s.RequestID,
                EventTypes:     s.EventTypes,
                CreatedAt:      s.CreatedAt,
                TTL:            s.TTL,
        }
}</span>

// FromStoreModel converts from the store.Subscription model
func (s *Subscription) FromStoreModel(sub *store.Subscription) <span class="cov1" title="1">{
        s.SubscriptionID = sub.SubscriptionID
        s.ConnectionID = sub.ConnectionID
        s.RequestID = sub.RequestID
        s.EventTypes = sub.EventTypes
        s.CreatedAt = sub.CreatedAt
        s.TTL = sub.TTL
        s.SetKeys()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package dynamorm

import (
        "context"
        "fmt"
        "time"

        "github.com/pay-theory/dynamorm/pkg/core"
        "github.com/pay-theory/streamer/internal/store"
)

// requestQueue implements RequestQueue using DynamORM
type requestQueue struct {
        db core.DB
}

// NewRequestQueue creates a new DynamORM-backed request queue
func NewRequestQueue(db core.DB) store.RequestQueue <span class="cov10" title="28">{
        return &amp;requestQueue{
                db: db,
        }
}</span>

// Enqueue adds a new request to the queue
func (q *requestQueue) Enqueue(ctx context.Context, req *store.AsyncRequest) error <span class="cov5" title="6">{
        if err := q.validateRequest(req); err != nil </span><span class="cov4" title="4">{
                return err
        }</span>

        // Set default values
        <span class="cov2" title="2">if req.Status == "" </span><span class="cov0" title="0">{
                req.Status = store.StatusPending
        }</span>
        <span class="cov2" title="2">if req.CreatedAt.IsZero() </span><span class="cov1" title="1">{
                req.CreatedAt = time.Now()
        }</span>
        <span class="cov2" title="2">if req.TTL == 0 </span><span class="cov2" title="2">{
                req.TTL = time.Now().Add(7 * 24 * time.Hour).Unix() // 7 days TTL
        }</span>

        // Convert to DynamORM model
        <span class="cov2" title="2">dynamormReq := &amp;AsyncRequest{}
        dynamormReq.FromStoreModel(req)

        // Create the request
        if err := q.db.Model(dynamormReq).Create(); err != nil </span><span class="cov1" title="1">{
                return store.NewStoreError("Enqueue", dynamormReq.TableName(), req.RequestID, fmt.Errorf("failed to enqueue request: %w", err))
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Get retrieves a specific request
func (q *requestQueue) Get(ctx context.Context, requestID string) (*store.AsyncRequest, error) <span class="cov8" title="16">{
        if requestID == "" </span><span class="cov3" title="3">{
                return nil, store.NewValidationError("requestID", "cannot be empty")
        }</span>

        // Create model with keys
        <span class="cov7" title="13">req := &amp;AsyncRequest{RequestID: requestID}
        req.SetKeys()

        // Query for the request (need to handle multiple statuses)
        var requests []AsyncRequest
        if err := q.db.Model(&amp;AsyncRequest{}).
                Where("pk", "=", req.PK).
                All(&amp;requests); err != nil </span><span class="cov0" title="0">{
                return nil, store.NewStoreError("Get", req.TableName(), requestID, fmt.Errorf("failed to get request: %w", err))
        }</span>

        <span class="cov7" title="13">if len(requests) == 0 </span><span class="cov1" title="1">{
                return nil, store.NewStoreError("Get", req.TableName(), requestID, store.ErrNotFound)
        }</span>

        // Return the first (should be only) result
        <span class="cov7" title="12">return requests[0].ToStoreModel(), nil</span>
}

// UpdateStatus updates the status of a request
func (q *requestQueue) UpdateStatus(ctx context.Context, requestID string, status store.RequestStatus, message string) error <span class="cov5" title="5">{
        if requestID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("requestID", "cannot be empty")
        }</span>

        // Get the current request to find its current status
        <span class="cov4" title="4">current, err := q.Get(ctx, requestID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Delete old status entry
        <span class="cov4" title="4">oldReq := &amp;AsyncRequest{RequestID: requestID, Status: current.Status}
        oldReq.SetKeys()
        if err := q.db.Model(oldReq).Delete(); err != nil </span><span class="cov0" title="0">{
                // Log but don't fail
                fmt.Printf("Failed to delete old status entry: %v\n", err)
        }</span>

        // Create new status entry
        <span class="cov4" title="4">newReq := &amp;AsyncRequest{}
        newReq.FromStoreModel(current)
        newReq.Status = status
        newReq.SetKeys()

        if err := q.db.Model(newReq).Create(); err != nil </span><span class="cov1" title="1">{
                return store.NewStoreError("UpdateStatus", newReq.TableName(), requestID, fmt.Errorf("failed to update status: %w", err))
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// UpdateProgress updates the progress of a request
func (q *requestQueue) UpdateProgress(ctx context.Context, requestID string, progress float64, message string, details map[string]interface{}) error <span class="cov4" title="4">{
        if requestID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("requestID", "cannot be empty")
        }</span>

        // Get current request
        <span class="cov3" title="3">current, err := q.Get(ctx, requestID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">req := &amp;AsyncRequest{RequestID: requestID, Status: current.Status}
        req.SetKeys()

        // Update progress fields
        err = q.db.Model(req).
                UpdateBuilder().
                Set("progress", progress).
                Set("progress_message", message).
                Set("progress_details", details).
                Execute()

        if err != nil </span><span class="cov0" title="0">{
                return store.NewStoreError("UpdateProgress", req.TableName(), requestID, fmt.Errorf("failed to update progress: %w", err))
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// CompleteRequest marks a request as completed with results
func (q *requestQueue) CompleteRequest(ctx context.Context, requestID string, result map[string]interface{}) error <span class="cov2" title="2">{
        now := time.Now()

        // Get current request
        current, err := q.Get(ctx, requestID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Update status to completed
        <span class="cov1" title="1">current.Status = store.StatusCompleted
        current.ProcessingEnded = &amp;now
        current.Result = result
        current.Progress = 100

        // Delete old entry and create new one with updated status
        return q.UpdateStatus(ctx, requestID, store.StatusCompleted, "Request completed successfully")</span>
}

// FailRequest marks a request as failed with an error
func (q *requestQueue) FailRequest(ctx context.Context, requestID string, errMsg string) error <span class="cov2" title="2">{
        now := time.Now()

        // Get current request
        current, err := q.Get(ctx, requestID)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Update status to failed
        <span class="cov1" title="1">current.Status = store.StatusFailed
        current.ProcessingEnded = &amp;now
        current.Error = errMsg

        // Delete old entry and create new one with updated status
        return q.UpdateStatus(ctx, requestID, store.StatusFailed, errMsg)</span>
}

// GetByConnection retrieves all requests for a connection
func (q *requestQueue) GetByConnection(ctx context.Context, connectionID string, limit int) ([]*store.AsyncRequest, error) <span class="cov2" title="2">{
        if connectionID == "" </span><span class="cov1" title="1">{
                return nil, store.NewValidationError("connectionID", "cannot be empty")
        }</span>

        <span class="cov1" title="1">var requests []AsyncRequest

        // Query using the connection index with v1.0.9 API
        query := q.db.Model(&amp;AsyncRequest{}).
                Index("connection-index").
                Where("connection_id", "=", connectionID)

        if limit &gt; 0 </span><span class="cov1" title="1">{
                query = query.Limit(limit)
        }</span>

        <span class="cov1" title="1">if err := query.All(&amp;requests); err != nil </span><span class="cov0" title="0">{
                return nil, store.NewStoreError("GetByConnection", store.RequestsTable, connectionID, fmt.Errorf("failed to get requests by connection: %w", err))
        }</span>

        // Convert to store models
        <span class="cov1" title="1">result := make([]*store.AsyncRequest, len(requests))
        for i := range requests </span><span class="cov2" title="2">{
                result[i] = requests[i].ToStoreModel()
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// GetByStatus retrieves requests by status
func (q *requestQueue) GetByStatus(ctx context.Context, status store.RequestStatus, limit int) ([]*store.AsyncRequest, error) <span class="cov2" title="2">{
        var requests []AsyncRequest

        // Query using the status index with v1.0.9 API
        query := q.db.Model(&amp;AsyncRequest{}).
                Index("status-index").
                Where("status", "=", status)

        if limit &gt; 0 </span><span class="cov2" title="2">{
                query = query.Limit(limit)
        }</span>

        <span class="cov2" title="2">if err := query.All(&amp;requests); err != nil </span><span class="cov0" title="0">{
                return nil, store.NewStoreError("GetByStatus", store.RequestsTable, string(status), fmt.Errorf("failed to get requests by status: %w", err))
        }</span>

        // Convert to store models
        <span class="cov2" title="2">result := make([]*store.AsyncRequest, len(requests))
        for i := range requests </span><span class="cov2" title="2">{
                result[i] = requests[i].ToStoreModel()
        }</span>

        <span class="cov2" title="2">return result, nil</span>
}

// Dequeue retrieves and marks requests for processing
func (q *requestQueue) Dequeue(ctx context.Context, limit int) ([]*store.AsyncRequest, error) <span class="cov0" title="0">{
        // Get pending requests
        requests, err := q.GetByStatus(ctx, store.StatusPending, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Mark each as processing
        <span class="cov0" title="0">for _, req := range requests </span><span class="cov0" title="0">{
                if err := q.UpdateStatus(ctx, req.RequestID, store.StatusProcessing, "Dequeued for processing"); err != nil </span><span class="cov0" title="0">{
                        // Log error but continue
                        fmt.Printf("Failed to update status for request %s: %v\n", req.RequestID, err)
                }</span>
        }

        <span class="cov0" title="0">return requests, nil</span>
}

// Delete removes a request
func (q *requestQueue) Delete(ctx context.Context, requestID string) error <span class="cov3" title="3">{
        if requestID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("requestID", "cannot be empty")
        }</span>

        // Get the request to find its status
        <span class="cov2" title="2">current, err := q.Get(ctx, requestID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create model with keys
        <span class="cov2" title="2">req := &amp;AsyncRequest{RequestID: requestID, Status: current.Status}
        req.SetKeys()

        // Delete the request
        if err := q.db.Model(req).Delete(); err != nil </span><span class="cov1" title="1">{
                return store.NewStoreError("Delete", req.TableName(), requestID, fmt.Errorf("failed to delete request: %w", err))
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// validateRequest validates a request before saving
func (q *requestQueue) validateRequest(req *store.AsyncRequest) error <span class="cov5" title="6">{
        if req == nil </span><span class="cov1" title="1">{
                return store.NewValidationError("request", "cannot be nil")
        }</span>
        <span class="cov5" title="5">if req.RequestID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("RequestID", "cannot be empty")
        }</span>
        <span class="cov4" title="4">if req.ConnectionID == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("ConnectionID", "cannot be empty")
        }</span>
        <span class="cov3" title="3">if req.Action == "" </span><span class="cov1" title="1">{
                return store.NewValidationError("Action", "cannot be empty")
        }</span>
        <span class="cov2" title="2">if req.UserID == "" </span><span class="cov0" title="0">{
                return store.NewValidationError("UserID", "cannot be empty")
        }</span>
        <span class="cov2" title="2">if req.TenantID == "" </span><span class="cov0" title="0">{
                return store.NewValidationError("TenantID", "cannot be empty")
        }</span>
        <span class="cov2" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package store

import (
        "errors"
        "fmt"
)

// Common errors
var (
        // ErrNotFound is returned when an item is not found in DynamoDB
        ErrNotFound = errors.New("item not found")

        // ErrAlreadyExists is returned when trying to create an item that already exists
        ErrAlreadyExists = errors.New("item already exists")

        // ErrInvalidInput is returned when input validation fails
        ErrInvalidInput = errors.New("invalid input")

        // ErrConnectionClosed is returned when operating on a closed connection
        ErrConnectionClosed = errors.New("connection is closed")

        // ErrRequestNotPending is returned when trying to process a non-pending request
        ErrRequestNotPending = errors.New("request is not in pending state")

        // ErrConcurrentModification is returned when an item was modified concurrently
        ErrConcurrentModification = errors.New("item was modified concurrently")
)

// StoreError wraps storage-related errors with additional context
type StoreError struct {
        Op      string // Operation that failed
        Table   string // DynamoDB table
        Key     string // Item key
        Err     error  // Underlying error
        Message string // Additional context
}

// Error implements the error interface
func (e *StoreError) Error() string <span class="cov6" title="7">{
        if e.Message != "" </span><span class="cov4" title="3">{
                return fmt.Sprintf("%s %s (table=%s, key=%s): %s - %v",
                        e.Op, e.Message, e.Table, e.Key, e.Message, e.Err)
        }</span>
        <span class="cov4" title="4">return fmt.Sprintf("%s failed (table=%s, key=%s): %v",
                e.Op, e.Table, e.Key, e.Err)</span>
}

// Unwrap returns the underlying error
func (e *StoreError) Unwrap() error <span class="cov2" title="2">{
        return e.Err
}</span>

// Is checks if the error matches the target
func (e *StoreError) Is(target error) bool <span class="cov9" title="18">{
        return errors.Is(e.Err, target)
}</span>

// NewStoreError creates a new storage error
func NewStoreError(op, table, key string, err error) *StoreError <span class="cov9" title="19">{
        return &amp;StoreError{
                Op:    op,
                Table: table,
                Key:   key,
                Err:   err,
        }
}</span>

// IsNotFound checks if an error is a not found error
func IsNotFound(err error) bool <span class="cov8" title="13">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov7" title="12">var storeErr *StoreError
        if errors.As(err, &amp;storeErr) </span><span class="cov7" title="9">{
                return errors.Is(storeErr.Err, ErrNotFound)
        }</span>

        <span class="cov4" title="3">return errors.Is(err, ErrNotFound)</span>
}

// IsAlreadyExists checks if an error is an already exists error
func IsAlreadyExists(err error) bool <span class="cov5" title="5">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov4" title="4">var storeErr *StoreError
        if errors.As(err, &amp;storeErr) </span><span class="cov1" title="1">{
                return errors.Is(storeErr.Err, ErrAlreadyExists)
        }</span>

        <span class="cov4" title="3">return errors.Is(err, ErrAlreadyExists)</span>
}

// ValidationError represents input validation errors
type ValidationError struct {
        Field   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov8" title="16">{
        return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}</span>

// NewValidationError creates a new validation error
func NewValidationError(field, message string) error <span class="cov10" title="25">{
        return &amp;ValidationError{
                Field:   field,
                Message: message,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package store

import (
        "context"
        "fmt"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// TableDefinition holds the configuration for a DynamoDB table
type TableDefinition struct {
        TableName              string
        AttributeDefinitions   []types.AttributeDefinition
        KeySchema              []types.KeySchemaElement
        GlobalSecondaryIndexes []types.GlobalSecondaryIndex
        BillingMode            types.BillingMode
}

// GetTableDefinitions returns all table definitions for Streamer
func GetTableDefinitions() []TableDefinition <span class="cov0" title="0">{
        return []TableDefinition{
                getConnectionsTableDefinition(),
                getRequestsTableDefinition(),
                getSubscriptionsTableDefinition(),
        }
}</span>

// getConnectionsTableDefinition returns the definition for the connections table
func getConnectionsTableDefinition() TableDefinition <span class="cov0" title="0">{
        return TableDefinition{
                TableName: ConnectionsTable,
                AttributeDefinitions: []types.AttributeDefinition{
                        {
                                AttributeName: aws.String("ConnectionID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("UserID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("TenantID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                },
                KeySchema: []types.KeySchemaElement{
                        {
                                AttributeName: aws.String("ConnectionID"),
                                KeyType:       types.KeyTypeHash,
                        },
                },
                GlobalSecondaryIndexes: []types.GlobalSecondaryIndex{
                        {
                                IndexName: aws.String("UserIndex"),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("UserID"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                        },
                        {
                                IndexName: aws.String("TenantIndex"),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("TenantID"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                        },
                },
                BillingMode: types.BillingModePayPerRequest,
        }
}</span>

// getRequestsTableDefinition returns the definition for the requests table
func getRequestsTableDefinition() TableDefinition <span class="cov0" title="0">{
        return TableDefinition{
                TableName: RequestsTable,
                AttributeDefinitions: []types.AttributeDefinition{
                        {
                                AttributeName: aws.String("RequestID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("ConnectionID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("Status"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("CreatedAt"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                },
                KeySchema: []types.KeySchemaElement{
                        {
                                AttributeName: aws.String("RequestID"),
                                KeyType:       types.KeyTypeHash,
                        },
                },
                GlobalSecondaryIndexes: []types.GlobalSecondaryIndex{
                        {
                                IndexName: aws.String("ConnectionIndex"),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("ConnectionID"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                        {
                                                AttributeName: aws.String("CreatedAt"),
                                                KeyType:       types.KeyTypeRange,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                        },
                        {
                                IndexName: aws.String("StatusIndex"),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("Status"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                        {
                                                AttributeName: aws.String("CreatedAt"),
                                                KeyType:       types.KeyTypeRange,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                        },
                },
                BillingMode: types.BillingModePayPerRequest,
        }
}</span>

// getSubscriptionsTableDefinition returns the definition for the subscriptions table
func getSubscriptionsTableDefinition() TableDefinition <span class="cov0" title="0">{
        return TableDefinition{
                TableName: SubscriptionsTable,
                AttributeDefinitions: []types.AttributeDefinition{
                        {
                                AttributeName: aws.String("SubscriptionID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("ConnectionID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                        {
                                AttributeName: aws.String("RequestID"),
                                AttributeType: types.ScalarAttributeTypeS,
                        },
                },
                KeySchema: []types.KeySchemaElement{
                        {
                                AttributeName: aws.String("SubscriptionID"),
                                KeyType:       types.KeyTypeHash,
                        },
                },
                GlobalSecondaryIndexes: []types.GlobalSecondaryIndex{
                        {
                                IndexName: aws.String("ConnectionIndex"),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("ConnectionID"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                        },
                        {
                                IndexName: aws.String("RequestIndex"),
                                KeySchema: []types.KeySchemaElement{
                                        {
                                                AttributeName: aws.String("RequestID"),
                                                KeyType:       types.KeyTypeHash,
                                        },
                                },
                                Projection: &amp;types.Projection{
                                        ProjectionType: types.ProjectionTypeAll,
                                },
                        },
                },
                BillingMode: types.BillingModePayPerRequest,
        }
}</span>

// CreateTables creates all required DynamoDB tables
func CreateTables(ctx context.Context, client *dynamodb.Client) error <span class="cov0" title="0">{
        definitions := GetTableDefinitions()

        for _, def := range definitions </span><span class="cov0" title="0">{
                if err := createTable(ctx, client, def); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create table %s: %w", def.TableName, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createTable creates a single DynamoDB table
func createTable(ctx context.Context, client *dynamodb.Client, def TableDefinition) error <span class="cov0" title="0">{
        // Check if table already exists
        _, err := client.DescribeTable(ctx, &amp;dynamodb.DescribeTableInput{
                TableName: aws.String(def.TableName),
        })
        if err == nil </span><span class="cov0" title="0">{
                // Table already exists
                fmt.Printf("Table %s already exists, skipping creation\n", def.TableName)
                return nil
        }</span>

        <span class="cov0" title="0">input := &amp;dynamodb.CreateTableInput{
                TableName:            aws.String(def.TableName),
                AttributeDefinitions: def.AttributeDefinitions,
                KeySchema:            def.KeySchema,
                BillingMode:          def.BillingMode,
        }

        // Add GSIs if any
        if len(def.GlobalSecondaryIndexes) &gt; 0 </span><span class="cov0" title="0">{
                input.GlobalSecondaryIndexes = def.GlobalSecondaryIndexes
        }</span>

        // Enable TTL after table creation
        <span class="cov0" title="0">_, err = client.CreateTable(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create table: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Created table %s\n", def.TableName)

        // Wait for table to become active
        waiter := dynamodb.NewTableExistsWaiter(client)
        if err := waiter.Wait(ctx, &amp;dynamodb.DescribeTableInput{
                TableName: aws.String(def.TableName),
        }, 5*time.Minute); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed waiting for table to become active: %w", err)
        }</span>

        // Enable TTL on the tables
        <span class="cov0" title="0">if err := enableTTL(ctx, client, def.TableName); err != nil </span><span class="cov0" title="0">{
                // TTL enablement failure is not critical
                fmt.Printf("Warning: Failed to enable TTL on table %s: %v\n", def.TableName, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// enableTTL enables time-to-live on a DynamoDB table
func enableTTL(ctx context.Context, client *dynamodb.Client, tableName string) error <span class="cov0" title="0">{
        input := &amp;dynamodb.UpdateTimeToLiveInput{
                TableName: aws.String(tableName),
                TimeToLiveSpecification: &amp;types.TimeToLiveSpecification{
                        AttributeName: aws.String("TTL"),
                        Enabled:       aws.Bool(true),
                },
        }

        _, err := client.UpdateTimeToLive(ctx, input)
        return err
}</span>

// DeleteTables deletes all Streamer tables (for testing)
func DeleteTables(ctx context.Context, client *dynamodb.Client) error <span class="cov0" title="0">{
        definitions := GetTableDefinitions()

        for _, def := range definitions </span><span class="cov0" title="0">{
                input := &amp;dynamodb.DeleteTableInput{
                        TableName: aws.String(def.TableName),
                }

                _, err := client.DeleteTable(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        // Ignore if table doesn't exist
                        fmt.Printf("Warning: Failed to delete table %s: %v\n", def.TableName, err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("Deleted table %s\n", def.TableName)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package store

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/google/uuid"
)

// requestQueue implements RequestQueue using DynamoDB
type requestQueue struct {
        client    DynamoDBClient
        tableName string
}

// NewRequestQueue creates a new DynamoDB-backed request queue
func NewRequestQueue(client DynamoDBClient, tableName string) RequestQueue <span class="cov3" title="2">{
        if tableName == "" </span><span class="cov1" title="1">{
                tableName = RequestsTable
        }</span>
        <span class="cov3" title="2">return &amp;requestQueue{
                client:    client,
                tableName: tableName,
        }</span>
}

// Enqueue adds a new request to the queue
func (q *requestQueue) Enqueue(ctx context.Context, req *AsyncRequest) error <span class="cov8" title="7">{
        if err := q.validateRequest(req); err != nil </span><span class="cov5" title="3">{
                return err
        }</span>

        // Set defaults
        <span class="cov6" title="4">if req.RequestID == "" </span><span class="cov5" title="3">{
                req.RequestID = uuid.New().String()
        }</span>
        <span class="cov6" title="4">if req.CreatedAt.IsZero() </span><span class="cov5" title="3">{
                req.CreatedAt = time.Now()
        }</span>
        <span class="cov6" title="4">if req.Status == "" </span><span class="cov5" title="3">{
                req.Status = StatusPending
        }</span>
        <span class="cov6" title="4">if req.TTL == 0 </span><span class="cov5" title="3">{
                // Default TTL of 7 days
                req.TTL = time.Now().Add(7 * 24 * time.Hour).Unix()
        }</span>
        <span class="cov6" title="4">if req.MaxRetries == 0 </span><span class="cov5" title="3">{
                req.MaxRetries = 3
        }</span>

        // Marshal request to DynamoDB attribute values
        <span class="cov6" title="4">item, err := attributevalue.MarshalMap(req)
        if err != nil </span><span class="cov0" title="0">{
                return NewStoreError("Enqueue", q.tableName, req.RequestID, fmt.Errorf("failed to marshal request: %w", err))
        }</span>

        // Put item with condition check to prevent overwrites
        <span class="cov6" title="4">input := &amp;dynamodb.PutItemInput{
                TableName:           aws.String(q.tableName),
                Item:                item,
                ConditionExpression: aws.String("attribute_not_exists(RequestID)"),
        }

        _, err = q.client.PutItem(ctx, input)
        if err != nil </span><span class="cov3" title="2">{
                var cfe *types.ConditionalCheckFailedException
                if errors.As(err, &amp;cfe) </span><span class="cov1" title="1">{
                        return NewStoreError("Enqueue", q.tableName, req.RequestID, ErrAlreadyExists)
                }</span>
                <span class="cov1" title="1">return NewStoreError("Enqueue", q.tableName, req.RequestID, fmt.Errorf("failed to enqueue request: %w", err))</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// Dequeue retrieves and marks requests for processing
func (q *requestQueue) Dequeue(ctx context.Context, limit int) ([]*AsyncRequest, error) <span class="cov7" title="6">{
        if limit &lt;= 0 </span><span class="cov1" title="1">{
                limit = 10
        }</span>
        <span class="cov7" title="6">if limit &gt; 100 </span><span class="cov1" title="1">{
                limit = 100 // DynamoDB query limit
        }</span>

        // Query for pending requests
        <span class="cov7" title="6">input := &amp;dynamodb.QueryInput{
                TableName:              aws.String(q.tableName),
                IndexName:              aws.String("StatusIndex"),
                KeyConditionExpression: aws.String("#status = :status"),
                ExpressionAttributeNames: map[string]string{
                        "#status": "Status",
                },
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":status": &amp;types.AttributeValueMemberS{Value: string(StatusPending)},
                },
                Limit:            aws.Int32(int32(limit)),
                ScanIndexForward: aws.Bool(true), // Oldest first
        }

        result, err := q.client.Query(ctx, input)
        if err != nil </span><span class="cov1" title="1">{
                return nil, NewStoreError("Dequeue", q.tableName, "", fmt.Errorf("failed to query pending requests: %w", err))
        }</span>

        <span class="cov7" title="5">var requests []*AsyncRequest
        for _, item := range result.Items </span><span class="cov7" title="5">{
                var req AsyncRequest
                if err := attributevalue.UnmarshalMap(item, &amp;req); err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid items
                }

                // Try to mark as processing
                <span class="cov7" title="5">if err := q.UpdateStatus(ctx, req.RequestID, StatusProcessing, "Request dequeued for processing"); err != nil </span><span class="cov1" title="1">{
                        // Another worker might have grabbed it
                        continue</span>
                }

                <span class="cov6" title="4">requests = append(requests, &amp;req)</span>
        }

        <span class="cov7" title="5">return requests, nil</span>
}

// UpdateStatus updates the status of a request
func (q *requestQueue) UpdateStatus(ctx context.Context, requestID string, status RequestStatus, message string) error <span class="cov10" title="11">{
        if requestID == "" </span><span class="cov1" title="1">{
                return NewValidationError("requestID", "cannot be empty")
        }</span>

        <span class="cov9" title="10">updateExpr := "SET #status = :status"
        exprAttrNames := map[string]string{
                "#status": "Status",
        }
        exprAttrValues := map[string]types.AttributeValue{
                ":status": &amp;types.AttributeValueMemberS{Value: string(status)},
        }

        // Add message if provided
        if message != "" </span><span class="cov8" title="7">{
                updateExpr += ", ProgressMessage = :message"
                exprAttrValues[":message"] = &amp;types.AttributeValueMemberS{Value: message}
        }</span>

        // Update processing timestamps
        <span class="cov9" title="10">now := time.Now()
        switch status </span>{
        case StatusProcessing:<span class="cov8" title="8">
                updateExpr += ", ProcessingStarted = :now"
                exprAttrValues[":now"] = &amp;types.AttributeValueMemberS{Value: now.Format(time.RFC3339Nano)}</span>
        case StatusCompleted, StatusFailed:<span class="cov1" title="1">
                updateExpr += ", ProcessingEnded = :now"
                exprAttrValues[":now"] = &amp;types.AttributeValueMemberS{Value: now.Format(time.RFC3339Nano)}</span>
        }

        <span class="cov9" title="10">input := &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(q.tableName),
                Key: map[string]types.AttributeValue{
                        "RequestID": &amp;types.AttributeValueMemberS{Value: requestID},
                },
                UpdateExpression:          aws.String(updateExpr),
                ExpressionAttributeNames:  exprAttrNames,
                ExpressionAttributeValues: exprAttrValues,
                ConditionExpression:       aws.String("attribute_exists(RequestID)"),
        }

        _, err := q.client.UpdateItem(ctx, input)
        if err != nil </span><span class="cov5" title="3">{
                var cfe *types.ConditionalCheckFailedException
                if errors.As(err, &amp;cfe) </span><span class="cov1" title="1">{
                        return NewStoreError("UpdateStatus", q.tableName, requestID, ErrNotFound)
                }</span>
                <span class="cov3" title="2">return NewStoreError("UpdateStatus", q.tableName, requestID, fmt.Errorf("failed to update status: %w", err))</span>
        }

        <span class="cov8" title="7">return nil</span>
}

// UpdateProgress updates the progress of a request
func (q *requestQueue) UpdateProgress(ctx context.Context, requestID string, progress float64, message string, details map[string]interface{}) error <span class="cov8" title="7">{
        if requestID == "" </span><span class="cov1" title="1">{
                return NewValidationError("requestID", "cannot be empty")
        }</span>
        <span class="cov7" title="6">if progress &lt; 0 || progress &gt; 1 </span><span class="cov3" title="2">{
                return NewValidationError("progress", "must be between 0 and 1")
        }</span>

        <span class="cov6" title="4">updateExpr := "SET Progress = :progress"
        exprAttrValues := map[string]types.AttributeValue{
                ":progress":   &amp;types.AttributeValueMemberN{Value: fmt.Sprintf("%.2f", progress)},
                ":processing": &amp;types.AttributeValueMemberS{Value: string(StatusProcessing)},
        }

        if message != "" </span><span class="cov3" title="2">{
                updateExpr += ", ProgressMessage = :message"
                exprAttrValues[":message"] = &amp;types.AttributeValueMemberS{Value: message}
        }</span>

        <span class="cov6" title="4">if details != nil </span><span class="cov3" title="2">{
                detailsAV, err := attributevalue.MarshalMap(details)
                if err == nil </span><span class="cov3" title="2">{
                        updateExpr += ", ProgressDetails = :details"
                        exprAttrValues[":details"] = &amp;types.AttributeValueMemberM{Value: detailsAV}
                }</span>
        }

        <span class="cov6" title="4">input := &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(q.tableName),
                Key: map[string]types.AttributeValue{
                        "RequestID": &amp;types.AttributeValueMemberS{Value: requestID},
                },
                UpdateExpression:          aws.String(updateExpr),
                ExpressionAttributeValues: exprAttrValues,
                ConditionExpression:       aws.String("attribute_exists(RequestID) AND #status = :processing"),
                ExpressionAttributeNames: map[string]string{
                        "#status": "Status",
                },
        }

        _, err := q.client.UpdateItem(ctx, input)
        if err != nil </span><span class="cov1" title="1">{
                var cfe *types.ConditionalCheckFailedException
                if errors.As(err, &amp;cfe) </span><span class="cov1" title="1">{
                        return NewStoreError("UpdateProgress", q.tableName, requestID, ErrRequestNotPending)
                }</span>
                <span class="cov0" title="0">return NewStoreError("UpdateProgress", q.tableName, requestID, fmt.Errorf("failed to update progress: %w", err))</span>
        }

        <span class="cov5" title="3">return nil</span>
}

// CompleteRequest marks a request as completed with results
func (q *requestQueue) CompleteRequest(ctx context.Context, requestID string, result map[string]interface{}) error <span class="cov6" title="4">{
        if requestID == "" </span><span class="cov1" title="1">{
                return NewValidationError("requestID", "cannot be empty")
        }</span>

        <span class="cov5" title="3">updateExpr := "SET #status = :status, ProcessingEnded = :now, Progress = :progress"
        exprAttrNames := map[string]string{
                "#status": "Status",
        }
        exprAttrValues := map[string]types.AttributeValue{
                ":status":   &amp;types.AttributeValueMemberS{Value: string(StatusCompleted)},
                ":now":      &amp;types.AttributeValueMemberS{Value: time.Now().Format(time.RFC3339Nano)},
                ":progress": &amp;types.AttributeValueMemberN{Value: "1.0"},
        }

        if result != nil </span><span class="cov1" title="1">{
                resultAV, err := attributevalue.MarshalMap(result)
                if err != nil </span><span class="cov0" title="0">{
                        return NewStoreError("CompleteRequest", q.tableName, requestID, fmt.Errorf("failed to marshal result: %w", err))
                }</span>
                <span class="cov1" title="1">updateExpr += ", #result = :result"
                exprAttrNames["#result"] = "Result"
                exprAttrValues[":result"] = &amp;types.AttributeValueMemberM{Value: resultAV}</span>
        }

        <span class="cov5" title="3">input := &amp;dynamodb.UpdateItemInput{
                TableName:                 aws.String(q.tableName),
                Key:                       map[string]types.AttributeValue{"RequestID": &amp;types.AttributeValueMemberS{Value: requestID}},
                UpdateExpression:          aws.String(updateExpr),
                ExpressionAttributeNames:  exprAttrNames,
                ExpressionAttributeValues: exprAttrValues,
                ConditionExpression:       aws.String("attribute_exists(RequestID)"),
        }

        _, err := q.client.UpdateItem(ctx, input)
        if err != nil </span><span class="cov1" title="1">{
                var cfe *types.ConditionalCheckFailedException
                if errors.As(err, &amp;cfe) </span><span class="cov1" title="1">{
                        return NewStoreError("CompleteRequest", q.tableName, requestID, ErrNotFound)
                }</span>
                <span class="cov0" title="0">return NewStoreError("CompleteRequest", q.tableName, requestID, fmt.Errorf("failed to complete request: %w", err))</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// FailRequest marks a request as failed with an error
func (q *requestQueue) FailRequest(ctx context.Context, requestID string, errMsg string) error <span class="cov6" title="4">{
        if requestID == "" </span><span class="cov1" title="1">{
                return NewValidationError("requestID", "cannot be empty")
        }</span>
        <span class="cov5" title="3">if errMsg == "" </span><span class="cov1" title="1">{
                return NewValidationError("error", "cannot be empty")
        }</span>

        <span class="cov3" title="2">input := &amp;dynamodb.UpdateItemInput{
                TableName: aws.String(q.tableName),
                Key: map[string]types.AttributeValue{
                        "RequestID": &amp;types.AttributeValueMemberS{Value: requestID},
                },
                UpdateExpression: aws.String("SET #status = :status, ProcessingEnded = :now, #error = :error"),
                ExpressionAttributeNames: map[string]string{
                        "#status": "Status",
                        "#error":  "Error",
                },
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":status": &amp;types.AttributeValueMemberS{Value: string(StatusFailed)},
                        ":now":    &amp;types.AttributeValueMemberS{Value: time.Now().Format(time.RFC3339Nano)},
                        ":error":  &amp;types.AttributeValueMemberS{Value: errMsg},
                },
                ConditionExpression: aws.String("attribute_exists(RequestID)"),
        }

        _, err := q.client.UpdateItem(ctx, input)
        if err != nil </span><span class="cov1" title="1">{
                var cfe *types.ConditionalCheckFailedException
                if errors.As(err, &amp;cfe) </span><span class="cov1" title="1">{
                        return NewStoreError("FailRequest", q.tableName, requestID, ErrNotFound)
                }</span>
                <span class="cov0" title="0">return NewStoreError("FailRequest", q.tableName, requestID, fmt.Errorf("failed to fail request: %w", err))</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// GetByConnection retrieves all requests for a connection
func (q *requestQueue) GetByConnection(ctx context.Context, connectionID string, limit int) ([]*AsyncRequest, error) <span class="cov5" title="3">{
        if connectionID == "" </span><span class="cov1" title="1">{
                return nil, NewValidationError("connectionID", "cannot be empty")
        }</span>
        <span class="cov3" title="2">if limit &lt;= 0 </span><span class="cov1" title="1">{
                limit = 100
        }</span>

        <span class="cov3" title="2">input := &amp;dynamodb.QueryInput{
                TableName:              aws.String(q.tableName),
                IndexName:              aws.String("ConnectionIndex"),
                KeyConditionExpression: aws.String("ConnectionID = :connectionID"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":connectionID": &amp;types.AttributeValueMemberS{Value: connectionID},
                },
                Limit:            aws.Int32(int32(limit)),
                ScanIndexForward: aws.Bool(false), // Newest first
        }

        return q.queryRequests(ctx, input)</span>
}

// GetByStatus retrieves requests by status
func (q *requestQueue) GetByStatus(ctx context.Context, status RequestStatus, limit int) ([]*AsyncRequest, error) <span class="cov5" title="3">{
        if limit &lt;= 0 </span><span class="cov1" title="1">{
                limit = 100
        }</span>

        <span class="cov5" title="3">input := &amp;dynamodb.QueryInput{
                TableName:              aws.String(q.tableName),
                IndexName:              aws.String("StatusIndex"),
                KeyConditionExpression: aws.String("#status = :status"),
                ExpressionAttributeNames: map[string]string{
                        "#status": "Status",
                },
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":status": &amp;types.AttributeValueMemberS{Value: string(status)},
                },
                Limit:            aws.Int32(int32(limit)),
                ScanIndexForward: aws.Bool(true), // Oldest first for processing
        }

        return q.queryRequests(ctx, input)</span>
}

// Get retrieves a specific request
func (q *requestQueue) Get(ctx context.Context, requestID string) (*AsyncRequest, error) <span class="cov7" title="5">{
        if requestID == "" </span><span class="cov1" title="1">{
                return nil, NewValidationError("requestID", "cannot be empty")
        }</span>

        <span class="cov6" title="4">input := &amp;dynamodb.GetItemInput{
                TableName: aws.String(q.tableName),
                Key: map[string]types.AttributeValue{
                        "RequestID": &amp;types.AttributeValueMemberS{Value: requestID},
                },
        }

        result, err := q.client.GetItem(ctx, input)
        if err != nil </span><span class="cov1" title="1">{
                return nil, NewStoreError("Get", q.tableName, requestID, fmt.Errorf("failed to get request: %w", err))
        }</span>

        <span class="cov5" title="3">if result.Item == nil </span><span class="cov1" title="1">{
                return nil, NewStoreError("Get", q.tableName, requestID, ErrNotFound)
        }</span>

        <span class="cov3" title="2">var req AsyncRequest
        err = attributevalue.UnmarshalMap(result.Item, &amp;req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, NewStoreError("Get", q.tableName, requestID, fmt.Errorf("failed to unmarshal request: %w", err))
        }</span>

        <span class="cov1" title="1">return &amp;req, nil</span>
}

// Delete removes a request
func (q *requestQueue) Delete(ctx context.Context, requestID string) error <span class="cov5" title="3">{
        if requestID == "" </span><span class="cov1" title="1">{
                return NewValidationError("requestID", "cannot be empty")
        }</span>

        <span class="cov3" title="2">input := &amp;dynamodb.DeleteItemInput{
                TableName: aws.String(q.tableName),
                Key: map[string]types.AttributeValue{
                        "RequestID": &amp;types.AttributeValueMemberS{Value: requestID},
                },
        }

        _, err := q.client.DeleteItem(ctx, input)
        if err != nil </span><span class="cov1" title="1">{
                return NewStoreError("Delete", q.tableName, requestID, fmt.Errorf("failed to delete request: %w", err))
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// queryRequests executes a query and returns requests
func (q *requestQueue) queryRequests(ctx context.Context, input *dynamodb.QueryInput) ([]*AsyncRequest, error) <span class="cov7" title="5">{
        var requests []*AsyncRequest
        var lastEvaluatedKey map[string]types.AttributeValue

        // Handle pagination manually
        for </span><span class="cov7" title="6">{
                if lastEvaluatedKey != nil </span><span class="cov1" title="1">{
                        input.ExclusiveStartKey = lastEvaluatedKey
                }</span>

                <span class="cov7" title="6">result, err := q.client.Query(ctx, input)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to query requests: %w", err)
                }</span>

                <span class="cov7" title="6">for _, item := range result.Items </span><span class="cov7" title="5">{
                        var req AsyncRequest
                        if err := attributevalue.UnmarshalMap(item, &amp;req); err != nil </span><span class="cov0" title="0">{
                                // Skip invalid items
                                continue</span>
                        }
                        <span class="cov7" title="5">requests = append(requests, &amp;req)</span>
                }

                // If we've reached the limit, stop paginating
                <span class="cov7" title="6">if input.Limit != nil &amp;&amp; len(requests) &gt;= int(*input.Limit) </span><span class="cov0" title="0">{
                        break</span>
                }

                // Check if there are more pages
                <span class="cov7" title="6">lastEvaluatedKey = result.LastEvaluatedKey
                if lastEvaluatedKey == nil </span><span class="cov7" title="5">{
                        break</span>
                }
        }

        <span class="cov7" title="5">return requests, nil</span>
}

// validateRequest validates a request before enqueueing
func (q *requestQueue) validateRequest(req *AsyncRequest) error <span class="cov10" title="11">{
        if req == nil </span><span class="cov3" title="2">{
                return NewValidationError("request", "cannot be nil")
        }</span>
        <span class="cov9" title="9">if req.ConnectionID == "" </span><span class="cov3" title="2">{
                return NewValidationError("ConnectionID", "cannot be empty")
        }</span>
        <span class="cov8" title="7">if req.Action == "" </span><span class="cov3" title="2">{
                return NewValidationError("Action", "cannot be empty")
        }</span>
        <span class="cov7" title="5">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// Claims represents the JWT claims we expect
type Claims struct {
        jwt.RegisteredClaims
        TenantID    string   `json:"tenant_id"`
        Permissions []string `json:"permissions"`
}

// JWTVerifier handles JWT token verification
type JWTVerifier struct {
        publicKey *rsa.PublicKey
        issuer    string
}

// NewJWTVerifier creates a new JWT verifier with the given public key
func NewJWTVerifier(publicKeyPEM, issuer string) (*JWTVerifier, error) <span class="cov7" title="7">{
        // Parse the public key
        publicKey, err := parsePublicKey(publicKeyPEM)
        if err != nil </span><span class="cov4" title="3">{
                return nil, fmt.Errorf("failed to parse public key: %w", err)
        }</span>

        <span class="cov5" title="4">return &amp;JWTVerifier{
                publicKey: publicKey,
                issuer:    issuer,
        }, nil</span>
}

// Verify validates a JWT token and returns the claims
func (v *JWTVerifier) Verify(tokenString string) (*Claims, error) <span class="cov10" title="13">{
        // Remove "Bearer " prefix if present
        tokenString = strings.TrimPrefix(tokenString, "Bearer ")
        tokenString = strings.TrimSpace(tokenString)

        // Parse and validate the token
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov9" title="11">{
                // Verify the algorithm is RS256
                if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov9" title="10">return v.publicKey, nil</span>
        })

        <span class="cov10" title="13">if err != nil </span><span class="cov7" title="6">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        // Check if token is valid
        <span class="cov7" title="7">if !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("token is invalid")
        }</span>

        // Extract claims
        <span class="cov7" title="7">claims, ok := token.Claims.(*Claims)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("failed to extract claims")
        }</span>

        // Validate standard claims
        <span class="cov7" title="7">if err := v.validateClaims(claims); err != nil </span><span class="cov5" title="4">{
                return nil, err
        }</span>

        <span class="cov4" title="3">return claims, nil</span>
}

// validateClaims performs additional validation on the claims
func (v *JWTVerifier) validateClaims(claims *Claims) error <span class="cov7" title="7">{
        now := time.Now()

        // Check expiration
        if claims.ExpiresAt != nil &amp;&amp; claims.ExpiresAt.Before(now) </span><span class="cov0" title="0">{
                return errors.New("token has expired")
        }</span>

        // Check not before
        <span class="cov7" title="7">if claims.NotBefore != nil &amp;&amp; claims.NotBefore.After(now) </span><span class="cov0" title="0">{
                return errors.New("token not yet valid")
        }</span>

        // Check issued at (reject tokens from the future)
        <span class="cov7" title="7">if claims.IssuedAt != nil &amp;&amp; claims.IssuedAt.After(now.Add(1*time.Minute)) </span><span class="cov1" title="1">{
                return errors.New("token issued in the future")
        }</span>

        // Validate issuer if configured
        <span class="cov7" title="6">if v.issuer != "" &amp;&amp; claims.Issuer != v.issuer </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid issuer: expected %s, got %s", v.issuer, claims.Issuer)
        }</span>

        // Validate required fields
        <span class="cov6" title="5">if claims.Subject == "" </span><span class="cov1" title="1">{
                return errors.New("missing subject (user ID)")
        }</span>

        <span class="cov5" title="4">if claims.TenantID == "" </span><span class="cov1" title="1">{
                return errors.New("missing tenant ID")
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// parsePublicKey parses a PEM-encoded RSA public key
func parsePublicKey(pemString string) (*rsa.PublicKey, error) <span class="cov9" title="11">{
        // Decode PEM block
        block, _ := pem.Decode([]byte(pemString))
        if block == nil </span><span class="cov5" title="4">{
                return nil, errors.New("failed to decode PEM block")
        }</span>

        // Parse the public key
        <span class="cov7" title="7">switch block.Type </span>{
        case "RSA PUBLIC KEY":<span class="cov3" title="2">
                // PKCS#1 format
                pub, err := x509.ParsePKCS1PublicKey(block.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse PKCS1 public key: %w", err)
                }</span>
                <span class="cov3" title="2">return pub, nil</span>

        case "PUBLIC KEY":<span class="cov5" title="4">
                // PKCS#8 format
                pub, err := x509.ParsePKIXPublicKey(block.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse PKIX public key: %w", err)
                }</span>

                <span class="cov5" title="4">rsaPub, ok := pub.(*rsa.PublicKey)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("not an RSA public key")
                }</span>
                <span class="cov5" title="4">return rsaPub, nil</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported key type: %s", block.Type)</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/aws/aws-lambda-go/events"
        "github.com/aws/aws-sdk-go-v2/service/cloudwatch/types"
        "github.com/pay-theory/streamer/internal/store"
        "github.com/pay-theory/streamer/lambda/shared"
)

// JWTVerifierInterface defines the interface for JWT verification
type JWTVerifierInterface interface {
        Verify(token string) (*Claims, error)
}

// HandlerConfig holds configuration for the handler
type HandlerConfig struct {
        TableName      string
        JWTPublicKey   string
        JWTIssuer      string
        AllowedTenants []string
        LogLevel       string
}

// Handler handles WebSocket $connect requests
type Handler struct {
        store       store.ConnectionStore
        config      *HandlerConfig
        jwtVerifier JWTVerifierInterface
        logger      *shared.Logger
        metrics     shared.MetricsPublisher
}

// NewHandler creates a new connect handler
func NewHandler(store store.ConnectionStore, config *HandlerConfig, metrics shared.MetricsPublisher) *Handler <span class="cov0" title="0">{
        verifier, err := NewJWTVerifier(config.JWTPublicKey, config.JWTIssuer)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create JWT verifier: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;Handler{
                store:       store,
                config:      config,
                jwtVerifier: verifier,
                logger:      shared.NewLogger("connect-handler"),
                metrics:     metrics,
        }</span>
}

// NewHandlerWithVerifier creates a new connect handler with a custom JWT verifier (for testing)
func NewHandlerWithVerifier(store store.ConnectionStore, config *HandlerConfig, metrics shared.MetricsPublisher, verifier JWTVerifierInterface) *Handler <span class="cov8" title="7">{
        return &amp;Handler{
                store:       store,
                config:      config,
                jwtVerifier: verifier,
                logger:      shared.NewLogger("connect-handler"),
                metrics:     metrics,
        }
}</span>

// Handle processes the WebSocket $connect event
func (h *Handler) Handle(ctx context.Context, event events.APIGatewayWebsocketProxyRequest) (events.APIGatewayProxyResponse, error) <span class="cov8" title="7">{
        start := time.Now()
        connectionID := event.RequestContext.ConnectionID

        // Start X-Ray tracing
        traceData := shared.TraceSegment{
                ConnectionID: connectionID,
                Action:       "connect",
        }
        ctx, seg := shared.StartSubsegment(ctx, "HandleConnect", traceData)
        defer func() </span><span class="cov8" title="7">{
                shared.EndSubsegment(seg, nil)
        }</span>()

        // Log the connection attempt with structured logging
        <span class="cov8" title="7">h.logger.Info(ctx, "Connection attempt", map[string]interface{}{
                "connection_id": connectionID,
                "source_ip":     event.RequestContext.Identity.SourceIP,
                "user_agent":    event.Headers["User-Agent"],
        })

        // Extract JWT from query string
        token := event.QueryStringParameters["Authorization"]
        if token == "" </span><span class="cov3" title="2">{
                // Try headers as fallback
                token = event.Headers["Authorization"]
        }</span>

        <span class="cov8" title="7">if token == "" </span><span class="cov1" title="1">{
                h.logger.Warn(ctx, "Missing authorization token", map[string]interface{}{
                        "connection_id": connectionID,
                })

                // Publish metric for auth failure
                h.metrics.PublishMetric(ctx, "", shared.CommonMetrics.AuthenticationFailed, 1, types.StandardUnitCount,
                        shared.MetricsDimensions{}.Environment(os.Getenv("ENVIRONMENT")),
                        shared.MetricsDimensions{}.ErrorType("missing_token"))

                return unauthorizedResponse("Missing authorization token")
        }</span>

        // Validate JWT
        <span class="cov8" title="6">ctx2, jwtSeg := shared.StartSubsegment(ctx, "ValidateJWT", shared.TraceSegment{})
        claims, err := h.jwtVerifier.Verify(token)
        shared.EndSubsegment(jwtSeg, err)

        if err != nil </span><span class="cov1" title="1">{
                h.logger.Error(ctx2, "JWT validation failed", map[string]interface{}{
                        "connection_id": connectionID,
                        "error":         err.Error(),
                })

                // Publish metric for auth failure
                h.metrics.PublishMetric(ctx, "", shared.CommonMetrics.AuthenticationFailed, 1, types.StandardUnitCount,
                        shared.MetricsDimensions{}.Environment(os.Getenv("ENVIRONMENT")),
                        shared.MetricsDimensions{}.ErrorType("invalid_jwt"))

                return unauthorizedResponse(fmt.Sprintf("Invalid token: %v", err))
        }</span>

        // Update trace data with user info
        <span class="cov7" title="5">traceData.UserID = claims.Subject
        traceData.TenantID = claims.TenantID
        shared.AddTraceAnnotation(ctx, "user_id", claims.Subject)
        shared.AddTraceAnnotation(ctx, "tenant_id", claims.TenantID)

        // Validate tenant if restrictions are configured
        if len(h.config.AllowedTenants) &gt; 0 </span><span class="cov3" title="2">{
                allowed := false
                for _, tenant := range h.config.AllowedTenants </span><span class="cov5" title="3">{
                        if claims.TenantID == tenant </span><span class="cov1" title="1">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov3" title="2">if !allowed </span><span class="cov1" title="1">{
                        h.logger.Warn(ctx, "Tenant not allowed", map[string]interface{}{
                                "connection_id": connectionID,
                                "tenant_id":     claims.TenantID,
                        })

                        // Publish metric for auth failure
                        h.metrics.PublishMetric(ctx, "", shared.CommonMetrics.AuthenticationFailed, 1, types.StandardUnitCount,
                                shared.MetricsDimensions{}.Environment(os.Getenv("ENVIRONMENT")),
                                shared.MetricsDimensions{}.ErrorType("tenant_not_allowed"),
                                shared.MetricsDimensions{}.TenantID(claims.TenantID))

                        return unauthorizedResponse("Tenant not allowed")
                }</span>
        }

        // Create connection record
        <span class="cov6" title="4">connection := &amp;store.Connection{
                ConnectionID: event.RequestContext.ConnectionID,
                UserID:       claims.Subject,
                TenantID:     claims.TenantID,
                Endpoint:     fmt.Sprintf("%s/%s", event.RequestContext.DomainName, event.RequestContext.Stage),
                ConnectedAt:  time.Now(),
                LastPing:     time.Now(),
                Metadata: map[string]string{
                        "user_agent":  event.Headers["User-Agent"],
                        "ip_address":  event.RequestContext.Identity.SourceIP,
                        "permissions": jsonStringify(claims.Permissions),
                },
                TTL: time.Now().Add(24 * time.Hour).Unix(),
        }

        // Save connection to store
        ctx3, saveSeg := shared.StartSubsegment(ctx, "SaveConnection", shared.TraceSegment{})
        err = h.store.Save(ctx3, connection)
        shared.EndSubsegment(saveSeg, err)

        if err != nil </span><span class="cov1" title="1">{
                h.logger.Error(ctx, "Failed to save connection", map[string]interface{}{
                        "connection_id": connectionID,
                        "error":         err.Error(),
                })
                return internalErrorResponse("Failed to establish connection")
        }</span>

        // Log successful connection
        <span class="cov5" title="3">h.logger.Info(ctx, "Connection established", map[string]interface{}{
                "connection_id": connectionID,
                "user_id":       connection.UserID,
                "tenant_id":     connection.TenantID,
        })

        // Publish success metrics
        h.metrics.PublishMetric(ctx, "", shared.CommonMetrics.ConnectionEstablished, 1, types.StandardUnitCount,
                shared.MetricsDimensions{}.Environment(os.Getenv("ENVIRONMENT")),
                shared.MetricsDimensions{}.TenantID(connection.TenantID))

        // Track connection latency
        latency := time.Since(start)
        h.metrics.PublishLatency(ctx, "", shared.CommonMetrics.ProcessingLatency, latency,
                shared.MetricsDimensions{}.Environment(os.Getenv("ENVIRONMENT")),
                shared.MetricsDimensions{}.Action("connect"))

        // Return success response
        return events.APIGatewayProxyResponse{
                StatusCode: 200,
                Body:       `{"message":"Connected successfully"}`,
                Headers: map[string]string{
                        "Content-Type": "application/json",
                },
        }, nil</span>
}

// Helper functions for responses
func unauthorizedResponse(message string) (events.APIGatewayProxyResponse, error) <span class="cov6" title="4">{
        body, _ := json.Marshal(map[string]string{
                "error": message,
                "code":  "UNAUTHORIZED",
        })

        return events.APIGatewayProxyResponse{
                StatusCode: 401,
                Body:       string(body),
                Headers: map[string]string{
                        "Content-Type": "application/json",
                },
        }, nil
}</span>

func internalErrorResponse(message string) (events.APIGatewayProxyResponse, error) <span class="cov3" title="2">{
        body, _ := json.Marshal(map[string]string{
                "error": message,
                "code":  "INTERNAL_ERROR",
        })

        return events.APIGatewayProxyResponse{
                StatusCode: 500,
                Body:       string(body),
                Headers: map[string]string{
                        "Content-Type": "application/json",
                },
        }, nil
}</span>

func jsonStringify(v interface{}) string <span class="cov10" title="9">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov9" title="8">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "context"
        "log"
        "os"
        "strings"

        "github.com/aws/aws-lambda-go/lambda"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/pay-theory/dynamorm/pkg/session"
        dynamormStore "github.com/pay-theory/streamer/internal/store/dynamorm"
        "github.com/pay-theory/streamer/lambda/shared"
)

func main() <span class="cov0" title="0">{
        // Load configuration from environment
        cfg := &amp;HandlerConfig{
                TableName:      getEnv("CONNECTIONS_TABLE", "streamer_connections"),
                JWTPublicKey:   getEnv("JWT_PUBLIC_KEY", ""),
                JWTIssuer:      getEnv("JWT_ISSUER", ""),
                AllowedTenants: getEnvSlice("ALLOWED_TENANTS", []string{}),
                LogLevel:       getEnv("LOG_LEVEL", "INFO"),
        }

        // Validate configuration
        if cfg.JWTPublicKey == "" </span><span class="cov0" title="0">{
                log.Fatal("JWT_PUBLIC_KEY environment variable is required")
        }</span>

        // Initialize AWS SDK for CloudWatch metrics
        <span class="cov0" title="0">awsCfg, err := config.LoadDefaultConfig(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load AWS config: %v", err)
        }</span>

        // Initialize DynamORM
        <span class="cov0" title="0">dynamormConfig := session.Config{
                Region: awsCfg.Region,
        }

        factory, err := dynamormStore.NewStoreFactory(dynamormConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create DynamORM factory: %v", err)
        }</span>

        // Get connection store from factory
        <span class="cov0" title="0">connStore := factory.ConnectionStore()

        // Create CloudWatch metrics client
        metricsNamespace := getEnv("METRICS_NAMESPACE", "Streamer")
        metrics := shared.NewCloudWatchMetrics(awsCfg, metricsNamespace)

        // Create handler
        handler := NewHandler(connStore, cfg, metrics)

        // Log startup
        log.Printf("Connect handler started - Table: %s, Region: %s", cfg.TableName, awsCfg.Region)

        // Start Lambda runtime
        lambda.Start(handler.Handle)</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvSlice(key string, defaultValue []string) []string <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        // Simple comma-separated parsing
        <span class="cov0" title="0">var result []string
        for _, v := range strings.Split(value, ",") </span><span class="cov0" title="0">{
                v = strings.TrimSpace(v)
                if v != "" </span><span class="cov0" title="0">{
                        result = append(result, v)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/aws/aws-lambda-go/events"
        "github.com/aws/aws-sdk-go-v2/service/cloudwatch/types"
        "github.com/pay-theory/streamer/internal/store"
        "github.com/pay-theory/streamer/lambda/shared"
)

// HandlerConfig holds configuration for the handler
type HandlerConfig struct {
        ConnectionsTable   string
        SubscriptionsTable string
        RequestsTable      string
        MetricsEnabled     bool
        LogLevel           string
}

// Handler handles WebSocket $disconnect requests
type Handler struct {
        connStore     store.ConnectionStore
        subStore      SubscriptionStore // Interface for future implementation
        requestStore  RequestStore      // Interface for future implementation
        config        *HandlerConfig
        metricsLogger *MetricsLogger
        logger        *shared.Logger
        metrics       shared.MetricsPublisher
}

// SubscriptionStore interface for future implementation
type SubscriptionStore interface {
        DeleteByConnection(ctx context.Context, connectionID string) error
        CountByConnection(ctx context.Context, connectionID string) (int, error)
}

// RequestStore interface for future implementation
type RequestStore interface {
        CancelByConnection(ctx context.Context, connectionID string) (int, error)
}

// NewHandler creates a new disconnect handler
func NewHandler(connStore store.ConnectionStore, subStore SubscriptionStore, requestStore RequestStore, config *HandlerConfig, metrics shared.MetricsPublisher) *Handler <span class="cov7" title="6">{
        return &amp;Handler{
                connStore:     connStore,
                subStore:      subStore,
                requestStore:  requestStore,
                config:        config,
                metricsLogger: NewMetricsLogger(config.MetricsEnabled),
                logger:        shared.NewLogger("disconnect-handler"),
                metrics:       metrics,
        }
}</span>

// Handle processes the WebSocket $disconnect event
func (h *Handler) Handle(ctx context.Context, event events.APIGatewayWebsocketProxyRequest) (events.APIGatewayProxyResponse, error) <span class="cov7" title="6">{
        connectionID := event.RequestContext.ConnectionID
        startTime := time.Now()

        // Start X-Ray tracing
        traceData := shared.TraceSegment{
                ConnectionID: connectionID,
                Action:       "disconnect",
        }
        ctx, seg := shared.StartSubsegment(ctx, "HandleDisconnect", traceData)
        defer func() </span><span class="cov7" title="6">{
                shared.EndSubsegment(seg, nil)
        }</span>()

        // Log the disconnection attempt with structured logging
        <span class="cov7" title="6">h.logger.Info(ctx, "Processing disconnect", map[string]interface{}{
                "connection_id": connectionID,
        })

        // Initialize metrics
        metrics := &amp;DisconnectMetrics{
                ConnectionID:     connectionID,
                DisconnectTime:   time.Now(),
                DisconnectReason: "client_disconnect", // Default reason
        }

        // Get connection details before deletion for metrics
        conn, err := h.connStore.Get(ctx, connectionID)
        if err != nil </span><span class="cov1" title="1">{
                // Connection might already be deleted
                log.Printf("Connection %s not found during disconnect: %v", connectionID, err)
                metrics.ConnectionNotFound = true
        }</span> else<span class="cov6" title="5"> {
                // Calculate connection duration
                metrics.UserID = conn.UserID
                metrics.TenantID = conn.TenantID
                metrics.ConnectedAt = conn.ConnectedAt
                metrics.DurationSeconds = int64(time.Since(conn.ConnectedAt).Seconds())

                // Extract message counts from metadata if available
                if messagesStr, ok := conn.Metadata["messages_sent"]; ok </span><span class="cov5" title="4">{
                        // Parse message count - this would be updated by the message processor
                        metrics.MessagesSent = parseIntOrDefault(messagesStr, 0)
                }</span>
                <span class="cov6" title="5">if messagesStr, ok := conn.Metadata["messages_received"]; ok </span><span class="cov5" title="4">{
                        metrics.MessagesReceived = parseIntOrDefault(messagesStr, 0)
                }</span>
        }

        // Delete the connection record
        <span class="cov7" title="6">if err := h.connStore.Delete(ctx, connectionID); err != nil </span><span class="cov1" title="1">{
                log.Printf("Failed to delete connection %s: %v", connectionID, err)
                metrics.DeleteError = err.Error()
                // Don't return error - connection is already closed on API Gateway side
        }</span>

        // Clean up subscriptions if store is available
        <span class="cov7" title="6">if h.subStore != nil </span><span class="cov6" title="5">{
                // Count subscriptions before deletion for metrics
                subCount, err := h.subStore.CountByConnection(ctx, connectionID)
                if err == nil </span><span class="cov6" title="5">{
                        metrics.SubscriptionsCancelled = subCount
                }</span>

                // Delete all subscriptions for this connection
                <span class="cov6" title="5">if err := h.subStore.DeleteByConnection(ctx, connectionID); err != nil </span><span class="cov1" title="1">{
                        log.Printf("Failed to delete subscriptions for connection %s: %v", connectionID, err)
                        metrics.SubscriptionError = err.Error()
                        // Don't return error - continue cleanup
                }</span>
        }

        // Cancel any in-progress async requests
        <span class="cov7" title="6">if h.requestStore != nil </span><span class="cov6" title="5">{
                cancelledCount, err := h.requestStore.CancelByConnection(ctx, connectionID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to cancel requests for connection %s: %v", connectionID, err)
                        metrics.RequestError = err.Error()
                }</span> else<span class="cov6" title="5"> {
                        metrics.RequestsCancelled = cancelledCount
                }</span>
        }

        // Calculate cleanup duration
        <span class="cov7" title="6">metrics.CleanupDurationMs = int64(time.Since(startTime).Milliseconds())

        // Log metrics
        h.metricsLogger.LogDisconnect(ctx, metrics)

        // Log structured summary
        h.logger.Info(ctx, "Disconnect completed", map[string]interface{}{
                "connection_id":           connectionID,
                "user_id":                 metrics.UserID,
                "tenant_id":               metrics.TenantID,
                "duration_seconds":        metrics.DurationSeconds,
                "messages_sent":           metrics.MessagesSent,
                "messages_received":       metrics.MessagesReceived,
                "subscriptions_cancelled": metrics.SubscriptionsCancelled,
                "requests_cancelled":      metrics.RequestsCancelled,
                "cleanup_duration_ms":     metrics.CleanupDurationMs,
        })

        // Update trace data with user info
        if metrics.UserID != "" </span><span class="cov6" title="5">{
                shared.AddTraceAnnotation(ctx, "user_id", metrics.UserID)
                shared.AddTraceAnnotation(ctx, "tenant_id", metrics.TenantID)
        }</span>

        // Publish CloudWatch metrics
        <span class="cov7" title="6">environment := os.Getenv("ENVIRONMENT")

        // Connection closed metric
        h.metrics.PublishMetric(ctx, "", shared.CommonMetrics.ConnectionClosed, 1, types.StandardUnitCount,
                shared.MetricsDimensions{}.Environment(environment),
                shared.MetricsDimensions{}.TenantID(metrics.TenantID))

        // Connection duration metric (if we found the connection)
        if !metrics.ConnectionNotFound &amp;&amp; metrics.DurationSeconds &gt; 0 </span><span class="cov6" title="5">{
                h.metrics.PublishMetric(ctx, "", shared.CommonMetrics.ConnectionDuration, float64(metrics.DurationSeconds), types.StandardUnitSeconds,
                        shared.MetricsDimensions{}.Environment(environment),
                        shared.MetricsDimensions{}.TenantID(metrics.TenantID))
        }</span>

        // Cleanup latency metric
        <span class="cov7" title="6">h.metrics.PublishLatency(ctx, "", shared.CommonMetrics.ProcessingLatency, time.Since(startTime),
                shared.MetricsDimensions{}.Environment(environment),
                shared.MetricsDimensions{}.Action("disconnect"))

        // Always return success - the connection is already closed
        return events.APIGatewayProxyResponse{
                StatusCode: 200,
                Body:       `{"message":"Disconnected successfully"}`,
                Headers: map[string]string{
                        "Content-Type": "application/json",
                },
        }, nil</span>
}

// DisconnectMetrics holds metrics for a disconnect event
type DisconnectMetrics struct {
        ConnectionID           string
        UserID                 string
        TenantID               string
        ConnectedAt            time.Time
        DisconnectTime         time.Time
        DisconnectReason       string
        DurationSeconds        int64
        MessagesSent           int
        MessagesReceived       int
        SubscriptionsCancelled int
        RequestsCancelled      int
        CleanupDurationMs      int64
        ConnectionNotFound     bool
        DeleteError            string
        SubscriptionError      string
        RequestError           string
}

// MetricsLogger handles metrics logging
type MetricsLogger struct {
        enabled bool
}

// NewMetricsLogger creates a new metrics logger
func NewMetricsLogger(enabled bool) *MetricsLogger <span class="cov8" title="8">{
        return &amp;MetricsLogger{enabled: enabled}
}</span>

// LogDisconnect logs disconnect metrics
func (m *MetricsLogger) LogDisconnect(ctx context.Context, metrics *DisconnectMetrics) <span class="cov8" title="8">{
        if !m.enabled </span><span class="cov3" title="2">{
                return
        }</span>

        // Format as JSON for CloudWatch Insights
        <span class="cov7" title="6">data := map[string]interface{}{
                "event_type":              "connection_disconnected",
                "connection_id":           metrics.ConnectionID,
                "user_id":                 metrics.UserID,
                "tenant_id":               metrics.TenantID,
                "disconnect_reason":       metrics.DisconnectReason,
                "duration_seconds":        metrics.DurationSeconds,
                "messages_sent":           metrics.MessagesSent,
                "messages_received":       metrics.MessagesReceived,
                "subscriptions_cancelled": metrics.SubscriptionsCancelled,
                "requests_cancelled":      metrics.RequestsCancelled,
                "cleanup_duration_ms":     metrics.CleanupDurationMs,
                "connection_not_found":    metrics.ConnectionNotFound,
                "has_delete_error":        metrics.DeleteError != "",
                "has_subscription_error":  metrics.SubscriptionError != "",
                "has_request_error":       metrics.RequestError != "",
                "timestamp":               time.Now().UTC().Format(time.RFC3339),
        }

        // Log as structured JSON
        jsonData, _ := json.Marshal(data)
        log.Printf("METRICS: %s", string(jsonData))</span>
}

// Helper function to parse int with default
func parseIntOrDefault(s string, defaultValue int) int <span class="cov10" title="14">{
        var value int
        n, err := fmt.Sscanf(s, "%d", &amp;value)
        if err != nil || n != 1 </span><span class="cov3" title="2">{
                return defaultValue
        }</span>
        // Check if we consumed the entire string
        <span class="cov9" title="12">var remainder string
        fmt.Sscanf(s, "%d%s", &amp;value, &amp;remainder)
        if remainder != "" </span><span class="cov1" title="1">{
                return defaultValue
        }</span>
        <span class="cov9" title="11">return value</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "context"
        "log"
        "os"

        "github.com/aws/aws-lambda-go/lambda"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/pay-theory/dynamorm/pkg/session"
        dynamormStore "github.com/pay-theory/streamer/internal/store/dynamorm"
        "github.com/pay-theory/streamer/lambda/shared"
)

func main() <span class="cov0" title="0">{
        // Load configuration from environment
        cfg := &amp;HandlerConfig{
                ConnectionsTable:   getEnv("CONNECTIONS_TABLE", "streamer_connections"),
                SubscriptionsTable: getEnv("SUBSCRIPTIONS_TABLE", "streamer_subscriptions"),
                RequestsTable:      getEnv("REQUESTS_TABLE", "streamer_requests"),
                MetricsEnabled:     getEnvBool("METRICS_ENABLED", true),
                LogLevel:           getEnv("LOG_LEVEL", "INFO"),
        }

        // Initialize AWS SDK for CloudWatch metrics
        awsCfg, err := config.LoadDefaultConfig(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load AWS config: %v", err)
        }</span>

        // Initialize DynamORM
        <span class="cov0" title="0">dynamormConfig := session.Config{
                Region: awsCfg.Region,
        }

        factory, err := dynamormStore.NewStoreFactory(dynamormConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create DynamORM factory: %v", err)
        }</span>

        // Get stores from factory
        <span class="cov0" title="0">connStore := factory.ConnectionStore()
        // Note: SubscriptionStore and RequestStore would be initialized here when implemented

        // Create CloudWatch metrics client
        metricsNamespace := getEnv("METRICS_NAMESPACE", "Streamer")
        metrics := shared.NewCloudWatchMetrics(awsCfg, metricsNamespace)

        // Create handler
        handler := NewHandler(connStore, nil, nil, cfg, metrics) // nil for subscription/request stores for now

        // Start Lambda runtime
        lambda.Start(handler.Handle)</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value == "true" || value == "1" || value == "yes"</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package executor

import (
        "context"
        "errors"
        "fmt"
        "log"
        "sync"
        "time"

        "github.com/pay-theory/streamer/internal/store"
        "github.com/pay-theory/streamer/pkg/connection"
        "github.com/pay-theory/streamer/pkg/progress"
        "github.com/pay-theory/streamer/pkg/streamer"
)

// AsyncExecutor handles async request processing
type AsyncExecutor struct {
        connManager      connection.ConnectionManager
        requestQueue     store.RequestQueue
        handlers         map[string]streamer.Handler
        progressHandlers map[string]streamer.HandlerWithProgress
        mu               sync.RWMutex
        logger           *log.Logger
}

// New creates a new async executor
func New(connManager connection.ConnectionManager, requestQueue store.RequestQueue, logger *log.Logger) *AsyncExecutor <span class="cov1" title="1">{
        return &amp;AsyncExecutor{
                connManager:      connManager,
                requestQueue:     requestQueue,
                handlers:         make(map[string]streamer.Handler),
                progressHandlers: make(map[string]streamer.HandlerWithProgress),
                logger:           logger,
        }
}</span>

// RegisterHandler registers an async handler
func (e *AsyncExecutor) RegisterHandler(action string, handler streamer.Handler) error <span class="cov2" title="4">{
        e.mu.Lock()
        defer e.mu.Unlock()

        if _, exists := e.handlers[action]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("handler already registered for action: %s", action)
        }</span>

        <span class="cov2" title="3">e.handlers[action] = handler

        // Check if handler supports progress reporting
        if progressHandler, ok := handler.(streamer.HandlerWithProgress); ok </span><span class="cov1" title="1">{
                e.progressHandlers[action] = progressHandler
                e.logger.Printf("Registered handler with progress support for action: %s", action)
        }</span> else<span class="cov1" title="2"> {
                e.logger.Printf("Registered handler without progress support for action: %s", action)
        }</span>

        <span class="cov2" title="3">return nil</span>
}

// ProcessRequest processes a single async request
func (e *AsyncExecutor) ProcessRequest(ctx context.Context, asyncReq *store.AsyncRequest) error <span class="cov4" title="10">{
        e.logger.Printf("Processing async request: %s, action: %s", asyncReq.RequestID, asyncReq.Action)

        // Update status to PROCESSING
        if err := e.requestQueue.UpdateStatus(ctx, asyncReq.RequestID, store.StatusProcessing, "Processing started"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update status: %w", err)
        }</span>

        // Update processing started time
        <span class="cov4" title="10">now := time.Now()
        asyncReq.ProcessingStarted = &amp;now

        // Get handler
        e.mu.RLock()
        handler, exists := e.handlers[asyncReq.Action]
        progressHandler, hasProgress := e.progressHandlers[asyncReq.Action]
        e.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                errMsg := fmt.Sprintf("unknown action: %s", asyncReq.Action)
                e.logger.Printf("Error: %s", errMsg)
                e.requestQueue.FailRequest(ctx, asyncReq.RequestID, errMsg)
                return errors.New(errMsg)
        }</span>

        // Convert AsyncRequest to streamer.Request
        <span class="cov4" title="9">request, err := streamer.ConvertAsyncRequestToRequest(asyncReq)
        if err != nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("failed to convert request: %v", err)
                e.logger.Printf("Error: %s", errMsg)
                e.requestQueue.FailRequest(ctx, asyncReq.RequestID, errMsg)
                return fmt.Errorf(errMsg)
        }</span>

        // Validate request
        <span class="cov4" title="9">if err := handler.Validate(request); err != nil </span><span class="cov1" title="2">{
                errMsg := fmt.Sprintf("validation failed: %v", err)
                e.logger.Printf("Error: %s", errMsg)
                e.requestQueue.FailRequest(ctx, asyncReq.RequestID, errMsg)
                return fmt.Errorf(errMsg)
        }</span>

        // Create progress reporter with batching for better performance
        <span class="cov3" title="7">reporter := progress.NewBatchedReporter(
                asyncReq.RequestID,
                asyncReq.ConnectionID,
                e.connManager,
                progress.WithInterval(200*time.Millisecond), // Batch every 200ms
                progress.WithMaxBatch(5),                    // Max 5 updates per batch
                progress.WithFlushThreshold(90.0),           // Flush at 90% or higher
        )

        // Report initial progress
        reporter.Report(0, "Processing started")

        // Process with appropriate handler
        var result *streamer.Result
        if hasProgress </span><span class="cov1" title="1">{
                // Use handler with progress support
                e.logger.Printf("Processing with progress support")
                result, err = progressHandler.ProcessWithProgress(ctx, request, reporter)
        }</span> else<span class="cov3" title="6"> {
                // Use regular handler
                e.logger.Printf("Processing without progress support")

                // Add reporter to context for handlers that might use it
                ctxWithReporter := progress.WithReporter(ctx, reporter)
                result, err = handler.Process(ctxWithReporter, request)

                // Send 100% progress for handlers without built-in progress
                reporter.Report(100, "Processing complete")
        }</span>

        // Handle processing result
        <span class="cov3" title="7">if err != nil </span><span class="cov2" title="3">{
                errMsg := fmt.Sprintf("handler failed: %v", err)
                e.logger.Printf("Error: %s", errMsg)

                // Update request status
                e.requestQueue.FailRequest(ctx, asyncReq.RequestID, errMsg)

                // Send failure notification
                reporter.Fail(err)

                return fmt.Errorf(errMsg)
        }</span>

        // Convert result to map for storage
        <span class="cov2" title="4">resultMap := make(map[string]interface{})
        if result.Data != nil </span><span class="cov1" title="2">{
                switch v := result.Data.(type) </span>{
                case map[string]interface{}:<span class="cov1" title="2">
                        resultMap = v</span>
                default:<span class="cov0" title="0">
                        resultMap["data"] = v</span>
                }
        }
        <span class="cov2" title="4">resultMap["success"] = result.Success
        if result.Metadata != nil </span><span class="cov0" title="0">{
                resultMap["metadata"] = result.Metadata
        }</span>

        // Update processing ended time
        <span class="cov2" title="4">endTime := time.Now()
        asyncReq.ProcessingEnded = &amp;endTime

        // Mark request as complete
        if err := e.requestQueue.CompleteRequest(ctx, asyncReq.RequestID, resultMap); err != nil </span><span class="cov0" title="0">{
                e.logger.Printf("Failed to complete request: %v", err)
                return fmt.Errorf("failed to complete request: %w", err)
        }</span>

        // Send completion notification
        <span class="cov2" title="4">reporter.Complete(resultMap)

        e.logger.Printf("Successfully processed request %s in %v",
                asyncReq.RequestID,
                endTime.Sub(*asyncReq.ProcessingStarted))

        // Shutdown the batched reporter gracefully
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()
        reporter.Shutdown(shutdownCtx)

        return nil</span>
}

// ProcessWithRetry processes a request with retry logic
func (e *AsyncExecutor) ProcessWithRetry(ctx context.Context, asyncReq *store.AsyncRequest) error <span class="cov2" title="4">{
        maxRetries := asyncReq.MaxRetries
        if maxRetries &lt;= 0 </span><span class="cov0" title="0">{
                maxRetries = 3
        }</span>

        <span class="cov2" title="4">var lastErr error
        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov3" title="6">{
                if attempt &gt; 0 </span><span class="cov1" title="2">{
                        // Update retry count
                        asyncReq.RetryCount = attempt
                        retryMsg := fmt.Sprintf("Retry attempt %d/%d", attempt, maxRetries)
                        e.logger.Printf("%s for request %s", retryMsg, asyncReq.RequestID)

                        // Update status with retry info
                        e.requestQueue.UpdateStatus(ctx, asyncReq.RequestID, store.StatusRetrying, retryMsg)

                        // Wait before retry (exponential backoff)
                        backoff := time.Duration(attempt) * time.Second * 2
                        if backoff &gt; 30*time.Second </span><span class="cov0" title="0">{
                                backoff = 30 * time.Second
                        }</span>

                        <span class="cov1" title="2">select </span>{
                        case &lt;-time.After(backoff):<span class="cov1" title="1"></span>
                                // Continue with retry
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return ctx.Err()</span>
                        }
                }

                // Process the request
                <span class="cov3" title="5">err := e.ProcessRequest(ctx, asyncReq)
                if err == nil </span><span class="cov1" title="2">{
                        return nil
                }</span>

                <span class="cov2" title="3">lastErr = err

                // Check if error is retryable
                if !isRetryableError(err) </span><span class="cov1" title="1">{
                        e.logger.Printf("Non-retryable error: %v", err)
                        break</span>
                }
        }

        <span class="cov1" title="1">return fmt.Errorf("failed after %d attempts: %w", asyncReq.RetryCount+1, lastErr)</span>
}

// isRetryableError determines if an error should trigger a retry
func isRetryableError(err error) bool <span class="cov4" title="12">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check for specific error types
        <span class="cov4" title="11">errStr := err.Error()

        // Network/timeout errors are retryable
        if contains(errStr, []string{"timeout", "connection refused", "EOF", "broken pipe"}) </span><span class="cov3" title="6">{
                return true
        }</span>

        // Validation errors are not retryable
        <span class="cov3" title="5">if contains(errStr, []string{"validation", "invalid", "required"}) </span><span class="cov2" title="4">{
                return false
        }</span>

        // Default to not retrying
        <span class="cov1" title="1">return false</span>
}

// contains checks if a string contains any of the given substrings
func contains(s string, substrs []string) bool <span class="cov5" title="21">{
        for _, substr := range substrs </span><span class="cov6" title="49">{
                if len(s) &gt;= len(substr) &amp;&amp; containsString(s, substr) </span><span class="cov4" title="12">{
                        return true
                }</span>
        }
        <span class="cov4" title="9">return false</span>
}

// containsString is a simple string contains check
func containsString(s, substr string) bool <span class="cov6" title="51">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || containsSubstring(s, substr))
}</span>

// containsSubstring checks if s contains substr
func containsSubstring(s, substr string) bool <span class="cov6" title="53">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov10" title="703">{
                if s[i:i+len(substr)] == substr </span><span class="cov4" title="16">{
                        return true
                }</span>
        }
        <span class="cov5" title="37">return false</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "math/rand"
        "time"

        "github.com/pay-theory/streamer/pkg/streamer"
)

// ReportHandlerWithProgress implements async report generation with progress updates
type ReportHandlerWithProgress struct {
        estimatedDuration time.Duration
}

func NewReportHandlerWithProgress() *ReportHandlerWithProgress <span class="cov0" title="0">{
        return &amp;ReportHandlerWithProgress{
                estimatedDuration: 2 * time.Minute,
        }
}</span>

func (h *ReportHandlerWithProgress) EstimatedDuration() time.Duration <span class="cov0" title="0">{
        return h.estimatedDuration
}</span>

func (h *ReportHandlerWithProgress) Validate(req *streamer.Request) error <span class="cov0" title="0">{
        if req.Payload == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("payload is required")
        }</span>

        <span class="cov0" title="0">var params map[string]interface{}
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid payload format: %w", err)
        }</span>

        // Basic validation
        <span class="cov0" title="0">if _, ok := params["start_date"]; !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("start_date is required")
        }</span>
        <span class="cov0" title="0">if _, ok := params["end_date"]; !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("end_date is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *ReportHandlerWithProgress) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov0" title="0">{
        // This should not be called for async handlers
        return nil, fmt.Errorf("use ProcessWithProgress for async handlers")
}</span>

func (h *ReportHandlerWithProgress) ProcessWithProgress(
        ctx context.Context,
        req *streamer.Request,
        reporter streamer.ProgressReporter,
) (*streamer.Result, error) <span class="cov0" title="0">{
        // Parse parameters
        var params map[string]interface{}
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse payload: %w", err)
        }</span>

        // Step 1: Query data (0-30%)
        <span class="cov0" title="0">reporter.Report(0, "Starting report generation...")

        // Simulate data query
        select </span>{
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                reporter.Report(30, fmt.Sprintf("Queried %d records", 1000+rand.Intn(9000)))</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }

        // Step 2: Process data (30-60%)
        <span class="cov0" title="0">reporter.Report(30, "Processing data...")

        // Simulate data processing
        select </span>{
        case &lt;-time.After(10 * time.Second):<span class="cov0" title="0">
                reporter.Report(60, "Data processing complete")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }

        // Step 3: Generate report (60-90%)
        <span class="cov0" title="0">reporter.Report(60, "Generating report file...")

        // Simulate report generation
        select </span>{
        case &lt;-time.After(8 * time.Second):<span class="cov0" title="0">
                reporter.Report(90, "Uploading to S3...")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }

        // Step 4: Upload to S3 (90-100%)
        <span class="cov0" title="0">select </span>{
        case &lt;-time.After(3 * time.Second):<span class="cov0" title="0">
                reporter.Report(100, "Report ready!")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        }

        // Return success result
        <span class="cov0" title="0">reportURL := fmt.Sprintf("https://reports.example.com/%s/report-%d.pdf",
                req.ID,
                time.Now().Unix())

        return &amp;streamer.Result{
                RequestID: req.ID,
                Success:   true,
                Data: map[string]interface{}{
                        "url":          reportURL,
                        "records":      1000 + rand.Intn(9000),
                        "size_bytes":   1024 * 1024 * (1 + rand.Intn(10)),
                        "format":       params["format"],
                        "generated_at": time.Now().Format(time.RFC3339),
                },
        }, nil</span>
}

// DataProcessingHandlerWithProgress implements async data processing with progress updates
type DataProcessingHandlerWithProgress struct {
        estimatedDuration time.Duration
}

func NewDataProcessingHandlerWithProgress() *DataProcessingHandlerWithProgress <span class="cov0" title="0">{
        return &amp;DataProcessingHandlerWithProgress{
                estimatedDuration: 5 * time.Minute,
        }
}</span>

func (h *DataProcessingHandlerWithProgress) EstimatedDuration() time.Duration <span class="cov0" title="0">{
        return h.estimatedDuration
}</span>

func (h *DataProcessingHandlerWithProgress) Validate(req *streamer.Request) error <span class="cov0" title="0">{
        if req.Payload == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("payload is required")
        }</span>

        <span class="cov0" title="0">var params map[string]interface{}
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid payload format: %w", err)
        }</span>

        <span class="cov0" title="0">if _, ok := params["dataset_id"]; !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("dataset_id is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *DataProcessingHandlerWithProgress) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("use ProcessWithProgress for async handlers")
}</span>

func (h *DataProcessingHandlerWithProgress) ProcessWithProgress(
        ctx context.Context,
        req *streamer.Request,
        reporter streamer.ProgressReporter,
) (*streamer.Result, error) <span class="cov0" title="0">{
        var params map[string]interface{}
        json.Unmarshal(req.Payload, &amp;params)

        // Simulate multi-step data processing
        steps := []struct {
                name     string
                duration time.Duration
                progress float64
        }{
                {"Loading dataset", 5 * time.Second, 20},
                {"Validating data", 3 * time.Second, 35},
                {"Applying transformations", 8 * time.Second, 60},
                {"Aggregating results", 6 * time.Second, 80},
                {"Saving output", 4 * time.Second, 100},
        }

        currentProgress := float64(0)
        for _, step := range steps </span><span class="cov0" title="0">{
                reporter.Report(currentProgress, step.name+"...")

                select </span>{
                case &lt;-time.After(step.duration):<span class="cov0" title="0">
                        currentProgress = step.progress
                        reporter.Report(currentProgress, step.name+" complete")</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }

        <span class="cov0" title="0">return &amp;streamer.Result{
                RequestID: req.ID,
                Success:   true,
                Data: map[string]interface{}{
                        "dataset_id":              params["dataset_id"],
                        "rows_processed":          50000 + rand.Intn(50000),
                        "output_format":           "parquet",
                        "output_path":             fmt.Sprintf("s3://processed-data/%s/output-%d.parquet", params["dataset_id"], time.Now().Unix()),
                        "processing_time_seconds": 26,
                },
        }, nil</span>
}

// BulkHandlerWithProgress implements async bulk operations with progress updates
type BulkHandlerWithProgress struct {
        estimatedDuration time.Duration
}

func NewBulkHandlerWithProgress() *BulkHandlerWithProgress <span class="cov0" title="0">{
        return &amp;BulkHandlerWithProgress{
                estimatedDuration: 10 * time.Minute,
        }
}</span>

func (h *BulkHandlerWithProgress) EstimatedDuration() time.Duration <span class="cov0" title="0">{
        return h.estimatedDuration
}</span>

func (h *BulkHandlerWithProgress) Validate(req *streamer.Request) error <span class="cov0" title="0">{
        if req.Payload == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("payload is required")
        }</span>

        <span class="cov0" title="0">var params map[string]interface{}
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid payload format: %w", err)
        }</span>

        <span class="cov0" title="0">items, ok := params["items"].([]interface{})
        if !ok || len(items) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("items array is required and must not be empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *BulkHandlerWithProgress) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("use ProcessWithProgress for async handlers")
}</span>

func (h *BulkHandlerWithProgress) ProcessWithProgress(
        ctx context.Context,
        req *streamer.Request,
        reporter streamer.ProgressReporter,
) (*streamer.Result, error) <span class="cov0" title="0">{
        var params map[string]interface{}
        json.Unmarshal(req.Payload, &amp;params)

        items, _ := params["items"].([]interface{})
        totalItems := len(items)
        batchSize := 25
        if bs, ok := params["batch_size"].(float64); ok &amp;&amp; bs &gt; 0 </span><span class="cov0" title="0">{
                batchSize = int(bs)
        }</span>

        <span class="cov0" title="0">processed := 0
        failed := 0

        reporter.Report(0, fmt.Sprintf("Starting bulk operation for %d items", totalItems))

        // Process in batches
        for i := 0; i &lt; totalItems; i += batchSize </span><span class="cov0" title="0">{
                end := i + batchSize
                if end &gt; totalItems </span><span class="cov0" title="0">{
                        end = totalItems
                }</span>

                <span class="cov0" title="0">batchNum := (i / batchSize) + 1
                totalBatches := (totalItems + batchSize - 1) / batchSize

                reporter.SetMetadata("current_batch", batchNum)
                reporter.SetMetadata("total_batches", totalBatches)

                // Simulate batch processing
                select </span>{
                case &lt;-time.After(2 * time.Second):<span class="cov0" title="0">
                        // Simulate some failures
                        if rand.Float32() &lt; 0.1 </span><span class="cov0" title="0">{ // 10% failure rate
                                failed += end - i
                        }</span> else<span class="cov0" title="0"> {
                                processed += end - i
                        }</span>

                        <span class="cov0" title="0">progress := float64(end) / float64(totalItems) * 100
                        reporter.Report(progress, fmt.Sprintf("Processed batch %d/%d", batchNum, totalBatches))</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                }
        }

        <span class="cov0" title="0">success := failed == 0
        message := "All items processed successfully"
        if failed &gt; 0 </span><span class="cov0" title="0">{
                message = fmt.Sprintf("Completed with %d failures", failed)
        }</span>

        <span class="cov0" title="0">return &amp;streamer.Result{
                RequestID: req.ID,
                Success:   success,
                Data: map[string]interface{}{
                        "total_items":    totalItems,
                        "processed":      processed,
                        "failed":         failed,
                        "success_rate":   float64(processed) / float64(totalItems) * 100,
                        "operation_type": params["operation_type"],
                        "message":        message,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "math/rand"
        "time"

        "github.com/pay-theory/streamer/pkg/streamer"
)

// DataProcessorHandler implements async data processing with ML pipeline simulation
type DataProcessorHandler struct {
        modelVersion string
        maxBatchSize int
}

// NewDataProcessorHandler creates a new data processor handler
func NewDataProcessorHandler() *DataProcessorHandler <span class="cov1" title="1">{
        return &amp;DataProcessorHandler{
                modelVersion: "v2.3.1",
                maxBatchSize: 1000,
        }
}</span>

// EstimatedDuration returns the expected processing time
func (h *DataProcessorHandler) EstimatedDuration() time.Duration <span class="cov1" title="1">{
        return 5 * time.Minute
}</span>

// Validate validates the data processing request
func (h *DataProcessorHandler) Validate(req *streamer.Request) error <span class="cov1" title="2">{
        if req.Payload == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("payload is required")
        }</span>

        <span class="cov1" title="2">var params DataProcessingParams
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid payload format: %w", err)
        }</span>

        // Validate pipeline type
        <span class="cov1" title="2">validPipelines := map[string]bool{
                "classification": true,
                "regression":     true,
                "clustering":     true,
                "anomaly":        true,
                "transformation": true,
        }
        if !validPipelines[params.Pipeline] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid pipeline: %s", params.Pipeline)
        }</span>

        // Validate data source
        <span class="cov1" title="1">if params.DataSource.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("data_source.type is required")
        }</span>

        // Validate based on source type
        <span class="cov1" title="1">switch params.DataSource.Type </span>{
        case "file":<span class="cov1" title="1">
                if params.DataSource.Path == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("data_source.path is required for file type")
                }</span>
        case "query":<span class="cov0" title="0">
                if params.DataSource.Query == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("data_source.query is required for query type")
                }</span>
        case "stream":<span class="cov0" title="0">
                if params.DataSource.StreamID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("data_source.stream_id is required for stream type")
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid data_source.type: %s", params.DataSource.Type)</span>
        }

        // Validate output configuration
        <span class="cov1" title="1">if params.Output.Format == "" </span><span class="cov0" title="0">{
                params.Output.Format = "json" // Default
        }</span>

        <span class="cov1" title="1">validFormats := map[string]bool{"json": true, "csv": true, "parquet": true}
        if !validFormats[params.Output.Format] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid output.format: %s", params.Output.Format)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Process should not be called for async handlers
func (h *DataProcessorHandler) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("use ProcessWithProgress for async handlers")
}</span>

// ProcessWithProgress implements the ML pipeline processing with detailed progress
func (h *DataProcessorHandler) ProcessWithProgress(
        ctx context.Context,
        req *streamer.Request,
        reporter streamer.ProgressReporter,
) (*streamer.Result, error) <span class="cov1" title="1">{
        // Parse parameters
        var params DataProcessingParams
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse payload: %w", err)
        }</span>

        // Set metadata
        <span class="cov1" title="1">reporter.SetMetadata("pipeline", params.Pipeline)
        reporter.SetMetadata("model_version", h.modelVersion)
        reporter.SetMetadata("data_source_type", params.DataSource.Type)

        // Execute pipeline stages
        reporter.Report(0, "Initializing pipeline...")

        // Stage 1: Data ingestion (0-20%)
        dataStats, err := h.ingestData(ctx, params, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("data ingestion failed: %w", err)
        }</span>

        // Stage 2: Preprocessing (20-40%)
        <span class="cov1" title="1">preprocessed, err := h.preprocessData(ctx, dataStats, params, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("preprocessing failed: %w", err)
        }</span>

        // Stage 3: Feature engineering (40-60%)
        <span class="cov1" title="1">features, err := h.engineerFeatures(ctx, preprocessed, params, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("feature engineering failed: %w", err)
        }</span>

        // Stage 4: Model processing (60-85%)
        <span class="cov1" title="1">results, err := h.runModel(ctx, features, params, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("model processing failed: %w", err)
        }</span>

        // Stage 5: Post-processing and output (85-100%)
        <span class="cov1" title="1">output, err := h.postProcess(ctx, results, params, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("post-processing failed: %w", err)
        }</span>

        <span class="cov1" title="1">reporter.Report(100, "Processing complete!")

        return &amp;streamer.Result{
                RequestID: req.ID,
                Success:   true,
                Data:      output,
                Metadata: map[string]string{
                        "pipeline":          params.Pipeline,
                        "model_version":     h.modelVersion,
                        "processing_id":     fmt.Sprintf("proc-%d", time.Now().Unix()),
                        "records_processed": fmt.Sprintf("%d", results.RecordsProcessed),
                },
        }, nil</span>
}

// ingestData handles data ingestion from various sources
func (h *DataProcessorHandler) ingestData(ctx context.Context, params DataProcessingParams, reporter streamer.ProgressReporter) (*DataStats, error) <span class="cov1" title="1">{
        stats := &amp;DataStats{
                StartTime: time.Now(),
        }

        switch params.DataSource.Type </span>{
        case "file":<span class="cov0" title="0">
                return h.ingestFromFile(ctx, params.DataSource.Path, reporter, stats)</span>
        case "query":<span class="cov1" title="1">
                return h.ingestFromQuery(ctx, params.DataSource.Query, reporter, stats)</span>
        case "stream":<span class="cov0" title="0">
                return h.ingestFromStream(ctx, params.DataSource.StreamID, reporter, stats)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported source type: %s", params.DataSource.Type)</span>
        }
}

// ingestFromFile simulates file-based data ingestion
func (h *DataProcessorHandler) ingestFromFile(ctx context.Context, path string, reporter streamer.ProgressReporter, stats *DataStats) (*DataStats, error) <span class="cov0" title="0">{
        // Simulate reading file in chunks
        totalChunks := 10
        recordsPerChunk := 5000

        for i := 1; i &lt;= totalChunks; i++ </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-time.After(200 * time.Millisecond):<span class="cov0" title="0">
                        stats.TotalRecords += recordsPerChunk
                        progress := float64(i) / float64(totalChunks) * 20.0
                        reporter.Report(progress, fmt.Sprintf("Read %d records from file", stats.TotalRecords))</span>
                }
        }

        <span class="cov0" title="0">stats.Columns = []string{"id", "timestamp", "value", "category", "score", "metadata"}
        stats.DataTypes = map[string]string{
                "id":        "string",
                "timestamp": "datetime",
                "value":     "float",
                "category":  "string",
                "score":     "int",
                "metadata":  "json",
        }

        return stats, nil</span>
}

// ingestFromQuery simulates query-based data ingestion
func (h *DataProcessorHandler) ingestFromQuery(ctx context.Context, query string, reporter streamer.ProgressReporter, stats *DataStats) (*DataStats, error) <span class="cov1" title="1">{
        // Simulate executing query and fetching results
        reporter.Report(5, "Executing query...")

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(2 * time.Second):<span class="cov1" title="1">
                reporter.Report(10, "Query executed, fetching results...")</span>
        }

        // Simulate fetching in batches
        <span class="cov1" title="1">batches := 8
        for i := 1; i &lt;= batches; i++ </span><span class="cov2" title="8">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-time.After(300 * time.Millisecond):<span class="cov2" title="8">
                        stats.TotalRecords += 3000
                        progress := 10 + (float64(i)/float64(batches))*10.0
                        reporter.Report(progress, fmt.Sprintf("Fetched %d records", stats.TotalRecords))</span>
                }
        }

        <span class="cov1" title="1">stats.Columns = []string{"user_id", "event_time", "event_type", "properties"}
        stats.DataTypes = map[string]string{
                "user_id":    "string",
                "event_time": "timestamp",
                "event_type": "string",
                "properties": "json",
        }

        return stats, nil</span>
}

// ingestFromStream simulates stream-based data ingestion
func (h *DataProcessorHandler) ingestFromStream(ctx context.Context, streamID string, reporter streamer.ProgressReporter, stats *DataStats) (*DataStats, error) <span class="cov0" title="0">{
        // Simulate connecting to stream
        reporter.Report(2, "Connecting to stream...")

        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(1 * time.Second):<span class="cov0" title="0">
                reporter.Report(5, "Connected, consuming messages...")</span>
        }

        // Simulate consuming messages
        <span class="cov0" title="0">duration := 5 * time.Second
        endTime := time.Now().Add(duration)
        ticker := time.NewTicker(500 * time.Millisecond)
        defer ticker.Stop()

        messageCount := 0
        for time.Now().Before(endTime) </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        messageCount++
                        stats.TotalRecords += rand.Intn(1000) + 500
                        elapsed := time.Since(stats.StartTime)
                        progress := 5 + (elapsed.Seconds()/duration.Seconds())*15.0
                        reporter.Report(progress, fmt.Sprintf("Consumed %d messages (%d records)", messageCount, stats.TotalRecords))</span>
                }
        }

        <span class="cov0" title="0">stats.Columns = []string{"message_id", "timestamp", "payload", "partition", "offset"}
        stats.DataTypes = map[string]string{
                "message_id": "string",
                "timestamp":  "timestamp",
                "payload":    "binary",
                "partition":  "int",
                "offset":     "long",
        }

        return stats, nil</span>
}

// preprocessData handles data preprocessing
func (h *DataProcessorHandler) preprocessData(ctx context.Context, stats *DataStats, params DataProcessingParams, reporter streamer.ProgressReporter) (*PreprocessedData, error) <span class="cov1" title="1">{
        preprocessed := &amp;PreprocessedData{
                OriginalRecords: stats.TotalRecords,
                StartTime:       time.Now(),
        }

        // Data cleaning
        reporter.Report(20, "Cleaning data...")
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(1 * time.Second):<span class="cov1" title="1">
                preprocessed.CleanedRecords = int(float64(stats.TotalRecords) * 0.95) // 5% removed
                preprocessed.RemovedDuplicates = int(float64(stats.TotalRecords) * 0.02)
                preprocessed.RemovedInvalid = int(float64(stats.TotalRecords) * 0.03)
                reporter.Report(25, fmt.Sprintf("Cleaned %d records (removed %d)",
                        preprocessed.CleanedRecords,
                        preprocessed.RemovedDuplicates+preprocessed.RemovedInvalid))</span>
        }

        // Normalization
        <span class="cov1" title="1">reporter.Report(30, "Normalizing data...")
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(1500 * time.Millisecond):<span class="cov1" title="1">
                preprocessed.NormalizedColumns = []string{"value", "score"}
                reporter.Report(35, "Data normalized")</span>
        }

        // Handle missing values
        <span class="cov1" title="1">reporter.Report(35, "Handling missing values...")
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(800 * time.Millisecond):<span class="cov1" title="1">
                preprocessed.ImputedValues = map[string]int{
                        "value": 1234,
                        "score": 567,
                }
                reporter.Report(40, "Missing values handled")</span>
        }

        <span class="cov1" title="1">preprocessed.ProcessingTime = time.Since(preprocessed.StartTime)
        return preprocessed, nil</span>
}

// engineerFeatures performs feature engineering
func (h *DataProcessorHandler) engineerFeatures(ctx context.Context, preprocessed *PreprocessedData, params DataProcessingParams, reporter streamer.ProgressReporter) (*FeatureSet, error) <span class="cov1" title="1">{
        features := &amp;FeatureSet{
                RecordCount: preprocessed.CleanedRecords,
                Features:    make(map[string]FeatureInfo),
        }

        // Extract basic features
        reporter.Report(40, "Extracting basic features...")
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(1 * time.Second):<span class="cov1" title="1">
                features.Features["mean_value"] = FeatureInfo{Type: "numeric", Importance: 0.85}
                features.Features["std_value"] = FeatureInfo{Type: "numeric", Importance: 0.72}
                features.Features["category_encoded"] = FeatureInfo{Type: "categorical", Importance: 0.68}
                reporter.Report(45, "Basic features extracted")</span>
        }

        // Generate derived features
        <span class="cov1" title="1">reporter.Report(45, "Generating derived features...")
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(1500 * time.Millisecond):<span class="cov1" title="1">
                features.Features["value_squared"] = FeatureInfo{Type: "numeric", Importance: 0.61}
                features.Features["value_log"] = FeatureInfo{Type: "numeric", Importance: 0.55}
                features.Features["interaction_score_value"] = FeatureInfo{Type: "numeric", Importance: 0.78}
                reporter.Report(52, "Derived features generated")</span>
        }

        // Feature selection
        <span class="cov1" title="1">reporter.Report(52, "Selecting important features...")
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(1 * time.Second):<span class="cov1" title="1">
                // Keep features with importance &gt; 0.6
                selectedCount := 0
                for name, info := range features.Features </span><span class="cov2" title="6">{
                        if info.Importance &gt; 0.6 </span><span class="cov2" title="5">{
                                selectedCount++
                        }</span> else<span class="cov1" title="1"> {
                                delete(features.Features, name)
                        }</span>
                }
                <span class="cov1" title="1">features.SelectedCount = selectedCount
                reporter.Report(60, fmt.Sprintf("Selected %d features", selectedCount))</span>
        }

        <span class="cov1" title="1">return features, nil</span>
}

// runModel executes the ML model
func (h *DataProcessorHandler) runModel(ctx context.Context, features *FeatureSet, params DataProcessingParams, reporter streamer.ProgressReporter) (*ModelResults, error) <span class="cov1" title="1">{
        results := &amp;ModelResults{
                ModelVersion:     h.modelVersion,
                Pipeline:         params.Pipeline,
                StartTime:        time.Now(),
                RecordsProcessed: features.RecordCount,
        }

        // Model initialization
        reporter.Report(60, "Loading model...")
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(1 * time.Second):<span class="cov1" title="1">
                reporter.Report(65, fmt.Sprintf("Model %s loaded", h.modelVersion))</span>
        }

        // Process in batches
        <span class="cov1" title="1">totalBatches := (features.RecordCount + h.maxBatchSize - 1) / h.maxBatchSize
        processedBatches := 0

        for batch := 0; batch &lt; totalBatches; batch++ </span><span class="cov3" title="23">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-time.After(500 * time.Millisecond):<span class="cov3" title="23">
                        processedBatches++
                        progress := 65 + (float64(processedBatches)/float64(totalBatches))*20.0

                        // Simulate different processing based on pipeline type
                        switch params.Pipeline </span>{
                        case "classification":<span class="cov3" title="23">
                                results.Predictions = append(results.Predictions, generateClassificationResults(h.maxBatchSize)...)</span>
                        case "regression":<span class="cov0" title="0">
                                results.Predictions = append(results.Predictions, generateRegressionResults(h.maxBatchSize)...)</span>
                        case "clustering":<span class="cov0" title="0">
                                results.Predictions = append(results.Predictions, generateClusteringResults(h.maxBatchSize)...)</span>
                        case "anomaly":<span class="cov0" title="0">
                                results.Predictions = append(results.Predictions, generateAnomalyResults(h.maxBatchSize)...)</span>
                        }

                        <span class="cov3" title="23">reporter.Report(progress, fmt.Sprintf("Processed batch %d/%d", processedBatches, totalBatches))</span>
                }
        }

        // Calculate metrics
        <span class="cov1" title="1">results.ProcessingTime = time.Since(results.StartTime)
        results.Metrics = calculateMetrics(params.Pipeline, results.Predictions)

        return results, nil</span>
}

// postProcess handles post-processing and output generation
func (h *DataProcessorHandler) postProcess(ctx context.Context, results *ModelResults, params DataProcessingParams, reporter streamer.ProgressReporter) (map[string]interface{}, error) <span class="cov1" title="1">{
        reporter.Report(85, "Post-processing results...")

        output := make(map[string]interface{})

        // Aggregate results
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(1 * time.Second):<span class="cov1" title="1">
                output["summary"] = map[string]interface{}{
                        "total_records":   results.RecordsProcessed,
                        "processing_time": results.ProcessingTime.Seconds(),
                        "model_version":   results.ModelVersion,
                        "pipeline":        results.Pipeline,
                        "metrics":         results.Metrics,
                }
                reporter.Report(90, "Results aggregated")</span>
        }

        // Format output based on requested format
        <span class="cov1" title="1">reporter.Report(92, fmt.Sprintf("Formatting output as %s...", params.Output.Format))
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(800 * time.Millisecond):<span class="cov1" title="1">
                switch params.Output.Format </span>{
                case "json":<span class="cov1" title="1">
                        output["data"] = results.Predictions[:min(100, len(results.Predictions))]</span> // Sample
                case "csv":<span class="cov0" title="0">
                        output["csv_url"] = fmt.Sprintf("https://storage.example.com/results/%s.csv", results.OutputID)</span>
                case "parquet":<span class="cov0" title="0">
                        output["parquet_url"] = fmt.Sprintf("https://storage.example.com/results/%s.parquet", results.OutputID)</span>
                }
                <span class="cov1" title="1">reporter.Report(95, "Output formatted")</span>
        }

        // Save results if destination specified
        <span class="cov1" title="1">if params.Output.Destination != "" </span><span class="cov0" title="0">{
                reporter.Report(96, "Saving results...")
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-time.After(1200 * time.Millisecond):<span class="cov0" title="0">
                        output["saved_to"] = params.Output.Destination
                        reporter.Report(99, "Results saved")</span>
                }
        }

        <span class="cov1" title="1">return output, nil</span>
}

// Helper functions

func generateClassificationResults(count int) []interface{} <span class="cov3" title="23">{
        results := make([]interface{}, count)
        classes := []string{"A", "B", "C", "D"}
        for i := 0; i &lt; count; i++ </span><span class="cov10" title="23000">{
                results[i] = map[string]interface{}{
                        "class":      classes[rand.Intn(len(classes))],
                        "confidence": rand.Float64(),
                }
        }</span>
        <span class="cov3" title="23">return results</span>
}

func generateRegressionResults(count int) []interface{} <span class="cov0" title="0">{
        results := make([]interface{}, count)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = map[string]interface{}{
                        "prediction": rand.Float64() * 100,
                        "confidence": rand.Float64(),
                }
        }</span>
        <span class="cov0" title="0">return results</span>
}

func generateClusteringResults(count int) []interface{} <span class="cov0" title="0">{
        results := make([]interface{}, count)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = map[string]interface{}{
                        "cluster":  rand.Intn(5),
                        "distance": rand.Float64(),
                }
        }</span>
        <span class="cov0" title="0">return results</span>
}

func generateAnomalyResults(count int) []interface{} <span class="cov0" title="0">{
        results := make([]interface{}, count)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                results[i] = map[string]interface{}{
                        "is_anomaly": rand.Float64() &gt; 0.95,
                        "score":      rand.Float64(),
                }
        }</span>
        <span class="cov0" title="0">return results</span>
}

func calculateMetrics(pipeline string, predictions []interface{}) map[string]float64 <span class="cov1" title="1">{
        metrics := make(map[string]float64)

        switch pipeline </span>{
        case "classification":<span class="cov1" title="1">
                metrics["accuracy"] = 0.92 + rand.Float64()*0.05
                metrics["precision"] = 0.89 + rand.Float64()*0.08
                metrics["recall"] = 0.91 + rand.Float64()*0.06
                metrics["f1_score"] = 0.90 + rand.Float64()*0.07</span>
        case "regression":<span class="cov0" title="0">
                metrics["mse"] = rand.Float64() * 10
                metrics["rmse"] = rand.Float64() * 5
                metrics["mae"] = rand.Float64() * 3
                metrics["r2"] = 0.85 + rand.Float64()*0.1</span>
        case "clustering":<span class="cov0" title="0">
                metrics["silhouette_score"] = 0.6 + rand.Float64()*0.3
                metrics["davies_bouldin"] = rand.Float64() * 2
                metrics["calinski_harabasz"] = 100 + rand.Float64()*50</span>
        case "anomaly":<span class="cov0" title="0">
                metrics["precision"] = 0.95 + rand.Float64()*0.04
                metrics["recall"] = 0.88 + rand.Float64()*0.1
                metrics["f1_score"] = 0.91 + rand.Float64()*0.08</span>
        }

        <span class="cov1" title="1">return metrics</span>
}

func min(a, b int) int <span class="cov1" title="1">{
        if a &lt; b </span><span class="cov1" title="1">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// Type definitions

type DataProcessingParams struct {
        Pipeline   string                 `json:"pipeline"` // classification, regression, clustering, anomaly, transformation
        DataSource DataSource             `json:"data_source"`
        Output     OutputConfig           `json:"output"`
        Options    map[string]interface{} `json:"options,omitempty"`
}

type DataSource struct {
        Type     string                 `json:"type"` // file, query, stream
        Path     string                 `json:"path,omitempty"`
        Query    string                 `json:"query,omitempty"`
        StreamID string                 `json:"stream_id,omitempty"`
        Config   map[string]interface{} `json:"config,omitempty"`
}

type OutputConfig struct {
        Format      string                 `json:"format"` // json, csv, parquet
        Destination string                 `json:"destination,omitempty"`
        Options     map[string]interface{} `json:"options,omitempty"`
}

type DataStats struct {
        StartTime    time.Time
        TotalRecords int
        Columns      []string
        DataTypes    map[string]string
}

type PreprocessedData struct {
        OriginalRecords   int
        CleanedRecords    int
        RemovedDuplicates int
        RemovedInvalid    int
        NormalizedColumns []string
        ImputedValues     map[string]int
        StartTime         time.Time
        ProcessingTime    time.Duration
}

type FeatureSet struct {
        RecordCount   int
        Features      map[string]FeatureInfo
        SelectedCount int
}

type FeatureInfo struct {
        Type       string // numeric, categorical, text
        Importance float64
}

type ModelResults struct {
        ModelVersion     string
        Pipeline         string
        StartTime        time.Time
        ProcessingTime   time.Duration
        RecordsProcessed int
        Predictions      []interface{}
        Metrics          map[string]float64
        OutputID         string
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/pay-theory/streamer/pkg/streamer"
)

// EchoAsyncHandler is a simple test handler that echoes the input with progress updates
type EchoAsyncHandler struct{}

// NewEchoAsyncHandler creates a new echo async handler
func NewEchoAsyncHandler() *EchoAsyncHandler <span class="cov0" title="0">{
        return &amp;EchoAsyncHandler{}
}</span>

// EstimatedDuration returns the expected processing time
func (h *EchoAsyncHandler) EstimatedDuration() time.Duration <span class="cov0" title="0">{
        return 10 * time.Second
}</span>

// Validate validates the echo request
func (h *EchoAsyncHandler) Validate(req *streamer.Request) error <span class="cov0" title="0">{
        if req.Payload == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("payload is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Process should not be called for async handlers
func (h *EchoAsyncHandler) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("use ProcessWithProgress for async handlers")
}</span>

// ProcessWithProgress echoes the input with simulated progress
func (h *EchoAsyncHandler) ProcessWithProgress(
        ctx context.Context,
        req *streamer.Request,
        reporter streamer.ProgressReporter,
) (*streamer.Result, error) <span class="cov0" title="0">{
        // Parse the payload
        var input map[string]interface{}
        if err := json.Unmarshal(req.Payload, &amp;input); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse payload: %w", err)
        }</span>

        // Simple progress steps
        <span class="cov0" title="0">steps := []struct {
                percentage float64
                message    string
                duration   time.Duration
        }{
                {0, "Starting echo processing...", 1 * time.Second},
                {25, "Validating input...", 1 * time.Second},
                {50, "Processing data...", 2 * time.Second},
                {75, "Preparing response...", 1 * time.Second},
                {100, "Echo complete!", 0},
        }

        for _, step := range steps </span><span class="cov0" title="0">{
                // Report progress
                if err := reporter.Report(step.percentage, step.message); err != nil </span><span class="cov0" title="0">{
                        // Log but don't fail
                        fmt.Printf("Failed to report progress: %v\n", err)
                }</span>

                // Simulate work
                <span class="cov0" title="0">if step.duration &gt; 0 </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-time.After(step.duration):<span class="cov0" title="0"></span>
                                // Continue
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, ctx.Err()</span>
                        }
                }
        }

        // Return the echoed result
        <span class="cov0" title="0">return &amp;streamer.Result{
                RequestID: req.ID,
                Success:   true,
                Data: map[string]interface{}{
                        "echo":         input,
                        "processed_at": time.Now().Format(time.RFC3339),
                        "handler":      "echo_async",
                },
                Metadata: map[string]string{
                        "test": "true",
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/pay-theory/streamer/pkg/streamer"
)

// ReportAsyncHandler implements async report generation with progress tracking
type ReportAsyncHandler struct {
        outputPath string // Mock output path for reports
}

// NewReportAsyncHandler creates a new async report handler
func NewReportAsyncHandler() *ReportAsyncHandler <span class="cov1" title="1">{
        return &amp;ReportAsyncHandler{
                outputPath: "/tmp/reports", // In production, this would be S3
        }
}</span>

// EstimatedDuration returns the expected processing time
func (h *ReportAsyncHandler) EstimatedDuration() time.Duration <span class="cov1" title="1">{
        return 2 * time.Minute
}</span>

// Validate validates the report generation request
func (h *ReportAsyncHandler) Validate(req *streamer.Request) error <span class="cov4" title="3">{
        if req.Payload == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("payload is required")
        }</span>

        <span class="cov4" title="3">var params ReportParams
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid payload format: %w", err)
        }</span>

        // Validate required fields
        <span class="cov4" title="3">if params.StartDate == "" || params.EndDate == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("start_date and end_date are required")
        }</span>

        // Parse dates
        <span class="cov3" title="2">startDate, err := time.Parse("2006-01-02", params.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid start_date format: %w", err)
        }</span>

        <span class="cov3" title="2">endDate, err := time.Parse("2006-01-02", params.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid end_date format: %w", err)
        }</span>

        <span class="cov3" title="2">if startDate.After(endDate) </span><span class="cov0" title="0">{
                return fmt.Errorf("start_date must be before end_date")
        }</span>

        // Validate date range (max 1 year)
        <span class="cov3" title="2">if endDate.Sub(startDate) &gt; 365*24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Errorf("date range cannot exceed 1 year")
        }</span>

        // Validate format
        <span class="cov3" title="2">validFormats := map[string]bool{"pdf": true, "csv": true, "excel": true}
        if !validFormats[params.Format] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid format: %s (must be pdf, csv, or excel)", params.Format)
        }</span>

        // Validate report type
        <span class="cov1" title="1">validTypes := map[string]bool{"monthly": true, "quarterly": true, "annual": true, "custom": true}
        if !validTypes[params.ReportType] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid report_type: %s", params.ReportType)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Process should not be called for async handlers
func (h *ReportAsyncHandler) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("use ProcessWithProgress for async handlers")
}</span>

// ProcessWithProgress implements the actual report generation with progress updates
func (h *ReportAsyncHandler) ProcessWithProgress(
        ctx context.Context,
        req *streamer.Request,
        reporter streamer.ProgressReporter,
) (*streamer.Result, error) <span class="cov1" title="1">{
        // Parse parameters
        var params ReportParams
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse payload: %w", err)
        }</span>

        // Add request metadata
        <span class="cov1" title="1">reporter.SetMetadata("report_type", params.ReportType)
        reporter.SetMetadata("format", params.Format)
        reporter.SetMetadata("date_range", fmt.Sprintf("%s to %s", params.StartDate, params.EndDate))

        // Step 1: Query data (0-30%)
        reporter.Report(0, "Querying data...")
        queryResult, err := h.queryData(ctx, params, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query data: %w", err)
        }</span>

        // Step 2: Process data (30-60%)
        <span class="cov1" title="1">reporter.Report(30, "Processing data...")
        processedData, err := h.processData(ctx, queryResult, params, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to process data: %w", err)
        }</span>

        // Step 3: Generate report (60-90%)
        <span class="cov1" title="1">reporter.Report(60, "Generating report file...")
        reportInfo, err := h.generateReport(ctx, processedData, params, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate report: %w", err)
        }</span>

        // Step 4: Finalize and store (90-100%)
        <span class="cov1" title="1">reporter.Report(90, "Finalizing report...")
        reportURL, err := h.finalizeReport(ctx, reportInfo, params, reporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to finalize report: %w", err)
        }</span>

        <span class="cov1" title="1">reporter.Report(100, "Report ready!")

        // Return result with download URL
        return &amp;streamer.Result{
                RequestID: req.ID,
                Success:   true,
                Data: map[string]interface{}{
                        "url":          reportURL,
                        "records":      processedData.RecordCount,
                        "size_bytes":   reportInfo.SizeBytes,
                        "format":       params.Format,
                        "generated_at": time.Now().Format(time.RFC3339),
                        "expires_at":   time.Now().Add(7 * 24 * time.Hour).Format(time.RFC3339),
                        "stats":        processedData.Stats,
                },
                Metadata: map[string]string{
                        "report_type": params.ReportType,
                        "start_date":  params.StartDate,
                        "end_date":    params.EndDate,
                },
        }, nil</span>
}

// queryData simulates data querying with detailed progress
func (h *ReportAsyncHandler) queryData(ctx context.Context, params ReportParams, reporter streamer.ProgressReporter) (*QueryResult, error) <span class="cov1" title="1">{
        // Simulate querying from multiple data sources
        dataSources := []struct {
                name       string
                recordBase int
                delay      time.Duration
        }{
                {"transactions", 2000, 800 * time.Millisecond},
                {"customers", 500, 600 * time.Millisecond},
                {"products", 1000, 700 * time.Millisecond},
                {"analytics", 1500, 900 * time.Millisecond},
        }

        totalRecords := 0
        queryStart := time.Now()

        for i, source := range dataSources </span><span class="cov6" title="4">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-time.After(source.delay):<span class="cov6" title="4">
                        records := source.recordBase + (i * 100)
                        totalRecords += records

                        progress := float64(i+1) / float64(len(dataSources)) * 30.0
                        reporter.Report(progress, fmt.Sprintf("Queried %s: %d records", source.name, records))
                        reporter.SetMetadata(fmt.Sprintf("source_%s_records", source.name), records)</span>
                }
        }

        <span class="cov1" title="1">return &amp;QueryResult{
                TotalRecords: totalRecords,
                Sources:      len(dataSources),
                QueryTime:    time.Since(queryStart),
        }, nil</span>
}

// processData processes the queried data with batch tracking
func (h *ReportAsyncHandler) processData(ctx context.Context, queryResult *QueryResult, params ReportParams, reporter streamer.ProgressReporter) (*ProcessedData, error) <span class="cov1" title="1">{
        batchSize := 500
        totalBatches := (queryResult.TotalRecords + batchSize - 1) / batchSize

        // Initialize processing stats
        stats := &amp;ProcessingStats{
                StartTime:      time.Now(),
                TotalRecords:   queryResult.TotalRecords,
                ProcessedCount: 0,
                Categories:     make(map[string]int),
        }

        for batch := 0; batch &lt; totalBatches; batch++ </span><span class="cov10" title="12">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-time.After(300 * time.Millisecond):<span class="cov10" title="12">
                        // Simulate batch processing
                        recordsInBatch := batchSize
                        if batch == totalBatches-1 </span><span class="cov1" title="1">{
                                // Last batch might be smaller
                                recordsInBatch = queryResult.TotalRecords - (batch * batchSize)
                        }</span>

                        <span class="cov10" title="12">stats.ProcessedCount += recordsInBatch

                        // Simulate categorization
                        categories := []string{"Electronics", "Clothing", "Books", "Home", "Sports"}
                        category := categories[batch%len(categories)]
                        stats.Categories[category] += recordsInBatch

                        progress := 30 + (float64(batch+1)/float64(totalBatches))*30.0
                        reporter.Report(progress, fmt.Sprintf("Processed batch %d/%d (%d records)",
                                batch+1, totalBatches, stats.ProcessedCount))</span>
                }
        }

        // Calculate final stats
        <span class="cov1" title="1">stats.EndTime = time.Now()
        stats.ProcessingDuration = stats.EndTime.Sub(stats.StartTime)

        // Simulate aggregated metrics
        return &amp;ProcessedData{
                RecordCount: stats.ProcessedCount,
                Stats: map[string]interface{}{
                        "total_value":        123456.78 * float64(stats.ProcessedCount) / 1000,
                        "average_value":      123.45,
                        "categories_count":   len(stats.Categories),
                        "top_category":       getTopCategory(stats.Categories),
                        "processing_time":    stats.ProcessingDuration.Seconds(),
                        "records_per_second": float64(stats.ProcessedCount) / stats.ProcessingDuration.Seconds(),
                },
                Categories: stats.Categories,
        }, nil</span>
}

// generateReport creates the actual report file
func (h *ReportAsyncHandler) generateReport(ctx context.Context, data *ProcessedData, params ReportParams, reporter streamer.ProgressReporter) (*ReportInfo, error) <span class="cov1" title="1">{
        // Different generation strategies based on format
        var generator ReportGenerator
        switch params.Format </span>{
        case "csv":<span class="cov1" title="1">
                generator = &amp;CSVGenerator{estimatedSize: 2 * 1024 * 1024}</span> // 2MB
        case "excel":<span class="cov0" title="0">
                generator = &amp;ExcelGenerator{estimatedSize: 5 * 1024 * 1024}</span> // 5MB
        case "pdf":<span class="cov0" title="0">
                generator = &amp;PDFGenerator{estimatedSize: 8 * 1024 * 1024}</span> // 8MB
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported format: %s", params.Format)</span>
        }

        // Generate report in stages
        <span class="cov1" title="1">stages := []struct {
                name     string
                duration time.Duration
                weight   float64
        }{
                {"headers", 500 * time.Millisecond, 0.2},
                {"data", 2 * time.Second, 0.5},
                {"formatting", 1 * time.Second, 0.2},
                {"finalization", 500 * time.Millisecond, 0.1},
        }

        var totalProgress float64 = 60.0
        for _, stage := range stages </span><span class="cov6" title="4">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-time.After(stage.duration):<span class="cov6" title="4">
                        totalProgress += stage.weight * 30.0
                        reporter.Report(totalProgress, fmt.Sprintf("Generating %s: %s", params.Format, stage.name))</span>
                }
        }

        // Create report info
        <span class="cov1" title="1">reportInfo := &amp;ReportInfo{
                ID:        fmt.Sprintf("report-%s-%d", params.ReportType, time.Now().Unix()),
                Format:    params.Format,
                SizeBytes: generator.GetEstimatedSize(),
                CreatedAt: time.Now(),
        }

        return reportInfo, nil</span>
}

// finalizeReport stores the report and generates access URL
func (h *ReportAsyncHandler) finalizeReport(ctx context.Context, info *ReportInfo, params ReportParams, reporter streamer.ProgressReporter) (string, error) <span class="cov1" title="1">{
        // Simulate upload/storage steps
        steps := []struct {
                name     string
                duration time.Duration
        }{
                {"Compressing", 600 * time.Millisecond},
                {"Encrypting", 400 * time.Millisecond},
                {"Uploading", 1 * time.Second},
                {"Generating URL", 200 * time.Millisecond},
        }

        baseProgress := 90.0
        progressPerStep := 10.0 / float64(len(steps))

        for i, step := range steps </span><span class="cov6" title="4">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return "", ctx.Err()</span>
                case &lt;-time.After(step.duration):<span class="cov6" title="4">
                        progress := baseProgress + (float64(i+1) * progressPerStep)
                        reporter.Report(progress, step.name+"...")</span>
                }
        }

        // Generate mock presigned URL
        // In production, this would be an actual S3 presigned URL or similar
        <span class="cov1" title="1">reportURL := fmt.Sprintf("https://reports.example.com/download/%s?token=%s&amp;expires=%d",
                info.ID,
                generateToken(),
                time.Now().Add(7*24*time.Hour).Unix(),
        )

        return reportURL, nil</span>
}

// Helper functions and types

type ReportParams struct {
        StartDate     string                 `json:"start_date"`
        EndDate       string                 `json:"end_date"`
        Format        string                 `json:"format"`      // pdf, csv, excel
        ReportType    string                 `json:"report_type"` // monthly, quarterly, annual, custom
        IncludeCharts bool                   `json:"include_charts"`
        Filters       map[string]interface{} `json:"filters,omitempty"`
}

type QueryResult struct {
        TotalRecords int
        Sources      int
        QueryTime    time.Duration
}

type ProcessedData struct {
        RecordCount int
        Stats       map[string]interface{}
        Categories  map[string]int
}

type ProcessingStats struct {
        StartTime          time.Time
        EndTime            time.Time
        ProcessingDuration time.Duration
        TotalRecords       int
        ProcessedCount     int
        Categories         map[string]int
}

type ReportInfo struct {
        ID        string
        Format    string
        SizeBytes int
        CreatedAt time.Time
}

// Report generators (interfaces for different formats)
type ReportGenerator interface {
        GetEstimatedSize() int
}

type CSVGenerator struct {
        estimatedSize int
}

func (g *CSVGenerator) GetEstimatedSize() int <span class="cov1" title="1">{
        return g.estimatedSize
}</span>

type ExcelGenerator struct {
        estimatedSize int
}

func (g *ExcelGenerator) GetEstimatedSize() int <span class="cov0" title="0">{
        return g.estimatedSize
}</span>

type PDFGenerator struct {
        estimatedSize int
}

func (g *PDFGenerator) GetEstimatedSize() int <span class="cov0" title="0">{
        return g.estimatedSize
}</span>

// Utility functions
func getTopCategory(categories map[string]int) string <span class="cov1" title="1">{
        var topCategory string
        var maxCount int

        for category, count := range categories </span><span class="cov6" title="5">{
                if count &gt; maxCount </span><span class="cov1" title="1">{
                        maxCount = count
                        topCategory = category
                }</span>
        }

        <span class="cov1" title="1">return topCategory</span>
}

func generateToken() string <span class="cov1" title="1">{
        // Simple mock token generation
        return fmt.Sprintf("%d-%d", time.Now().Unix(), time.Now().Nanosecond())
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/aws/aws-lambda-go/events"
        "github.com/aws/aws-lambda-go/lambda"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/apigatewaymanagementapi"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"

        "github.com/pay-theory/streamer/internal/store"
        "github.com/pay-theory/streamer/lambda/processor/executor"
        "github.com/pay-theory/streamer/lambda/processor/handlers"
        "github.com/pay-theory/streamer/pkg/connection"
        "github.com/pay-theory/streamer/pkg/streamer"
)

var (
        exec             *executor.AsyncExecutor
        logger           *log.Logger
        connectionsTable string
        requestsTable    string
)

func init() <span class="cov0" title="0">{
        logger = log.New(os.Stdout, "[PROCESSOR] ", log.LstdFlags|log.Lshortfile)

        // Get table names from environment
        connectionsTable = os.Getenv("CONNECTIONS_TABLE")
        if connectionsTable == "" </span><span class="cov0" title="0">{
                connectionsTable = "streamer_connections"
        }</span>

        <span class="cov0" title="0">requestsTable = os.Getenv("REQUESTS_TABLE")
        if requestsTable == "" </span><span class="cov0" title="0">{
                requestsTable = "streamer_requests"
        }</span>

        // Initialize AWS config
        <span class="cov0" title="0">ctx := context.Background()
        cfg, err := config.LoadDefaultConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to load AWS config: %v", err)
        }</span>

        // Initialize DynamoDB client
        <span class="cov0" title="0">dynamoClient := dynamodb.NewFromConfig(cfg)

        // Initialize storage components
        requestQueue := store.NewRequestQueue(dynamoClient, requestsTable)
        connectionStore := store.NewConnectionStore(dynamoClient, connectionsTable)

        // Initialize API Gateway Management API client
        apiGatewayEndpoint := os.Getenv("WEBSOCKET_ENDPOINT")
        if apiGatewayEndpoint == "" </span><span class="cov0" title="0">{
                logger.Fatal("WEBSOCKET_ENDPOINT environment variable is required")
        }</span>

        <span class="cov0" title="0">apiGatewayClient := apigatewaymanagementapi.NewFromConfig(cfg, func(o *apigatewaymanagementapi.Options) </span><span class="cov0" title="0">{
                o.BaseEndpoint = &amp;apiGatewayEndpoint
        }</span>)

        // Wrap the AWS SDK client with the adapter
        <span class="cov0" title="0">apiGatewayAdapter := connection.NewAWSAPIGatewayAdapter(apiGatewayClient)

        // Create real ConnectionManager from Team 1
        connManager := connection.NewManager(connectionStore, apiGatewayAdapter, apiGatewayEndpoint)
        connManager.SetLogger(logger.Printf)

        // Create executor
        exec = executor.New(connManager, requestQueue, logger)

        // Register async handlers
        if err := registerAsyncHandlers(exec); err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to register handlers: %v", err)
        }</span>

        <span class="cov0" title="0">logger.Println("Processor Lambda initialized successfully")</span>
}

func handler(ctx context.Context, event events.DynamoDBEvent) error <span class="cov0" title="0">{
        logger.Printf("Processing %d stream records", len(event.Records))

        for _, record := range event.Records </span><span class="cov0" title="0">{
                // Only process INSERT and MODIFY events for async requests
                if record.EventName != "INSERT" &amp;&amp; record.EventName != "MODIFY" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse the AsyncRequest from DynamoDB stream
                <span class="cov0" title="0">asyncReq, err := parseAsyncRequest(record)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Failed to parse AsyncRequest: %v", err)
                        continue</span>
                }

                // Skip if not in PENDING status
                <span class="cov0" title="0">if asyncReq.Status != store.StatusPending </span><span class="cov0" title="0">{
                        logger.Printf("Skipping request %s with status %s", asyncReq.RequestID, asyncReq.Status)
                        continue</span>
                }

                // Create context with timeout (Lambda max is 15 minutes, leave 1 minute buffer)
                <span class="cov0" title="0">processCtx, cancel := context.WithTimeout(ctx, 14*time.Minute)

                // Process the request with retry logic
                err = exec.ProcessWithRetry(processCtx, asyncReq)

                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Failed to process request %s: %v", asyncReq.RequestID, err)
                        // The error is logged but we don't return it to avoid reprocessing
                        // The request will be marked as failed in the ProcessWithRetry function
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// parseAsyncRequest converts a DynamoDB stream record to an AsyncRequest
func parseAsyncRequest(record events.DynamoDBEventRecord) (*store.AsyncRequest, error) <span class="cov0" title="0">{
        // For INSERT events, use NewImage; for MODIFY events, use NewImage as well
        image := record.Change.NewImage
        if image == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Convert DynamoDB event attribute values to a regular map
        // This is necessary because Lambda events use a different type than SDK v2
        <span class="cov0" title="0">imageMap := make(map[string]interface{})
        for k, v := range image </span><span class="cov0" title="0">{
                var val interface{}
                jsonBytes, err := v.MarshalJSON()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Failed to marshal attribute %s: %v", k, err)
                        continue</span>
                }
                <span class="cov0" title="0">if err := json.Unmarshal(jsonBytes, &amp;val); err != nil </span><span class="cov0" title="0">{
                        logger.Printf("Failed to unmarshal attribute %s: %v", k, err)
                        continue</span>
                }
                <span class="cov0" title="0">imageMap[k] = val</span>
        }

        // Now convert to AsyncRequest struct
        <span class="cov0" title="0">jsonBytes, err := json.Marshal(imageMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal image map: %w", err)
        }</span>

        <span class="cov0" title="0">var asyncReq store.AsyncRequest
        if err := json.Unmarshal(jsonBytes, &amp;asyncReq); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal AsyncRequest: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;asyncReq, nil</span>
}

func registerAsyncHandlers(exec *executor.AsyncExecutor) error <span class="cov0" title="0">{
        // Register handlers from the router package
        exec.RegisterHandler("delay", streamer.NewDelayHandler(30*time.Second))

        // Register production async handlers from handlers package
        exec.RegisterHandler("generate_report", handlers.NewReportAsyncHandler())
        exec.RegisterHandler("process_data", handlers.NewDataProcessorHandler())
        exec.RegisterHandler("bulk_operation", NewBulkHandlerWithProgress()) // Keep existing for now
        exec.RegisterHandler("echo_async", handlers.NewEchoAsyncHandler())   // Simple test handler

        logger.Printf("Registered %d async handlers", 5)
        return nil
}</span>

func main() <span class="cov0" title="0">{
        lambda.Start(handler)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package main

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "github.com/pay-theory/streamer/pkg/streamer"
)

// registerHandlers registers all production handlers
func registerHandlers(router *streamer.DefaultRouter) error <span class="cov8" title="6">{
        // Register simple handlers
        if err := router.Handle("echo", streamer.NewEchoHandler()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register echo handler: %w", err)
        }</span>

        <span class="cov8" title="6">if err := router.Handle("health", NewHealthHandler()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register health handler: %w", err)
        }</span>

        // Register async handlers
        <span class="cov8" title="6">if err := router.Handle("generate_report", NewReportHandler()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register report handler: %w", err)
        }</span>

        <span class="cov8" title="6">if err := router.Handle("process_data", NewDataProcessingHandler()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register data processing handler: %w", err)
        }</span>

        <span class="cov8" title="6">if err := router.Handle("bulk_operation", NewBulkHandler()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register bulk handler: %w", err)
        }</span>

        <span class="cov8" title="6">logger.Printf("Registered %d handlers", 5)
        return nil</span>
}

// HealthHandler returns system health status
type HealthHandler struct {
        estimatedDuration time.Duration
}

func NewHealthHandler() *HealthHandler <span class="cov8" title="7">{
        return &amp;HealthHandler{
                estimatedDuration: 10 * time.Millisecond,
        }
}</span>

func (h *HealthHandler) EstimatedDuration() time.Duration <span class="cov3" title="2">{
        return h.estimatedDuration
}</span>

func (h *HealthHandler) Validate(req *streamer.Request) error <span class="cov3" title="2">{
        return nil // No validation needed for health check
}</span>

func (h *HealthHandler) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov3" title="2">{
        return &amp;streamer.Result{
                RequestID: req.ID,
                Success:   true,
                Data: map[string]interface{}{
                        "status":    "healthy",
                        "timestamp": time.Now().Unix(),
                        "version":   "1.0.0",
                },
        }, nil
}</span>

// ReportHandler generates reports (async)
type ReportHandler struct {
        estimatedDuration time.Duration
}

// ReportParams defines the structure for report generation requests
type ReportParams struct {
        StartDate     time.Time `json:"start_date"`
        EndDate       time.Time `json:"end_date"`
        Format        string    `json:"format"` // pdf, csv, excel
        IncludeCharts bool      `json:"include_charts"`
        ReportType    string    `json:"report_type"` // monthly, quarterly, annual
}

func NewReportHandler() *ReportHandler <span class="cov9" title="8">{
        return &amp;ReportHandler{
                estimatedDuration: 2 * time.Minute, // Async processing
        }
}</span>

func (h *ReportHandler) EstimatedDuration() time.Duration <span class="cov1" title="1">{
        return h.estimatedDuration
}</span>

func (h *ReportHandler) Validate(req *streamer.Request) error <span class="cov9" title="8">{
        if req.Payload == nil </span><span class="cov3" title="2">{
                return errors.New("payload is required")
        }</span>

        <span class="cov8" title="6">var params ReportParams
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid payload format: %w", err)
        }</span>

        // Validate dates
        <span class="cov7" title="5">if params.StartDate.IsZero() || params.EndDate.IsZero() </span><span class="cov3" title="2">{
                return errors.New("start_date and end_date are required")
        }</span>

        <span class="cov5" title="3">if params.StartDate.After(params.EndDate) </span><span class="cov1" title="1">{
                return errors.New("start_date must be before end_date")
        }</span>

        // Validate format
        <span class="cov3" title="2">validFormats := map[string]bool{"pdf": true, "csv": true, "excel": true}
        if !validFormats[params.Format] </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid format: %s (must be pdf, csv, or excel)", params.Format)
        }</span>

        // Validate report type
        <span class="cov3" title="2">validTypes := map[string]bool{"monthly": true, "quarterly": true, "annual": true}
        if !validTypes[params.ReportType] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid report_type: %s", params.ReportType)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (h *ReportHandler) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov1" title="1">{
        // This will be called by async processor, not here
        return nil, errors.New("use ProcessWithProgress for async handlers")
}</span>

// ProcessWithProgress implements async processing with progress updates
func (h *ReportHandler) ProcessWithProgress(
        ctx context.Context,
        req *streamer.Request,
        reporter streamer.ProgressReporter,
) (*streamer.Result, error) <span class="cov0" title="0">{
        // This will be implemented in the async processor
        // For now, return a placeholder
        return nil, errors.New("async processing not yet implemented")
}</span>

// DataProcessingHandler processes large data sets (async)
type DataProcessingHandler struct {
        estimatedDuration time.Duration
}

type DataProcessingParams struct {
        DatasetID    string   `json:"dataset_id"`
        Operations   []string `json:"operations"`    // filter, transform, aggregate
        OutputFormat string   `json:"output_format"` // json, parquet, csv
}

func NewDataProcessingHandler() *DataProcessingHandler <span class="cov8" title="7">{
        return &amp;DataProcessingHandler{
                estimatedDuration: 5 * time.Minute, // Async processing
        }
}</span>

func (h *DataProcessingHandler) EstimatedDuration() time.Duration <span class="cov1" title="1">{
        return h.estimatedDuration
}</span>

func (h *DataProcessingHandler) Validate(req *streamer.Request) error <span class="cov9" title="8">{
        if req.Payload == nil </span><span class="cov3" title="2">{
                return errors.New("payload is required")
        }</span>

        <span class="cov8" title="6">var params DataProcessingParams
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid payload format: %w", err)
        }</span>

        <span class="cov7" title="5">if params.DatasetID == "" </span><span class="cov1" title="1">{
                return errors.New("dataset_id is required")
        }</span>

        <span class="cov6" title="4">if len(params.Operations) == 0 </span><span class="cov1" title="1">{
                return errors.New("at least one operation is required")
        }</span>

        // Validate operations
        <span class="cov5" title="3">validOps := map[string]bool{
                "filter": true, "transform": true, "aggregate": true,
                "sort": true, "deduplicate": true,
        }
        for _, op := range params.Operations </span><span class="cov7" title="5">{
                if !validOps[op] </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid operation: %s", op)
                }</span>
        }

        // Validate output format
        <span class="cov3" title="2">validFormats := map[string]bool{"json": true, "parquet": true, "csv": true}
        if !validFormats[params.OutputFormat] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid output_format: %s", params.OutputFormat)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (h *DataProcessingHandler) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov8" title="7">{
        return nil, errors.New("use ProcessWithProgress for async handlers")
}</span>

// BulkHandler handles bulk operations (async)
type BulkHandler struct {
        estimatedDuration time.Duration
}

type BulkOperationParams struct {
        OperationType string                   `json:"operation_type"` // create, update, delete
        EntityType    string                   `json:"entity_type"`    // user, product, order
        Items         []map[string]interface{} `json:"items"`
        BatchSize     int                      `json:"batch_size"`
}

func NewBulkHandler() *BulkHandler <span class="cov8" title="7">{
        return &amp;BulkHandler{
                estimatedDuration: 10 * time.Minute, // Async processing
        }
}</span>

func (h *BulkHandler) EstimatedDuration() time.Duration <span class="cov1" title="1">{
        return h.estimatedDuration
}</span>

func (h *BulkHandler) Validate(req *streamer.Request) error <span class="cov10" title="10">{
        if req.Payload == nil </span><span class="cov3" title="2">{
                return errors.New("payload is required")
        }</span>

        <span class="cov9" title="8">var params BulkOperationParams
        if err := json.Unmarshal(req.Payload, &amp;params); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid payload format: %w", err)
        }</span>

        // Validate operation type
        <span class="cov8" title="7">validOps := map[string]bool{"create": true, "update": true, "delete": true}
        if !validOps[params.OperationType] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid operation_type: %s", params.OperationType)
        }</span>

        // Validate entity type
        <span class="cov8" title="6">validEntities := map[string]bool{"user": true, "product": true, "order": true}
        if !validEntities[params.EntityType] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid entity_type: %s", params.EntityType)
        }</span>

        // Validate items
        <span class="cov7" title="5">if len(params.Items) == 0 </span><span class="cov1" title="1">{
                return errors.New("items cannot be empty")
        }</span>

        <span class="cov6" title="4">if len(params.Items) &gt; 10000 </span><span class="cov1" title="1">{
                return errors.New("too many items (max 10000)")
        }</span>

        // Validate batch size
        <span class="cov5" title="3">if params.BatchSize &lt;= 0 </span><span class="cov1" title="1">{
                params.BatchSize = 25 // Default
        }</span> else<span class="cov3" title="2"> if params.BatchSize &gt; 100 </span><span class="cov1" title="1">{
                return errors.New("batch_size too large (max 100)")
        }</span>

        <span class="cov3" title="2">return nil</span>
}

func (h *BulkHandler) Process(ctx context.Context, req *streamer.Request) (*streamer.Result, error) <span class="cov9" title="9">{
        return nil, errors.New("use ProcessWithProgress for async handlers")
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package main

import (
        "context"
        "log"
        "os"
        "time"

        "github.com/aws/aws-lambda-go/events"
        "github.com/aws/aws-lambda-go/lambda"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/apigatewaymanagementapi"

        "github.com/pay-theory/dynamorm/pkg/session"
        dynamormStore "github.com/pay-theory/streamer/internal/store/dynamorm"
        "github.com/pay-theory/streamer/pkg/connection"
        "github.com/pay-theory/streamer/pkg/streamer"
)

var (
        router             *streamer.DefaultRouter
        logger             *log.Logger
        connectionsTable   string
        requestsTable      string
        subscriptionsTable string
)

func init() <span class="cov1" title="1">{
        logger = log.New(os.Stdout, "[ROUTER] ", log.LstdFlags|log.Lshortfile)

        // Skip initialization if running tests (TestMain will handle setup)
        if isRunningTests() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get table names from environment
        <span class="cov1" title="1">connectionsTable = os.Getenv("CONNECTIONS_TABLE")
        if connectionsTable == "" </span><span class="cov1" title="1">{
                connectionsTable = "streamer_connections"
        }</span>

        <span class="cov1" title="1">requestsTable = os.Getenv("REQUESTS_TABLE")
        if requestsTable == "" </span><span class="cov1" title="1">{
                requestsTable = "streamer_requests"
        }</span>

        <span class="cov1" title="1">subscriptionsTable = os.Getenv("SUBSCRIPTIONS_TABLE")
        if subscriptionsTable == "" </span><span class="cov1" title="1">{
                subscriptionsTable = "streamer_subscriptions"
        }</span>

        // Initialize AWS config
        <span class="cov1" title="1">ctx := context.Background()
        cfg, err := config.LoadDefaultConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to load AWS config: %v", err)
        }</span>

        // Initialize DynamORM
        <span class="cov1" title="1">dynamormConfig := session.Config{
                Region: cfg.Region,
        }

        factory, err := dynamormStore.NewStoreFactory(dynamormConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to create DynamORM factory: %v", err)
        }</span>

        // Get stores from factory
        <span class="cov1" title="1">connStore := factory.ConnectionStore()
        reqQueue := factory.RequestQueue() // Note: This needs to be implemented in DynamORM

        // Create adapter
        queueAdapter := streamer.NewRequestQueueAdapter(reqQueue)

        // Initialize API Gateway Management API client
        apiGatewayEndpoint := os.Getenv("WEBSOCKET_ENDPOINT")
        if apiGatewayEndpoint == "" </span><span class="cov1" title="1">{
                logger.Println("WARNING: WEBSOCKET_ENDPOINT environment variable is not set")
                return
        }</span>

        <span class="cov0" title="0">apiGatewayClient := apigatewaymanagementapi.NewFromConfig(cfg, func(o *apigatewaymanagementapi.Options) </span><span class="cov0" title="0">{
                o.BaseEndpoint = &amp;apiGatewayEndpoint
        }</span>)

        // Wrap the AWS SDK client with the adapter
        <span class="cov0" title="0">apiGatewayAdapter := connection.NewAWSAPIGatewayAdapter(apiGatewayClient)

        // Create real ConnectionManager from Team 1
        connManager := connection.NewManager(connStore, apiGatewayAdapter, apiGatewayEndpoint)
        connManager.SetLogger(logger.Printf)

        // Create router
        router = streamer.NewRouter(queueAdapter, connManager)
        router.SetAsyncThreshold(5 * time.Second)

        // Apply middleware
        router.SetMiddleware(
                streamer.LoggingMiddleware(logger.Printf),
                validationMiddleware(),
                metricsMiddleware(),
        )

        // Register handlers
        if err := registerHandlers(router); err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to register handlers: %v", err)
        }</span>

        <span class="cov0" title="0">logger.Println("Router Lambda initialized successfully")</span>
}

// isRunningTests checks if we're running under go test
func isRunningTests() bool <span class="cov1" title="1">{
        for _, arg := range os.Args </span><span class="cov10" title="5">{
                if arg == "-test.v" || arg == "-test.run" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// handler processes incoming WebSocket messages
func handler(ctx context.Context, event events.APIGatewayWebsocketProxyRequest) (events.APIGatewayProxyResponse, error) <span class="cov7" title="3">{
        logger.Printf("Processing request from connection: %s, route: %s",
                event.RequestContext.ConnectionID,
                event.RequestContext.RouteKey)

        // Add request metadata
        if event.RequestContext.Authorizer != nil </span><span class="cov1" title="1">{
                // Extract user/tenant info from authorizer if available
                if authData, ok := event.RequestContext.Authorizer.(map[string]interface{}); ok </span><span class="cov1" title="1">{
                        if userID, ok := authData["userId"].(string); ok </span><span class="cov1" title="1">{
                                ctx = context.WithValue(ctx, "userId", userID)
                        }</span>
                        <span class="cov1" title="1">if tenantID, ok := authData["tenantId"].(string); ok </span><span class="cov1" title="1">{
                                ctx = context.WithValue(ctx, "tenantId", tenantID)
                        }</span>
                }
        }

        // Route the request
        <span class="cov7" title="3">err := router.Route(ctx, event)
        if err != nil </span><span class="cov1" title="1">{
                logger.Printf("Error routing request: %v", err)
                return events.APIGatewayProxyResponse{
                        StatusCode: 500,
                        Body:       "Internal Server Error",
                }, nil
        }</span>

        <span class="cov4" title="2">return events.APIGatewayProxyResponse{
                StatusCode: 200,
        }, nil</span>
}

// validationMiddleware adds request validation
func validationMiddleware() streamer.Middleware <span class="cov1" title="1">{
        return func(next streamer.Handler) streamer.Handler </span><span class="cov1" title="1">{
                return streamer.NewHandlerFunc(
                        func(ctx context.Context, req *streamer.Request) (*streamer.Result, error) </span><span class="cov4" title="2">{
                                // Add user/tenant IDs from context to request metadata
                                if userID, ok := ctx.Value("userId").(string); ok </span><span class="cov1" title="1">{
                                        req.Metadata["user_id"] = userID
                                }</span>
                                <span class="cov4" title="2">if tenantID, ok := ctx.Value("tenantId").(string); ok </span><span class="cov1" title="1">{
                                        req.Metadata["tenant_id"] = tenantID
                                }</span>

                                // Validate request size
                                <span class="cov4" title="2">if len(req.Payload) &gt; 1024*1024 </span><span class="cov1" title="1">{ // 1MB limit
                                        return nil, streamer.NewError(streamer.ErrCodeValidation, "Payload too large (max 1MB)")
                                }</span>

                                <span class="cov1" title="1">return next.Process(ctx, req)</span>
                        },
                        next.EstimatedDuration(),
                        next.Validate,
                )
        }
}

// metricsMiddleware adds basic metrics logging
func metricsMiddleware() streamer.Middleware <span class="cov1" title="1">{
        return func(next streamer.Handler) streamer.Handler </span><span class="cov1" title="1">{
                return streamer.NewHandlerFunc(
                        func(ctx context.Context, req *streamer.Request) (*streamer.Result, error) </span><span class="cov1" title="1">{
                                start := time.Now()

                                result, err := next.Process(ctx, req)

                                duration := time.Since(start)
                                status := "success"
                                if err != nil </span><span class="cov0" title="0">{
                                        status = "error"
                                }</span>

                                <span class="cov1" title="1">logger.Printf("METRICS: action=%s, duration=%v, status=%s",
                                        req.Action, duration, status)

                                return result, err</span>
                        },
                        next.EstimatedDuration(),
                        next.Validate,
                )
        }
}

func main() <span class="cov0" title="0">{
        lambda.Start(handler)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package shared

import (
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// JWTClaims represents the expected JWT claims
type JWTClaims struct {
        UserID      string   `json:"user_id"`
        TenantID    string   `json:"tenant_id"`
        Permissions []string `json:"permissions,omitempty"`
        jwt.RegisteredClaims
}

// ValidateJWT validates a JWT token and returns the claims
func ValidateJWT(tokenString, secret string) (map[string]interface{}, error) <span class="cov10" title="19">{
        // Remove Bearer prefix if present
        tokenString = strings.TrimPrefix(tokenString, "Bearer ")
        tokenString = strings.TrimSpace(tokenString)

        // Parse the token
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov9" title="16">{
                // Validate the signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov9" title="15">return []byte(secret), nil</span>
        })

        <span class="cov10" title="19">if err != nil </span><span class="cov6" title="6">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        // Check if token is valid
        <span class="cov8" title="13">if !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token")
        }</span>

        // Extract claims
        <span class="cov8" title="13">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token claims")
        }</span>

        // Validate expiration
        <span class="cov8" title="13">if exp, ok := claims["exp"].(float64); ok </span><span class="cov8" title="12">{
                if time.Now().Unix() &gt; int64(exp) </span><span class="cov0" title="0">{
                        return nil, errors.New("token expired")
                }</span>
        } else<span class="cov1" title="1"> {
                return nil, errors.New("missing expiration claim")
        }</span>

        // Validate required fields
        <span class="cov8" title="12">if _, ok := claims["user_id"].(string); !ok </span><span class="cov1" title="1">{
                return nil, errors.New("missing user_id claim")
        }</span>

        <span class="cov8" title="11">if _, ok := claims["tenant_id"].(string); !ok </span><span class="cov1" title="1">{
                return nil, errors.New("missing tenant_id claim")
        }</span>

        <span class="cov8" title="10">return claims, nil</span>
}

// GenerateJWT generates a JWT token for testing
func GenerateJWT(userID, tenantID string, permissions []string, secret string, duration time.Duration) (string, error) <span class="cov8" title="12">{
        claims := JWTClaims{
                UserID:      userID,
                TenantID:    tenantID,
                Permissions: permissions,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(duration)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(secret))
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package shared

import (
        "context"
        "encoding/json"
        "log"
        "os"
        "time"

        "github.com/aws/aws-lambda-go/lambdacontext"
)

// StructuredLog represents a structured log entry
type StructuredLog struct {
        Level         string                 `json:"level"`
        Message       string                 `json:"message"`
        RequestID     string                 `json:"request_id,omitempty"`
        CorrelationID string                 `json:"correlation_id,omitempty"`
        Timestamp     int64                  `json:"timestamp"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// LogLevel constants
const (
        LogLevelDebug = "DEBUG"
        LogLevelInfo  = "INFO"
        LogLevelWarn  = "WARN"
        LogLevelError = "ERROR"
)

// Logger provides structured logging
type Logger struct {
        serviceName string
}

// NewLogger creates a new structured logger
func NewLogger(serviceName string) *Logger <span class="cov6" title="6">{
        return &amp;Logger{
                serviceName: serviceName,
        }
}</span>

// extractRequestID gets the Lambda request ID from context
func extractRequestID(ctx context.Context) string <span class="cov9" title="15">{
        lc, ok := lambdacontext.FromContext(ctx)
        if ok </span><span class="cov3" title="2">{
                return lc.AwsRequestID
        }</span>
        <span class="cov9" title="13">return ""</span>
}

// Log writes a structured log entry
func (l *Logger) Log(ctx context.Context, level, message string, metadata map[string]interface{}) <span class="cov9" title="13">{
        entry := StructuredLog{
                Level:     level,
                Message:   message,
                RequestID: extractRequestID(ctx),
                Timestamp: getTimestamp(),
                Metadata:  metadata,
        }

        if l.serviceName != "" </span><span class="cov9" title="12">{
                if entry.Metadata == nil </span><span class="cov5" title="4">{
                        entry.Metadata = make(map[string]interface{})
                }</span>
                <span class="cov9" title="12">entry.Metadata["service"] = l.serviceName</span>
        }

        // Add correlation ID if present in context
        <span class="cov9" title="13">if correlationID := ctx.Value("correlation_id"); correlationID != nil </span><span class="cov4" title="3">{
                if id, ok := correlationID.(string); ok </span><span class="cov3" title="2">{
                        entry.CorrelationID = id
                }</span>
        }

        // Output as JSON
        <span class="cov9" title="13">data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to marshal log entry: %v", err)
                return
        }</span>

        // Write to stdout (CloudWatch will capture this)
        <span class="cov9" title="13">os.Stdout.Write(data)
        os.Stdout.Write([]byte("\n"))</span>
}

// Debug logs a debug message
func (l *Logger) Debug(ctx context.Context, message string, metadata map[string]interface{}) <span class="cov1" title="1">{
        l.Log(ctx, LogLevelDebug, message, metadata)
}</span>

// Info logs an info message
func (l *Logger) Info(ctx context.Context, message string, metadata map[string]interface{}) <span class="cov6" title="6">{
        l.Log(ctx, LogLevelInfo, message, metadata)
}</span>

// Warn logs a warning message
func (l *Logger) Warn(ctx context.Context, message string, metadata map[string]interface{}) <span class="cov1" title="1">{
        l.Log(ctx, LogLevelWarn, message, metadata)
}</span>

// Error logs an error message
func (l *Logger) Error(ctx context.Context, message string, metadata map[string]interface{}) <span class="cov1" title="1">{
        l.Log(ctx, LogLevelError, message, metadata)
}</span>

// LogMetric logs a metric event (for CloudWatch Metrics)
func LogMetric(ctx context.Context, metricName string, metadata map[string]interface{}) <span class="cov3" title="2">{
        // CloudWatch Embedded Metric Format
        emf := map[string]interface{}{
                "_aws": map[string]interface{}{
                        "Timestamp": getTimestamp(),
                        "CloudWatchMetrics": []map[string]interface{}{
                                {
                                        "Namespace":  "Streamer",
                                        "Dimensions": [][]string{{"Service"}},
                                        "Metrics": []map[string]interface{}{
                                                {
                                                        "Name": metricName,
                                                        "Unit": "Count",
                                                },
                                        },
                                },
                        },
                },
                "Service":  os.Getenv("SERVICE_NAME"),
                metricName: 1,
        }

        // Add metadata
        for k, v := range metadata </span><span class="cov3" title="2">{
                emf[k] = v
        }</span>

        // Output EMF
        <span class="cov3" title="2">data, err := json.Marshal(emf)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to marshal EMF: %v", err)
                return
        }</span>

        <span class="cov3" title="2">os.Stdout.Write(data)
        os.Stdout.Write([]byte("\n"))</span>
}

// getTimestamp returns current Unix timestamp in milliseconds
func getTimestamp() int64 <span class="cov10" title="16">{
        return time.Now().UnixNano() / 1e6
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package shared

import (
        "context"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/cloudwatch"
        "github.com/aws/aws-sdk-go-v2/service/cloudwatch/types"
)

// MetricsPublisher defines the CloudWatch metrics interface
type MetricsPublisher interface {
        PublishMetric(ctx context.Context, namespace, metricName string, value float64, unit types.StandardUnit, dimensions ...types.Dimension) error
        PublishLatency(ctx context.Context, namespace, metricName string, duration time.Duration, dimensions ...types.Dimension) error
}

// CloudWatchMetrics implements MetricsPublisher using CloudWatch
type CloudWatchMetrics struct {
        client    *cloudwatch.Client
        namespace string
}

// NewCloudWatchMetrics creates a new CloudWatch metrics client
func NewCloudWatchMetrics(cfg aws.Config, namespace string) *CloudWatchMetrics <span class="cov0" title="0">{
        return &amp;CloudWatchMetrics{
                client:    cloudwatch.NewFromConfig(cfg),
                namespace: namespace,
        }
}</span>

// PublishMetric publishes a single metric to CloudWatch
func (c *CloudWatchMetrics) PublishMetric(ctx context.Context, namespace, metricName string, value float64, unit types.StandardUnit, dimensions ...types.Dimension) error <span class="cov0" title="0">{
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = c.namespace
        }</span>

        <span class="cov0" title="0">input := &amp;cloudwatch.PutMetricDataInput{
                Namespace: aws.String(namespace),
                MetricData: []types.MetricDatum{
                        {
                                MetricName: aws.String(metricName),
                                Value:      aws.Float64(value),
                                Unit:       unit,
                                Timestamp:  aws.Time(time.Now()),
                                Dimensions: dimensions,
                        },
                },
        }

        _, err := c.client.PutMetricData(ctx, input)
        return err</span>
}

// PublishLatency publishes a latency metric in milliseconds
func (c *CloudWatchMetrics) PublishLatency(ctx context.Context, namespace, metricName string, duration time.Duration, dimensions ...types.Dimension) error <span class="cov0" title="0">{
        return c.PublishMetric(ctx, namespace, metricName, float64(duration.Milliseconds()), types.StandardUnitMilliseconds, dimensions...)
}</span>

// MetricsDimensions provides common dimension builders
type MetricsDimensions struct{}

// Function returns a dimension for Lambda function name
func (MetricsDimensions) Function(name string) types.Dimension <span class="cov1" title="1">{
        return types.Dimension{
                Name:  aws.String("FunctionName"),
                Value: aws.String(name),
        }
}</span>

// Environment returns a dimension for environment
func (MetricsDimensions) Environment(env string) types.Dimension <span class="cov10" title="5">{
        return types.Dimension{
                Name:  aws.String("Environment"),
                Value: aws.String(env),
        }
}</span>

// Action returns a dimension for action type
func (MetricsDimensions) Action(action string) types.Dimension <span class="cov8" title="4">{
        return types.Dimension{
                Name:  aws.String("Action"),
                Value: aws.String(action),
        }
}</span>

// ErrorType returns a dimension for error type
func (MetricsDimensions) ErrorType(errType string) types.Dimension <span class="cov7" title="3">{
        return types.Dimension{
                Name:  aws.String("ErrorType"),
                Value: aws.String(errType),
        }
}</span>

// TenantID returns a dimension for tenant
func (MetricsDimensions) TenantID(tenantID string) types.Dimension <span class="cov4" title="2">{
        return types.Dimension{
                Name:  aws.String("TenantID"),
                Value: aws.String(tenantID),
        }
}</span>

// CommonMetrics provides metric name constants
var CommonMetrics = struct {
        ConnectionEstablished string
        ConnectionClosed      string
        MessageSent           string
        MessageFailed         string
        AuthenticationFailed  string
        ConnectionDuration    string
        MessageSize           string
        ProcessingLatency     string
}{
        ConnectionEstablished: "ConnectionEstablished",
        ConnectionClosed:      "ConnectionClosed",
        MessageSent:           "MessageSent",
        MessageFailed:         "MessageFailed",
        AuthenticationFailed:  "AuthenticationFailed",
        ConnectionDuration:    "ConnectionDuration",
        MessageSize:           "MessageSize",
        ProcessingLatency:     "ProcessingLatency",
}

// CloudWatchAlarmConfig represents alarm configuration
type CloudWatchAlarmConfig struct {
        AlarmName          string
        MetricName         string
        Namespace          string
        Statistic          types.Statistic
        Period             int32
        EvaluationPeriods  int32
        Threshold          float64
        ComparisonOperator types.ComparisonOperator
        AlarmDescription   string
        Dimensions         []types.Dimension
        SNSTopic           string
}

// CreateAlarm creates a CloudWatch alarm
func CreateAlarm(ctx context.Context, cwClient *cloudwatch.Client, config CloudWatchAlarmConfig) error <span class="cov0" title="0">{
        input := &amp;cloudwatch.PutMetricAlarmInput{
                AlarmName:          aws.String(config.AlarmName),
                MetricName:         aws.String(config.MetricName),
                Namespace:          aws.String(config.Namespace),
                Statistic:          config.Statistic,
                Period:             aws.Int32(config.Period),
                EvaluationPeriods:  aws.Int32(config.EvaluationPeriods),
                Threshold:          aws.Float64(config.Threshold),
                ComparisonOperator: config.ComparisonOperator,
                AlarmDescription:   aws.String(config.AlarmDescription),
                Dimensions:         config.Dimensions,
                ActionsEnabled:     aws.Bool(true),
        }

        if config.SNSTopic != "" </span><span class="cov0" title="0">{
                input.AlarmActions = []string{config.SNSTopic}
        }</span>

        <span class="cov0" title="0">_, err := cwClient.PutMetricAlarm(ctx, input)
        return err</span>
}

// StandardAlarms provides common alarm configurations
var StandardAlarms = []CloudWatchAlarmConfig{
        {
                AlarmName:          "streamer-high-connection-failures",
                MetricName:         CommonMetrics.AuthenticationFailed,
                Namespace:          "Streamer",
                Statistic:          types.StatisticSum,
                Period:             300, // 5 minutes
                EvaluationPeriods:  2,
                Threshold:          10,
                ComparisonOperator: types.ComparisonOperatorGreaterThanThreshold,
                AlarmDescription:   "Alert when authentication failures exceed threshold",
        },
        {
                AlarmName:          "streamer-high-message-failures",
                MetricName:         CommonMetrics.MessageFailed,
                Namespace:          "Streamer",
                Statistic:          types.StatisticSum,
                Period:             300,
                EvaluationPeriods:  2,
                Threshold:          50,
                ComparisonOperator: types.ComparisonOperatorGreaterThanThreshold,
                AlarmDescription:   "Alert when message failures exceed threshold",
        },
        {
                AlarmName:          "streamer-high-processing-latency",
                MetricName:         CommonMetrics.ProcessingLatency,
                Namespace:          "Streamer",
                Statistic:          types.StatisticAverage,
                Period:             300,
                EvaluationPeriods:  3,
                Threshold:          1000, // 1 second
                ComparisonOperator: types.ComparisonOperatorGreaterThanThreshold,
                AlarmDescription:   "Alert when processing latency is too high",
        },
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package shared

import (
        "context"

        "github.com/aws/aws-xray-sdk-go/xray"
)

// TraceSegment represents custom X-Ray segment data
type TraceSegment struct {
        ConnectionID string `json:"connection_id,omitempty"`
        UserID       string `json:"user_id,omitempty"`
        TenantID     string `json:"tenant_id,omitempty"`
        MessageType  string `json:"message_type,omitempty"`
        MessageSize  int    `json:"message_size,omitempty"`
        Action       string `json:"action,omitempty"`
}

// StartSubsegment starts a new X-Ray subsegment with custom data
func StartSubsegment(ctx context.Context, name string, data TraceSegment) (context.Context, *xray.Segment) <span class="cov8" title="6">{
        ctx, seg := xray.BeginSubsegment(ctx, name)

        // Handle nil segment (e.g., in test environments)
        if seg == nil </span><span class="cov8" title="6">{
                return ctx, nil
        }</span>

        // Add annotations for searchable fields
        <span class="cov0" title="0">if data.ConnectionID != "" </span><span class="cov0" title="0">{
                seg.AddAnnotation("connection_id", data.ConnectionID)
        }</span>
        <span class="cov0" title="0">if data.UserID != "" </span><span class="cov0" title="0">{
                seg.AddAnnotation("user_id", data.UserID)
        }</span>
        <span class="cov0" title="0">if data.TenantID != "" </span><span class="cov0" title="0">{
                seg.AddAnnotation("tenant_id", data.TenantID)
        }</span>
        <span class="cov0" title="0">if data.Action != "" </span><span class="cov0" title="0">{
                seg.AddAnnotation("action", data.Action)
        }</span>

        // Add metadata for detailed info
        <span class="cov0" title="0">metadata := make(map[string]interface{})
        if data.MessageType != "" </span><span class="cov0" title="0">{
                metadata["type"] = data.MessageType
        }</span>
        <span class="cov0" title="0">if data.MessageSize &gt; 0 </span><span class="cov0" title="0">{
                metadata["size"] = data.MessageSize
        }</span>
        <span class="cov0" title="0">if len(metadata) &gt; 0 </span><span class="cov0" title="0">{
                seg.AddMetadata("message", metadata)
        }</span>

        <span class="cov0" title="0">return ctx, seg</span>
}

// EndSubsegment ends an X-Ray subsegment and records any error
func EndSubsegment(seg *xray.Segment, err error) <span class="cov9" title="7">{
        if seg == nil </span><span class="cov9" title="7">{
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                seg.AddError(err)
        }</span>
        <span class="cov0" title="0">seg.Close(err)</span>
}

// CaptureFunc wraps a function with X-Ray tracing
func CaptureFunc(ctx context.Context, name string, fn func(context.Context) error) error <span class="cov5" title="3">{
        return xray.Capture(ctx, name, func(ctx1 context.Context) error </span><span class="cov5" title="3">{
                return fn(ctx1)
        }</span>)
}

// CaptureFuncWithData wraps a function with X-Ray tracing and custom data
func CaptureFuncWithData(ctx context.Context, name string, data TraceSegment, fn func(context.Context) error) error <span class="cov7" title="5">{
        return xray.Capture(ctx, name, func(ctx1 context.Context) error </span><span class="cov7" title="5">{
                seg := xray.GetSegment(ctx1)

                // Handle nil segment (e.g., in test environments)
                if seg == nil </span><span class="cov7" title="5">{
                        return fn(ctx1)
                }</span>

                // Add custom data to segment
                <span class="cov0" title="0">if data.ConnectionID != "" </span><span class="cov0" title="0">{
                        seg.AddAnnotation("connection_id", data.ConnectionID)
                }</span>
                <span class="cov0" title="0">if data.UserID != "" </span><span class="cov0" title="0">{
                        seg.AddAnnotation("user_id", data.UserID)
                }</span>
                <span class="cov0" title="0">if data.TenantID != "" </span><span class="cov0" title="0">{
                        seg.AddAnnotation("tenant_id", data.TenantID)
                }</span>
                <span class="cov0" title="0">if data.Action != "" </span><span class="cov0" title="0">{
                        seg.AddAnnotation("action", data.Action)
                }</span>
                // Add message metadata
                <span class="cov0" title="0">msgMetadata := make(map[string]interface{})
                if data.MessageType != "" </span><span class="cov0" title="0">{
                        msgMetadata["type"] = data.MessageType
                }</span>
                <span class="cov0" title="0">if data.MessageSize &gt; 0 </span><span class="cov0" title="0">{
                        msgMetadata["size"] = data.MessageSize
                }</span>
                <span class="cov0" title="0">if len(msgMetadata) &gt; 0 </span><span class="cov0" title="0">{
                        seg.AddMetadata("message", msgMetadata)
                }</span>

                <span class="cov0" title="0">return fn(ctx1)</span>
        })
}

// AddTraceMetadata adds metadata to the current segment
func AddTraceMetadata(ctx context.Context, namespace, key string, value interface{}) <span class="cov10" title="8">{
        if seg := xray.GetSegment(ctx); seg != nil </span><span class="cov0" title="0">{
                metadata := map[string]interface{}{key: value}
                seg.AddMetadata(namespace, metadata)
        }</span>
}

// AddTraceAnnotation adds an annotation to the current segment
func AddTraceAnnotation(ctx context.Context, key string, value string) <span class="cov8" title="6">{
        if seg := xray.GetSegment(ctx); seg != nil </span><span class="cov0" title="0">{
                seg.AddAnnotation(key, value)
        }</span>
}

// RecordError records an error in the current segment
func RecordError(ctx context.Context, err error) <span class="cov7" title="5">{
        if seg := xray.GetSegment(ctx); seg != nil </span><span class="cov0" title="0">{
                seg.AddError(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package connection

import (
        "errors"
        "strings"

        "github.com/aws/aws-sdk-go-v2/service/apigatewaymanagementapi/types"
        "github.com/aws/smithy-go"
)

// isGoneError checks if the error indicates the connection is gone (410 status)
func isGoneError(err error) bool <span class="cov10" title="15">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov9" title="14">var apiErr smithy.APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov9" title="12">{
                // Check for GoneException or 410 status code
                return apiErr.ErrorCode() == "GoneException" ||
                        strings.Contains(apiErr.Error(), "410") ||
                        strings.Contains(apiErr.Error(), "Gone")
        }</span>

        // Check for specific exception types
        <span class="cov3" title="2">var goneErr *types.GoneException
        return errors.As(err, &amp;goneErr)</span>
}

// isForbiddenError checks if the error indicates forbidden access
func isForbiddenError(err error) bool <span class="cov8" title="11">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="10">var apiErr smithy.APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov8" title="9">{
                return apiErr.ErrorCode() == "ForbiddenException"
        }</span>

        <span class="cov1" title="1">var forbiddenErr *types.ForbiddenException
        return errors.As(err, &amp;forbiddenErr)</span>
}

// isPayloadTooLargeError checks if the error indicates payload is too large
func isPayloadTooLargeError(err error) bool <span class="cov8" title="11">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov8" title="10">var apiErr smithy.APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov8" title="9">{
                return apiErr.ErrorCode() == "PayloadTooLargeException"
        }</span>

        <span class="cov1" title="1">var payloadErr *types.PayloadTooLargeException
        return errors.As(err, &amp;payloadErr)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package connection

import (
        "context"
        "errors"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/apigatewaymanagementapi"
        "github.com/aws/aws-sdk-go-v2/service/apigatewaymanagementapi/types"
)

// AWSAPIGatewayAdapter adapts the AWS SDK client to our interface
type AWSAPIGatewayAdapter struct {
        client *apigatewaymanagementapi.Client
}

// NewAWSAPIGatewayAdapter creates a new adapter
func NewAWSAPIGatewayAdapter(client *apigatewaymanagementapi.Client) *AWSAPIGatewayAdapter <span class="cov1" title="1">{
        return &amp;AWSAPIGatewayAdapter{
                client: client,
        }
}</span>

// PostToConnection sends data to a WebSocket connection
func (a *AWSAPIGatewayAdapter) PostToConnection(ctx context.Context, connectionID string, data []byte) error <span class="cov0" title="0">{
        input := &amp;apigatewaymanagementapi.PostToConnectionInput{
                ConnectionId: aws.String(connectionID),
                Data:         data,
        }

        _, err := a.client.PostToConnection(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                // Convert AWS SDK errors to our error types
                return a.convertError(err, connectionID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteConnection terminates a WebSocket connection
func (a *AWSAPIGatewayAdapter) DeleteConnection(ctx context.Context, connectionID string) error <span class="cov0" title="0">{
        input := &amp;apigatewaymanagementapi.DeleteConnectionInput{
                ConnectionId: aws.String(connectionID),
        }

        _, err := a.client.DeleteConnection(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                // Convert AWS SDK errors to our error types
                return a.convertError(err, connectionID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConnection retrieves connection information
func (a *AWSAPIGatewayAdapter) GetConnection(ctx context.Context, connectionID string) (*ConnectionInfo, error) <span class="cov0" title="0">{
        input := &amp;apigatewaymanagementapi.GetConnectionInput{
                ConnectionId: aws.String(connectionID),
        }

        output, err := a.client.GetConnection(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, a.convertError(err, connectionID)
        }</span>

        <span class="cov0" title="0">info := &amp;ConnectionInfo{
                ConnectionID: connectionID,
        }

        if output.ConnectedAt != nil </span><span class="cov0" title="0">{
                info.ConnectedAt = output.ConnectedAt.String()
        }</span>
        <span class="cov0" title="0">if output.LastActiveAt != nil </span><span class="cov0" title="0">{
                info.LastActiveAt = output.LastActiveAt.String()
        }</span>
        <span class="cov0" title="0">if output.Identity != nil </span><span class="cov0" title="0">{
                if output.Identity.SourceIp != nil </span><span class="cov0" title="0">{
                        info.SourceIP = *output.Identity.SourceIp
                }</span>
                <span class="cov0" title="0">if output.Identity.UserAgent != nil </span><span class="cov0" title="0">{
                        info.UserAgent = *output.Identity.UserAgent
                }</span>
        }

        <span class="cov0" title="0">return info, nil</span>
}

// convertError converts AWS SDK errors to our error types
func (a *AWSAPIGatewayAdapter) convertError(err error, connectionID string) error <span class="cov10" title="22">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Check for specific AWS SDK error types
        <span class="cov9" title="21">var goneErr *types.GoneException
        if errors.As(err, &amp;goneErr) </span><span class="cov5" title="5">{
                return GoneError{
                        ConnectionID: connectionID,
                        Message:      fmt.Sprintf("connection %s is gone: %v", connectionID, err),
                }
        }</span>

        <span class="cov9" title="16">var forbiddenErr *types.ForbiddenException
        if errors.As(err, &amp;forbiddenErr) </span><span class="cov5" title="4">{
                return ForbiddenError{
                        ConnectionID: connectionID,
                        Message:      fmt.Sprintf("forbidden access to connection %s: %v", connectionID, err),
                }
        }</span>

        <span class="cov8" title="12">var payloadErr *types.PayloadTooLargeException
        if errors.As(err, &amp;payloadErr) </span><span class="cov3" title="2">{
                return PayloadTooLargeError{
                        ConnectionID: connectionID,
                        Message:      fmt.Sprintf("payload too large for connection %s: %v", connectionID, err),
                }
        }</span>

        // AWS SDK v2 doesn't have a specific throttling exception type
        // We'll check for it via the HTTP status code below

        // Check for HTTP status codes in generic API errors
        <span class="cov7" title="10">var apiErr interface{ HTTPStatusCode() int }
        if errors.As(err, &amp;apiErr) </span><span class="cov7" title="9">{
                switch apiErr.HTTPStatusCode() </span>{
                case 410:<span class="cov1" title="1">
                        return GoneError{
                                ConnectionID: connectionID,
                                Message:      fmt.Sprintf("connection %s returned 410: %v", connectionID, err),
                        }</span>
                case 403:<span class="cov1" title="1">
                        return ForbiddenError{
                                ConnectionID: connectionID,
                                Message:      fmt.Sprintf("connection %s returned 403: %v", connectionID, err),
                        }</span>
                case 413:<span class="cov1" title="1">
                        return PayloadTooLargeError{
                                ConnectionID: connectionID,
                                Message:      fmt.Sprintf("connection %s returned 413: %v", connectionID, err),
                        }</span>
                case 429:<span class="cov1" title="1">
                        return ThrottlingError{
                                ConnectionID: connectionID,
                                Message:      fmt.Sprintf("connection %s returned 429: %v", connectionID, err),
                        }</span>
                case 500, 502, 503, 504:<span class="cov5" title="4">
                        return InternalServerError{
                                Message: fmt.Sprintf("server error for connection %s: %v", connectionID, err),
                        }</span>
                }
        }

        // Return the original error if we can't convert it
        <span class="cov3" title="2">return err</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package connection

import (
        "errors"
        "fmt"
)

// Common errors
var (
        // ErrConnectionNotFound indicates the connection ID doesn't exist
        ErrConnectionNotFound = errors.New("connection not found")

        // ErrConnectionStale indicates the connection is no longer valid (410 Gone)
        ErrConnectionStale = errors.New("connection is stale")

        // ErrInvalidMessage indicates the message could not be marshaled
        ErrInvalidMessage = errors.New("invalid message format")

        // ErrBroadcastPartialFailure indicates some connections failed during broadcast
        ErrBroadcastPartialFailure = errors.New("broadcast partially failed")
)

// ConnectionError represents a connection-specific error
type ConnectionError struct {
        ConnectionID string
        Err          error
}

func (e *ConnectionError) Error() string <span class="cov10" title="4">{
        return "connection " + e.ConnectionID + ": " + e.Err.Error()
}</span>

func (e *ConnectionError) Unwrap() error <span class="cov8" title="3">{
        return e.Err
}</span>

// ConnectionGoneError indicates a WebSocket connection no longer exists
type ConnectionGoneError struct {
        ConnectionID string
}

func (e *ConnectionGoneError) Error() string <span class="cov1" title="1">{
        return fmt.Sprintf("connection %s is no longer active", e.ConnectionID)
}</span>

// BroadcastError contains errors from broadcasting to multiple connections
type BroadcastError struct {
        Failed []string // Connection IDs that failed
        Errors []error  // Corresponding errors
}

func (e *BroadcastError) Error() string <span class="cov8" title="3">{
        return fmt.Sprintf("broadcast failed for %d connections", len(e.Failed))
}</span>

// IsConnectionGone checks if an error indicates the connection is gone
func IsConnectionGone(err error) bool <span class="cov10" title="4">{
        _, ok := err.(*ConnectionGoneError)
        return ok
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package connection

import (
        "context"
)

// ConnectionManager defines the interface for managing WebSocket connections
type ConnectionManager interface {
        // Send sends a message to a specific connection
        Send(ctx context.Context, connectionID string, message interface{}) error

        // Broadcast sends a message to multiple connections
        Broadcast(ctx context.Context, connectionIDs []string, message interface{}) error

        // IsActive checks if a connection is active
        IsActive(ctx context.Context, connectionID string) bool

        // GetMetrics returns current performance metrics
        GetMetrics() map[string]interface{}

        // Shutdown gracefully shuts down the manager
        Shutdown(ctx context.Context) error

        // SetLogger sets a custom logger function
        SetLogger(logger func(format string, args ...interface{}))
}

// Ensure Manager implements ConnectionManager interface
var _ ConnectionManager = (*Manager)(nil)

// APIGatewayClient defines the interface for API Gateway Management API operations
type APIGatewayClient interface {
        // PostToConnection sends data to a WebSocket connection
        PostToConnection(ctx context.Context, connectionID string, data []byte) error

        // DeleteConnection terminates a WebSocket connection
        DeleteConnection(ctx context.Context, connectionID string) error

        // GetConnection retrieves connection information
        GetConnection(ctx context.Context, connectionID string) (*ConnectionInfo, error)
}

// ConnectionInfo represents information about a WebSocket connection
type ConnectionInfo struct {
        ConnectionID string
        ConnectedAt  string
        LastActiveAt string
        SourceIP     string
        UserAgent    string
}

// APIError represents an error from the API Gateway service
type APIError interface {
        error
        // HTTPStatusCode returns the HTTP status code of the error
        HTTPStatusCode() int
        // ErrorCode returns the error code (e.g., "GoneException")
        ErrorCode() string
        // IsRetryable returns true if the error is retryable
        IsRetryable() bool
}

// Common API Gateway error types
type (
        // GoneError indicates the connection no longer exists (410 Gone)
        GoneError struct {
                ConnectionID string
                Message      string
        }

        // ForbiddenError indicates access is forbidden (403 Forbidden)
        ForbiddenError struct {
                ConnectionID string
                Message      string
        }

        // PayloadTooLargeError indicates the payload exceeds size limits
        PayloadTooLargeError struct {
                ConnectionID string
                PayloadSize  int
                MaxSize      int
                Message      string
        }

        // ThrottlingError indicates rate limit exceeded (429 Too Many Requests)
        ThrottlingError struct {
                ConnectionID string
                RetryAfter   int // seconds
                Message      string
        }

        // InternalServerError indicates a server error (500)
        InternalServerError struct {
                Message string
        }
)

// Error implementations
func (e GoneError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

func (e GoneError) HTTPStatusCode() int <span class="cov8" title="1">{
        return 410
}</span>

func (e GoneError) ErrorCode() string <span class="cov8" title="1">{
        return "GoneException"
}</span>

func (e GoneError) IsRetryable() bool <span class="cov8" title="1">{
        return false
}</span>

func (e ForbiddenError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

func (e ForbiddenError) HTTPStatusCode() int <span class="cov8" title="1">{
        return 403
}</span>

func (e ForbiddenError) ErrorCode() string <span class="cov8" title="1">{
        return "ForbiddenException"
}</span>

func (e ForbiddenError) IsRetryable() bool <span class="cov8" title="1">{
        return false
}</span>

func (e PayloadTooLargeError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

func (e PayloadTooLargeError) HTTPStatusCode() int <span class="cov8" title="1">{
        return 413
}</span>

func (e PayloadTooLargeError) ErrorCode() string <span class="cov8" title="1">{
        return "PayloadTooLargeException"
}</span>

func (e PayloadTooLargeError) IsRetryable() bool <span class="cov8" title="1">{
        return false
}</span>

func (e ThrottlingError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

func (e ThrottlingError) HTTPStatusCode() int <span class="cov8" title="1">{
        return 429
}</span>

func (e ThrottlingError) ErrorCode() string <span class="cov8" title="1">{
        return "ThrottlingException"
}</span>

func (e ThrottlingError) IsRetryable() bool <span class="cov8" title="1">{
        return true
}</span>

func (e InternalServerError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

func (e InternalServerError) HTTPStatusCode() int <span class="cov8" title="1">{
        return 500
}</span>

func (e InternalServerError) ErrorCode() string <span class="cov8" title="1">{
        return "InternalServerError"
}</span>

func (e InternalServerError) IsRetryable() bool <span class="cov8" title="1">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package connection

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "math/rand"
        "sync"
        "sync/atomic"
        "time"

        "github.com/aws/aws-sdk-go-v2/service/apigatewaymanagementapi/types"
        "github.com/pay-theory/streamer/internal/store"
)

// Metrics holds performance metrics for the connection manager
type Metrics struct {
        SendLatency      *LatencyTracker
        BroadcastLatency *LatencyTracker
        ErrorsByType     map[string]*atomic.Int64
        ActiveSends      *atomic.Int32
        mu               sync.RWMutex
}

// LatencyTracker tracks latency percentiles
type LatencyTracker struct {
        samples []time.Duration
        mu      sync.Mutex
}

// CircuitBreaker tracks connection health
type CircuitBreaker struct {
        failures   map[string]int
        lastFailed map[string]time.Time
        mu         sync.RWMutex
}

// Manager handles WebSocket connections through API Gateway
type Manager struct {
        store      store.ConnectionStore
        apiGateway APIGatewayClient
        endpoint   string

        // Production features
        workerPool     chan struct{}
        circuitBreaker *CircuitBreaker
        metrics        *Metrics
        shutdownCh     chan struct{}
        wg             sync.WaitGroup

        mu     sync.RWMutex
        logger func(format string, args ...interface{})
}

// NewManager creates a new connection manager
func NewManager(store store.ConnectionStore, apiGateway APIGatewayClient, endpoint string) *Manager <span class="cov4" title="16">{
        m := &amp;Manager{
                store:      store,
                apiGateway: apiGateway,
                endpoint:   endpoint,
                workerPool: make(chan struct{}, 10), // 10 concurrent workers
                circuitBreaker: &amp;CircuitBreaker{
                        failures:   make(map[string]int),
                        lastFailed: make(map[string]time.Time),
                },
                metrics: &amp;Metrics{
                        SendLatency:      &amp;LatencyTracker{},
                        BroadcastLatency: &amp;LatencyTracker{},
                        ErrorsByType:     make(map[string]*atomic.Int64),
                        ActiveSends:      &amp;atomic.Int32{},
                },
                shutdownCh: make(chan struct{}),
                logger:     func(format string, args ...interface{}) </span><span class="cov0" title="0">{ fmt.Printf(format+"\n", args...) }</span>,
        }

        // Initialize error counters
        <span class="cov4" title="16">errorTypes := []string{"connection_not_found", "connection_stale", "marshal_error", "network_error", "timeout"}
        for _, errType := range errorTypes </span><span class="cov6" title="80">{
                m.metrics.ErrorsByType[errType] = &amp;atomic.Int64{}
        }</span>

        <span class="cov4" title="16">return m</span>
}

// SetLogger sets a custom logger function
func (m *Manager) SetLogger(logger func(format string, args ...interface{})) <span class="cov4" title="15">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.logger = logger
}</span>

// Shutdown gracefully shuts down the manager
func (m *Manager) Shutdown(ctx context.Context) error <span class="cov1" title="1">{
        m.logger("Shutting down connection manager...")

        // Signal shutdown
        close(m.shutdownCh)

        // Wait for active operations to complete
        done := make(chan struct{})
        go func() </span><span class="cov1" title="1">{
                m.wg.Wait()
                close(done)
        }</span>()

        <span class="cov1" title="1">select </span>{
        case &lt;-done:<span class="cov1" title="1">
                m.logger("Connection manager shutdown complete")
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                m.logger("Connection manager shutdown timed out")
                return ctx.Err()</span>
        }
}

// Send sends a message to a specific connection
func (m *Manager) Send(ctx context.Context, connectionID string, message interface{}) error <span class="cov3" title="9">{
        // Check if shutting down
        select </span>{
        case &lt;-m.shutdownCh:<span class="cov1" title="1">
                return errors.New("manager is shutting down")</span>
        default:<span class="cov3" title="8"></span>
        }

        // Track active sends
        <span class="cov3" title="8">m.metrics.ActiveSends.Add(1)
        defer m.metrics.ActiveSends.Add(-1)

        // Track latency
        start := time.Now()
        defer func() </span><span class="cov3" title="8">{
                m.metrics.SendLatency.Record(time.Since(start))
        }</span>()

        // Check circuit breaker
        <span class="cov3" title="8">if m.circuitBreaker.IsOpen(connectionID) </span><span class="cov0" title="0">{
                m.metrics.ErrorsByType["circuit_open"].Add(1)
                return fmt.Errorf("circuit breaker open for connection %s", connectionID)
        }</span>

        // Validate connection exists
        <span class="cov3" title="8">conn, err := m.store.Get(ctx, connectionID)
        if err != nil </span><span class="cov1" title="2">{
                if errors.Is(err, store.ErrNotFound) </span><span class="cov1" title="2">{
                        m.metrics.ErrorsByType["connection_not_found"].Add(1)
                        return ErrConnectionNotFound
                }</span>
                <span class="cov0" title="0">m.metrics.ErrorsByType["network_error"].Add(1)
                return fmt.Errorf("failed to get connection: %w", err)</span>
        }

        // Marshal message to JSON
        <span class="cov3" title="6">data, err := json.Marshal(message)
        if err != nil </span><span class="cov1" title="1">{
                m.metrics.ErrorsByType["marshal_error"].Add(1)
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        // Send with retry logic
        <span class="cov3" title="5">err = m.sendWithRetry(ctx, connectionID, data)
        if err != nil </span><span class="cov2" title="3">{
                // Handle 410 Gone - connection is stale
                if isConnectionGone(err) </span><span class="cov1" title="1">{
                        m.metrics.ErrorsByType["connection_stale"].Add(1)
                        m.logger("Connection %s is stale, removing from store", connectionID)
                        if delErr := m.store.Delete(ctx, connectionID); delErr != nil </span><span class="cov0" title="0">{
                                m.logger("Failed to delete stale connection %s: %v", connectionID, delErr)
                        }</span>
                        <span class="cov1" title="1">return ErrConnectionStale</span>
                }

                // Record failure for circuit breaker
                <span class="cov1" title="2">m.circuitBreaker.RecordFailure(connectionID)
                m.metrics.ErrorsByType["network_error"].Add(1)
                return err</span>
        }

        // Record success
        <span class="cov1" title="2">m.circuitBreaker.RecordSuccess(connectionID)

        // Update last ping time
        go func() </span><span class="cov1" title="2">{
                updateCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()
                if err := m.store.UpdateLastPing(updateCtx, conn.ConnectionID); err != nil </span><span class="cov0" title="0">{
                        m.logger("Failed to update last ping for connection %s: %v", connectionID, err)
                }</span>
        }()

        <span class="cov1" title="2">return nil</span>
}

// Broadcast sends a message to multiple connections
func (m *Manager) Broadcast(ctx context.Context, connectionIDs []string, message interface{}) error <span class="cov2" title="4">{
        if len(connectionIDs) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Track broadcast latency
        <span class="cov2" title="3">start := time.Now()
        defer func() </span><span class="cov2" title="3">{
                m.metrics.BroadcastLatency.Record(time.Since(start))
        }</span>()

        // Marshal message once
        <span class="cov2" title="3">data, err := json.Marshal(message)
        if err != nil </span><span class="cov0" title="0">{
                m.metrics.ErrorsByType["marshal_error"].Add(1)
                return fmt.Errorf("failed to marshal message: %w", err)
        }</span>

        // Use worker pool for parallel sending
        <span class="cov2" title="3">jobs := make(chan string, len(connectionIDs))
        results := make(chan error, len(connectionIDs))

        // Start workers
        numWorkers := 10
        if len(connectionIDs) &lt; numWorkers </span><span class="cov2" title="3">{
                numWorkers = len(connectionIDs)
        }</span>

        <span class="cov2" title="3">m.wg.Add(numWorkers)
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov3" title="8">{
                go func() </span><span class="cov3" title="8">{
                        defer m.wg.Done()
                        for connID := range jobs </span><span class="cov3" title="8">{
                                select </span>{
                                case &lt;-m.shutdownCh:<span class="cov0" title="0">
                                        results &lt;- errors.New("shutdown in progress")
                                        return</span>
                                case m.workerPool &lt;- struct{}{}:<span class="cov3" title="8">
                                        err := m.sendWithRetry(ctx, connID, data)
                                        &lt;-m.workerPool

                                        if err != nil </span><span class="cov1" title="2">{
                                                m.logger("Failed to send to connection %s: %v", connID, err)

                                                // Handle stale connections
                                                if isConnectionGone(err) </span><span class="cov1" title="1">{
                                                        go func(id string) </span><span class="cov1" title="1">{
                                                                delCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                                                                defer cancel()
                                                                if delErr := m.store.Delete(delCtx, id); delErr != nil </span><span class="cov0" title="0">{
                                                                        m.logger("Failed to delete stale connection %s: %v", id, delErr)
                                                                }</span>
                                                        }(connID)
                                                }
                                        }
                                        <span class="cov3" title="8">results &lt;- err</span>
                                }
                        }
                }()
        }

        // Queue jobs
        <span class="cov2" title="3">for _, connID := range connectionIDs </span><span class="cov3" title="8">{
                jobs &lt;- connID
        }</span>
        <span class="cov2" title="3">close(jobs)

        // Collect results
        var errs []error
        for i := 0; i &lt; len(connectionIDs); i++ </span><span class="cov3" title="8">{
                if err := &lt;-results; err != nil </span><span class="cov1" title="2">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov2" title="3">if len(errs) &gt; 0 </span><span class="cov1" title="2">{
                m.logger("Broadcast completed with %d errors out of %d connections", len(errs), len(connectionIDs))
                return fmt.Errorf("broadcast had %d failures: %w", len(errs), errs[0])
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// IsActive checks if a connection is active
func (m *Manager) IsActive(ctx context.Context, connectionID string) bool <span class="cov2" title="4">{
        // Check circuit breaker first
        if m.circuitBreaker.IsOpen(connectionID) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov2" title="4">conn, err := m.store.Get(ctx, connectionID)
        if err != nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check if connection is stale (no ping in last 5 minutes)
        <span class="cov2" title="3">if time.Since(conn.LastPing) &gt; 5*time.Minute </span><span class="cov1" title="2">{
                // Try to ping the connection
                testData := []byte(`{"type":"ping"}`)
                err := m.sendMessage(ctx, connectionID, testData)
                if err != nil </span><span class="cov1" title="1">{
                        m.circuitBreaker.RecordFailure(connectionID)
                        return false
                }</span>
                <span class="cov1" title="1">m.circuitBreaker.RecordSuccess(connectionID)</span>
        }

        <span class="cov1" title="2">return true</span>
}

// GetMetrics returns current performance metrics
func (m *Manager) GetMetrics() map[string]interface{} <span class="cov1" title="2">{
        return map[string]interface{}{
                "active_sends":          m.metrics.ActiveSends.Load(),
                "send_latency_p50":      m.metrics.SendLatency.Percentile(0.5),
                "send_latency_p99":      m.metrics.SendLatency.Percentile(0.99),
                "broadcast_latency_p50": m.metrics.BroadcastLatency.Percentile(0.5),
                "broadcast_latency_p99": m.metrics.BroadcastLatency.Percentile(0.99),
                "errors": map[string]int64{
                        "connection_not_found": m.metrics.ErrorsByType["connection_not_found"].Load(),
                        "connection_stale":     m.metrics.ErrorsByType["connection_stale"].Load(),
                        "marshal_error":        m.metrics.ErrorsByType["marshal_error"].Load(),
                        "network_error":        m.metrics.ErrorsByType["network_error"].Load(),
                },
                "circuit_breakers_open": m.circuitBreaker.CountOpen(),
        }
}</span>

// sendWithRetry sends a message with exponential backoff retry
func (m *Manager) sendWithRetry(ctx context.Context, connectionID string, data []byte) error <span class="cov4" title="13">{
        const maxRetries = 3
        baseDelay := 100 * time.Millisecond

        var lastErr error
        for attempt := 0; attempt &lt; maxRetries; attempt++ </span><span class="cov5" title="23">{
                err := m.sendMessage(ctx, connectionID, data)
                if err == nil </span><span class="cov3" title="8">{
                        return nil
                }</span>

                <span class="cov4" title="15">lastErr = err

                // Check if error is retryable using our interface
                var apiErr APIError
                if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                        if !apiErr.IsRetryable() </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov4" title="15"> {
                        // Fallback to checking HTTP status codes for legacy AWS SDK errors
                        var clientErr interface{ HTTPStatusCode() int }
                        if errors.As(err, &amp;clientErr) </span><span class="cov0" title="0">{
                                statusCode := clientErr.HTTPStatusCode()
                                if statusCode &gt;= 400 &amp;&amp; statusCode &lt; 500 &amp;&amp; statusCode != 429 </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                // Calculate delay with exponential backoff
                <span class="cov4" title="15">delay := baseDelay * time.Duration(1&lt;&lt;attempt)
                if delay &gt; 5*time.Second </span><span class="cov0" title="0">{
                        delay = 5 * time.Second
                }</span>

                // Add jitter (±25%)
                <span class="cov4" title="15">jitter := time.Duration(float64(delay) * 0.25 * (2*rand.Float64() - 1))
                delay += jitter

                m.logger("Retry %d/%d for connection %s after %v", attempt+1, maxRetries, connectionID, delay)

                select </span>{
                case &lt;-time.After(delay):<span class="cov4" title="15"></span>
                        // Continue to next retry
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-m.shutdownCh:<span class="cov0" title="0">
                        return errors.New("shutdown in progress")</span>
                }
        }

        <span class="cov3" title="5">return fmt.Errorf("failed after %d retries: %w", maxRetries, lastErr)</span>
}

// sendMessage sends a single message to a connection
func (m *Manager) sendMessage(ctx context.Context, connectionID string, data []byte) error <span class="cov5" title="25">{
        return m.apiGateway.PostToConnection(ctx, connectionID, data)
}</span>

// isConnectionGone checks if the error indicates a 410 Gone status
func isConnectionGone(err error) bool <span class="cov4" title="12">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check for our GoneError type
        <span class="cov4" title="11">var goneErr GoneError
        if errors.As(err, &amp;goneErr) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check for GoneException type (AWS SDK)
        <span class="cov4" title="11">var goneException *types.GoneException
        if errors.As(err, &amp;goneException) </span><span class="cov2" title="4">{
                return true
        }</span>

        // Also check for HTTP status code in error response
        <span class="cov3" title="7">var apiErr APIError
        if errors.As(err, &amp;apiErr) &amp;&amp; apiErr.HTTPStatusCode() == 410 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Legacy check for AWS SDK errors
        <span class="cov3" title="7">var sdkErr interface{ HTTPStatusCode() int }
        if errors.As(err, &amp;sdkErr) &amp;&amp; sdkErr.HTTPStatusCode() == 410 </span><span class="cov1" title="1">{
                return true
        }</span>

        <span class="cov3" title="6">return false</span>
}

// CircuitBreaker methods

func (cb *CircuitBreaker) IsOpen(connectionID string) bool <span class="cov4" title="19">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        failures, exists := cb.failures[connectionID]
        if !exists </span><span class="cov4" title="14">{
                return false
        }</span>

        // Open circuit after 3 consecutive failures
        <span class="cov3" title="5">if failures &gt;= 3 </span><span class="cov2" title="3">{
                // Check if we should try again (after 30 seconds)
                if time.Since(cb.lastFailed[connectionID]) &gt; 30*time.Second </span><span class="cov1" title="1">{
                        return false
                }</span>
                <span class="cov1" title="2">return true</span>
        }

        <span class="cov1" title="2">return false</span>
}

func (cb *CircuitBreaker) RecordFailure(connectionID string) <span class="cov4" title="12">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.failures[connectionID]++
        cb.lastFailed[connectionID] = time.Now()
}</span>

func (cb *CircuitBreaker) RecordSuccess(connectionID string) <span class="cov2" title="4">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        delete(cb.failures, connectionID)
        delete(cb.lastFailed, connectionID)
}</span>

func (cb *CircuitBreaker) CountOpen() int <span class="cov2" title="3">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        count := 0
        for connID, failures := range cb.failures </span><span class="cov2" title="3">{
                if failures &gt;= 3 &amp;&amp; time.Since(cb.lastFailed[connID]) &lt;= 30*time.Second </span><span class="cov1" title="1">{
                        count++
                }</span>
        }
        <span class="cov2" title="3">return count</span>
}

// LatencyTracker methods

func (lt *LatencyTracker) Record(d time.Duration) <span class="cov10" title="1116">{
        lt.mu.Lock()
        defer lt.mu.Unlock()

        lt.samples = append(lt.samples, d)

        // Keep only last 1000 samples
        if len(lt.samples) &gt; 1000 </span><span class="cov6" title="105">{
                lt.samples = lt.samples[len(lt.samples)-1000:]
        }</span>
}

func (lt *LatencyTracker) Percentile(p float64) time.Duration <span class="cov4" title="11">{
        lt.mu.Lock()
        defer lt.mu.Unlock()

        if len(lt.samples) == 0 </span><span class="cov3" title="7">{
                return 0
        }</span>

        // Simple percentile calculation (not optimized)
        <span class="cov2" title="4">sorted := make([]time.Duration, len(lt.samples))
        copy(sorted, lt.samples)

        // Sort samples
        for i := 0; i &lt; len(sorted); i++ </span><span class="cov4" title="16">{
                for j := i + 1; j &lt; len(sorted); j++ </span><span class="cov5" title="26">{
                        if sorted[i] &gt; sorted[j] </span><span class="cov1" title="2">{
                                sorted[i], sorted[j] = sorted[j], sorted[i]
                        }</span>
                }
        }

        <span class="cov2" title="4">index := int(float64(len(sorted)-1) * p)
        return sorted[index]</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package connection provides mock implementations for testing.
//
// This file consolidates all mock types for the connection package.
// We provide both manual mocks (with function fields) and testify-based mocks
// to support different testing styles across the codebase.
package connection

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/stretchr/testify/mock"
)

// =============================================================================
// ConnectionManager Mocks
// =============================================================================

// MockConnectionManager is a manual mock implementation of ConnectionManager.
// Use this when you need fine control over mock behavior or want to avoid testify.
type MockConnectionManager struct {
        // Function fields for each method
        SendFunc       func(ctx context.Context, connectionID string, message interface{}) error
        BroadcastFunc  func(ctx context.Context, connectionIDs []string, message interface{}) error
        IsActiveFunc   func(ctx context.Context, connectionID string) bool
        GetMetricsFunc func() map[string]interface{}
        ShutdownFunc   func(ctx context.Context) error
        SetLoggerFunc  func(logger func(format string, args ...interface{}))

        // State tracking
        mu      sync.Mutex
        calls   []MethodCall
        logger  func(format string, args ...interface{})
        metrics ConnectionMetrics
}

// MethodCall records a method invocation
type MethodCall struct {
        Method    string
        Arguments []interface{}
        Timestamp time.Time
}

// ConnectionMetrics tracks mock connection metrics
type ConnectionMetrics struct {
        SendCount      int
        BroadcastCount int
        FailureCount   int
        ActiveConns    map[string]bool
}

// NewMockConnectionManager creates a mock with sensible defaults
func NewMockConnectionManager() *MockConnectionManager <span class="cov0" title="0">{
        m := &amp;MockConnectionManager{
                calls:   make([]MethodCall, 0),
                metrics: ConnectionMetrics{ActiveConns: make(map[string]bool)},
                logger:  func(format string, args ...interface{}) </span>{<span class="cov0" title="0">}</span>,
        }
        <span class="cov0" title="0">m.setupDefaults()
        return m</span>
}

func (m *MockConnectionManager) setupDefaults() <span class="cov0" title="0">{
        m.SendFunc = func(ctx context.Context, connectionID string, message interface{}) error </span><span class="cov0" title="0">{
                m.mu.Lock()
                m.metrics.SendCount++
                m.mu.Unlock()
                return nil
        }</span>

        <span class="cov0" title="0">m.BroadcastFunc = func(ctx context.Context, connectionIDs []string, message interface{}) error </span><span class="cov0" title="0">{
                m.mu.Lock()
                m.metrics.BroadcastCount++
                m.mu.Unlock()
                return nil
        }</span>

        <span class="cov0" title="0">m.IsActiveFunc = func(ctx context.Context, connectionID string) bool </span><span class="cov0" title="0">{
                m.mu.Lock()
                defer m.mu.Unlock()
                return m.metrics.ActiveConns[connectionID]
        }</span>

        <span class="cov0" title="0">m.GetMetricsFunc = func() map[string]interface{} </span><span class="cov0" title="0">{
                m.mu.Lock()
                defer m.mu.Unlock()
                return map[string]interface{}{
                        "send_count":      m.metrics.SendCount,
                        "broadcast_count": m.metrics.BroadcastCount,
                        "failure_count":   m.metrics.FailureCount,
                        "active_conns":    len(m.metrics.ActiveConns),
                }
        }</span>

        <span class="cov0" title="0">m.ShutdownFunc = func(ctx context.Context) error </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">m.SetLoggerFunc = func(logger func(format string, args ...interface{})) </span><span class="cov0" title="0">{
                m.mu.Lock()
                m.logger = logger
                m.mu.Unlock()
        }</span>
}

// Send implements ConnectionManager
func (m *MockConnectionManager) Send(ctx context.Context, connectionID string, message interface{}) error <span class="cov0" title="0">{
        m.recordCall("Send", connectionID, message)
        if m.SendFunc != nil </span><span class="cov0" title="0">{
                return m.SendFunc(ctx, connectionID, message)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Broadcast implements ConnectionManager
func (m *MockConnectionManager) Broadcast(ctx context.Context, connectionIDs []string, message interface{}) error <span class="cov0" title="0">{
        m.recordCall("Broadcast", connectionIDs, message)
        if m.BroadcastFunc != nil </span><span class="cov0" title="0">{
                return m.BroadcastFunc(ctx, connectionIDs, message)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsActive implements ConnectionManager
func (m *MockConnectionManager) IsActive(ctx context.Context, connectionID string) bool <span class="cov0" title="0">{
        m.recordCall("IsActive", connectionID)
        if m.IsActiveFunc != nil </span><span class="cov0" title="0">{
                return m.IsActiveFunc(ctx, connectionID)
        }</span>
        <span class="cov0" title="0">return true</span>
}

// GetMetrics implements ConnectionManager
func (m *MockConnectionManager) GetMetrics() map[string]interface{} <span class="cov0" title="0">{
        m.recordCall("GetMetrics")
        if m.GetMetricsFunc != nil </span><span class="cov0" title="0">{
                return m.GetMetricsFunc()
        }</span>
        <span class="cov0" title="0">return make(map[string]interface{})</span>
}

// Shutdown implements ConnectionManager
func (m *MockConnectionManager) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        m.recordCall("Shutdown")
        if m.ShutdownFunc != nil </span><span class="cov0" title="0">{
                return m.ShutdownFunc(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetLogger implements ConnectionManager
func (m *MockConnectionManager) SetLogger(logger func(format string, args ...interface{})) <span class="cov0" title="0">{
        m.recordCall("SetLogger", logger)
        if m.SetLoggerFunc != nil </span><span class="cov0" title="0">{
                m.SetLoggerFunc(logger)
        }</span>
}

func (m *MockConnectionManager) recordCall(method string, args ...interface{}) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.calls = append(m.calls, MethodCall{
                Method:    method,
                Arguments: args,
                Timestamp: time.Now(),
        })
}</span>

// Testing helpers
func (m *MockConnectionManager) CallCount(method string) int <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        count := 0
        for _, call := range m.calls </span><span class="cov0" title="0">{
                if call.Method == method </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

func (m *MockConnectionManager) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.calls = m.calls[:0]
        m.metrics = ConnectionMetrics{ActiveConns: make(map[string]bool)}
}</span>

// MockConnectionManagerTestify is a testify-based mock of ConnectionManager.
// Use this when you prefer testify's mocking style.
type MockConnectionManagerTestify struct {
        mock.Mock
}

func (m *MockConnectionManagerTestify) Send(ctx context.Context, connectionID string, message interface{}) error <span class="cov0" title="0">{
        args := m.Called(ctx, connectionID, message)
        return args.Error(0)
}</span>

func (m *MockConnectionManagerTestify) Broadcast(ctx context.Context, connectionIDs []string, message interface{}) error <span class="cov0" title="0">{
        args := m.Called(ctx, connectionIDs, message)
        return args.Error(0)
}</span>

func (m *MockConnectionManagerTestify) IsActive(ctx context.Context, connectionID string) bool <span class="cov0" title="0">{
        args := m.Called(ctx, connectionID)
        return args.Bool(0)
}</span>

func (m *MockConnectionManagerTestify) GetMetrics() map[string]interface{} <span class="cov0" title="0">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return args.Get(0).(map[string]interface{})</span>
}

func (m *MockConnectionManagerTestify) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        args := m.Called(ctx)
        return args.Error(0)
}</span>

func (m *MockConnectionManagerTestify) SetLogger(logger func(format string, args ...interface{})) <span class="cov0" title="0">{
        m.Called(logger)
}</span>

// =============================================================================
// APIGatewayClient Mocks
// =============================================================================

// MockAPIGatewayClient is a testify-based mock of APIGatewayClient
type MockAPIGatewayClient struct {
        mock.Mock
        mu          sync.Mutex
        connections map[string]*ConnectionInfo
        messages    map[string][][]byte // connectionID -&gt; messages sent
}

// NewMockAPIGatewayClient creates a new mock API Gateway client
func NewMockAPIGatewayClient() *MockAPIGatewayClient <span class="cov8" title="17">{
        return &amp;MockAPIGatewayClient{
                connections: make(map[string]*ConnectionInfo),
                messages:    make(map[string][][]byte),
        }
}</span>

func (m *MockAPIGatewayClient) PostToConnection(ctx context.Context, connectionID string, data []byte) error <span class="cov10" title="26">{
        m.mu.Lock()
        m.messages[connectionID] = append(m.messages[connectionID], data)
        m.mu.Unlock()

        args := m.Called(ctx, connectionID, data)
        return args.Error(0)
}</span>

func (m *MockAPIGatewayClient) DeleteConnection(ctx context.Context, connectionID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        delete(m.connections, connectionID)
        delete(m.messages, connectionID)
        m.mu.Unlock()

        args := m.Called(ctx, connectionID)
        return args.Error(0)
}</span>

func (m *MockAPIGatewayClient) GetConnection(ctx context.Context, connectionID string) (*ConnectionInfo, error) <span class="cov0" title="0">{
        args := m.Called(ctx, connectionID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*ConnectionInfo), args.Error(1)</span>
}

// Helper methods
func (m *MockAPIGatewayClient) AddConnection(connectionID string, info *ConnectionInfo) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.connections[connectionID] = info
}</span>

func (m *MockAPIGatewayClient) GetMessages(connectionID string) [][]byte <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return append([][]byte{}, m.messages[connectionID]...)
}</span>

func (m *MockAPIGatewayClient) ClearMessages() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.messages = make(map[string][][]byte)
}</span>

// TestableAPIGatewayClient is a configurable mock for complex test scenarios.
// This provides more control than the testify mock for simulating various conditions.
type TestableAPIGatewayClient struct {
        mu          sync.Mutex
        connections map[string]*ConnectionInfo
        messages    map[string][][]byte
        errors      map[string]error // connectionID -&gt; error to return
        latency     time.Duration
        failureRate float32
}

// NewTestableAPIGatewayClient creates a new testable client
func NewTestableAPIGatewayClient() *TestableAPIGatewayClient <span class="cov4" title="4">{
        return &amp;TestableAPIGatewayClient{
                connections: make(map[string]*ConnectionInfo),
                messages:    make(map[string][][]byte),
                errors:      make(map[string]error),
        }
}</span>

func (t *TestableAPIGatewayClient) PostToConnection(ctx context.Context, connectionID string, data []byte) error <span class="cov8" title="16">{
        if t.latency &gt; 0 </span><span class="cov1" title="1">{
                select </span>{
                case &lt;-time.After(t.latency):<span class="cov1" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                }
        }

        <span class="cov8" title="16">t.mu.Lock()
        defer t.mu.Unlock()

        if err, exists := t.errors[connectionID]; exists </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov8" title="14">if _, exists := t.connections[connectionID]; !exists </span><span class="cov1" title="1">{
                return GoneError{
                        ConnectionID: connectionID,
                        Message:      "connection does not exist",
                }
        }</span>

        <span class="cov8" title="13">t.messages[connectionID] = append(t.messages[connectionID], data)
        return nil</span>
}

func (t *TestableAPIGatewayClient) DeleteConnection(ctx context.Context, connectionID string) error <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if _, exists := t.connections[connectionID]; !exists </span><span class="cov0" title="0">{
                return GoneError{
                        ConnectionID: connectionID,
                        Message:      "connection does not exist",
                }
        }</span>

        <span class="cov0" title="0">delete(t.connections, connectionID)
        delete(t.messages, connectionID)
        return nil</span>
}

func (t *TestableAPIGatewayClient) GetConnection(ctx context.Context, connectionID string) (*ConnectionInfo, error) <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()

        info, exists := t.connections[connectionID]
        if !exists </span><span class="cov0" title="0">{
                return nil, GoneError{
                        ConnectionID: connectionID,
                        Message:      "connection does not exist",
                }
        }</span>

        <span class="cov0" title="0">return &amp;ConnectionInfo{
                ConnectionID: info.ConnectionID,
                ConnectedAt:  info.ConnectedAt,
                LastActiveAt: time.Now().Format(time.RFC3339),
                SourceIP:     info.SourceIP,
                UserAgent:    info.UserAgent,
        }, nil</span>
}

// Configuration methods
func (t *TestableAPIGatewayClient) AddConnection(id string, sourceIP string) <span class="cov8" title="13">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.connections[id] = &amp;ConnectionInfo{
                ConnectionID: id,
                ConnectedAt:  time.Now().Format(time.RFC3339),
                LastActiveAt: time.Now().Format(time.RFC3339),
                SourceIP:     sourceIP,
                UserAgent:    "test-agent",
        }
}</span>

func (t *TestableAPIGatewayClient) SetError(connectionID string, err error) <span class="cov2" title="2">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.errors[connectionID] = err
}</span>

func (t *TestableAPIGatewayClient) SimulateGoneError(connectionID string) <span class="cov0" title="0">{
        t.SetError(connectionID, GoneError{
                ConnectionID: connectionID,
                Message:      fmt.Sprintf("Connection %s is gone", connectionID),
        })
}</span>

func (t *TestableAPIGatewayClient) SimulateThrottling(connectionID string, retryAfter int) <span class="cov0" title="0">{
        t.SetError(connectionID, ThrottlingError{
                ConnectionID: connectionID,
                RetryAfter:   retryAfter,
                Message:      "Rate limit exceeded",
        })
}</span>

func (t *TestableAPIGatewayClient) SetLatency(d time.Duration) <span class="cov1" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.latency = d
}</span>

func (t *TestableAPIGatewayClient) GetMessages(connectionID string) [][]byte <span class="cov7" title="12">{
        t.mu.Lock()
        defer t.mu.Unlock()
        return append([][]byte{}, t.messages[connectionID]...)
}</span>

func (t *TestableAPIGatewayClient) GetMessageCount(connectionID string) int <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        return len(t.messages[connectionID])
}</span>

func (t *TestableAPIGatewayClient) Clear() <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.connections = make(map[string]*ConnectionInfo)
        t.messages = make(map[string][][]byte)
        t.errors = make(map[string]error)
        t.latency = 0
        t.failureRate = 0
}</span>

// Interface compliance checks
var (
        _ ConnectionManager = (*MockConnectionManager)(nil)
        _ ConnectionManager = (*MockConnectionManagerTestify)(nil)
        _ APIGatewayClient  = (*MockAPIGatewayClient)(nil)
        _ APIGatewayClient  = (*TestableAPIGatewayClient)(nil)
)
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package connection provides testing utilities for connection management.
//
// These mocks are designed to work with any interface that has Send/IsActive methods,
// making them usable across different packages that define their own ConnectionManager interfaces.
package connection

import (
        "context"
        "sync"
)

// SendOnlyMock implements just the Send method, suitable for packages that only need Send.
// This works with pkg/streamer's ConnectionManager interface.
type SendOnlyMock struct {
        // SendFunc allows custom behavior for Send method
        SendFunc func(ctx context.Context, connectionID string, message interface{}) error

        // Messages stores all sent messages for verification
        Messages map[string][]interface{}
        mu       sync.Mutex
}

// NewSendOnlyMock creates a mock that only implements Send
func NewSendOnlyMock() *SendOnlyMock <span class="cov1" title="1">{
        return &amp;SendOnlyMock{
                Messages: make(map[string][]interface{}),
        }
}</span>

// Send implements the minimal ConnectionManager.Send method
func (m *SendOnlyMock) Send(ctx context.Context, connectionID string, message interface{}) error <span class="cov10" title="5">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.SendFunc != nil </span><span class="cov1" title="1">{
                return m.SendFunc(ctx, connectionID, message)
        }</span>

        // Default behavior: store the message
        <span class="cov8" title="4">m.Messages[connectionID] = append(m.Messages[connectionID], message)
        return nil</span>
}

// GetMessages returns all messages sent to a connection (thread-safe)
func (m *SendOnlyMock) GetMessages(connectionID string) []interface{} <span class="cov10" title="5">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return append([]interface{}{}, m.Messages[connectionID]...)
}</span>

// Reset clears all stored messages
func (m *SendOnlyMock) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.Messages = make(map[string][]interface{})
}</span>

// ProgressReporterMock implements Send and IsActive for pkg/progress
type ProgressReporterMock struct {
        SendOnlyMock // Embed for Send functionality

        // IsActiveFunc allows custom behavior for IsActive
        IsActiveFunc func(ctx context.Context, connectionID string) bool

        // ActiveConnections tracks which connections are active
        ActiveConnections map[string]bool
}

// NewProgressReporterMock creates a mock suitable for progress reporting
func NewProgressReporterMock() *ProgressReporterMock <span class="cov7" title="3">{
        return &amp;ProgressReporterMock{
                SendOnlyMock:      SendOnlyMock{Messages: make(map[string][]interface{})},
                ActiveConnections: make(map[string]bool),
        }
}</span>

// IsActive implements the IsActive method needed by pkg/progress
func (m *ProgressReporterMock) IsActive(ctx context.Context, connectionID string) bool <span class="cov8" title="4">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.IsActiveFunc != nil </span><span class="cov1" title="1">{
                return m.IsActiveFunc(ctx, connectionID)
        }</span>

        // Default behavior: check ActiveConnections map
        <span class="cov7" title="3">return m.ActiveConnections[connectionID]</span>
}

// SetActive sets a connection's active status
func (m *ProgressReporterMock) SetActive(connectionID string, active bool) <span class="cov7" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.ActiveConnections[connectionID] = active
}</span>

// TestifyMock is a minimal testify-based mock for simple cases
type TestifyMock struct {
        mock interface {
                Called(arguments ...interface{}) interface {
                        Error(int) error
                        Bool(int) bool
                        Get(int) interface{}
                }
        }
}

// Send for testify mocks
func (m *TestifyMock) Send(ctx context.Context, connectionID string, message interface{}) error <span class="cov0" title="0">{
        args := m.mock.Called(ctx, connectionID, message)
        return args.Error(0)
}</span>

// IsActive for testify mocks (if needed)
func (m *TestifyMock) IsActive(ctx context.Context, connectionID string) bool <span class="cov0" title="0">{
        args := m.mock.Called(ctx, connectionID)
        return args.Bool(0)
}</span>

// RecordingMock provides detailed recording of all method calls
type RecordingMock struct {
        SendOnlyMock
        IsActiveCalls []string // Track IsActive calls

        // Override for IsActive
        IsActiveFunc func(ctx context.Context, connectionID string) bool
}

// NewRecordingMock creates a mock that records all interactions
func NewRecordingMock() *RecordingMock <span class="cov1" title="1">{
        return &amp;RecordingMock{
                SendOnlyMock:  SendOnlyMock{Messages: make(map[string][]interface{})},
                IsActiveCalls: make([]string, 0),
        }
}</span>

// IsActive records the call and returns result
func (m *RecordingMock) IsActive(ctx context.Context, connectionID string) bool <span class="cov7" title="3">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.IsActiveCalls = append(m.IsActiveCalls, connectionID)

        if m.IsActiveFunc != nil </span><span class="cov0" title="0">{
                return m.IsActiveFunc(ctx, connectionID)
        }</span>
        <span class="cov7" title="3">return true</span> // Default to active
}

// GetIsActiveCalls returns all IsActive calls
func (m *RecordingMock) GetIsActiveCalls() []string <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return append([]string{}, m.IsActiveCalls...)
}</span>

// FailingMock always returns errors - useful for error handling tests
type FailingMock struct {
        Error error
}

// NewFailingMock creates a mock that always fails
func NewFailingMock(err error) *FailingMock <span class="cov4" title="2">{
        return &amp;FailingMock{Error: err}
}</span>

// Send always returns the configured error
func (m *FailingMock) Send(ctx context.Context, connectionID string, message interface{}) error <span class="cov4" title="2">{
        return m.Error
}</span>

// IsActive always returns false
func (m *FailingMock) IsActive(ctx context.Context, connectionID string) bool <span class="cov1" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package progress

import (
        "context"
        "sync"
        "time"
)

// Update represents a single progress update
type Update struct {
        RequestID  string
        Percentage float64
        Message    string
        Metadata   map[string]interface{}
        Error      error
        Timestamp  time.Time
}

// Batcher batches progress updates to reduce WebSocket message volume
type Batcher struct {
        reporter       Reporter
        updates        chan *Update
        interval       time.Duration
        maxBatch       int
        flushThreshold float64 // Percentage threshold for immediate flush
        mu             sync.Mutex
        shutdownCh     chan struct{}
        wg             sync.WaitGroup
}

// NewBatcher creates a new progress update batcher
func NewBatcher(reporter Reporter, opts ...BatcherOption) *Batcher <span class="cov5" title="14">{
        b := &amp;Batcher{
                reporter:       reporter,
                updates:        make(chan *Update, 100),
                interval:       100 * time.Millisecond,
                maxBatch:       10,
                flushThreshold: 95.0, // Flush immediately at 95% or higher
                shutdownCh:     make(chan struct{}),
        }

        // Apply options
        for _, opt := range opts </span><span class="cov5" title="16">{
                opt(b)
        }</span>

        // Start the batching goroutine
        <span class="cov5" title="14">b.wg.Add(1)
        go b.run()

        return b</span>
}

// BatcherOption configures the batcher
type BatcherOption func(*Batcher)

// WithInterval sets the batch interval
func WithInterval(interval time.Duration) BatcherOption <span class="cov5" title="11">{
        return func(b *Batcher) </span><span class="cov5" title="11">{
                b.interval = interval
        }</span>
}

// WithMaxBatch sets the maximum batch size
func WithMaxBatch(max int) BatcherOption <span class="cov2" title="3">{
        return func(b *Batcher) </span><span class="cov2" title="3">{
                b.maxBatch = max
        }</span>
}

// WithFlushThreshold sets the percentage threshold for immediate flush
func WithFlushThreshold(threshold float64) BatcherOption <span class="cov2" title="2">{
        return func(b *Batcher) </span><span class="cov2" title="2">{
                b.flushThreshold = threshold
        }</span>
}

// Report adds an update to the batch
func (b *Batcher) Report(percentage float64, message string) error <span class="cov10" title="218">{
        update := &amp;Update{
                Percentage: percentage,
                Message:    message,
                Timestamp:  time.Now(),
        }

        select </span>{
        case b.updates &lt;- update:<span class="cov9" title="217">
                return nil</span>
        case &lt;-b.shutdownCh:<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov1" title="1">
                // Channel full, drop oldest update
                select </span>{
                case &lt;-b.updates:<span class="cov1" title="1"></span>
                        // Dropped oldest
                default:<span class="cov0" title="0"></span>
                }
                // Try again
                <span class="cov1" title="1">select </span>{
                case b.updates &lt;- update:<span class="cov1" title="1">
                        return nil</span>
                default:<span class="cov0" title="0">
                        // Still full, skip this update
                        return nil</span>
                }
        }
}

// SetMetadata sets metadata for future updates
func (b *Batcher) SetMetadata(key string, value interface{}) error <span class="cov5" title="12">{
        return b.reporter.SetMetadata(key, value)
}</span>

// Complete flushes any pending updates and marks as complete
func (b *Batcher) Complete(result interface{}) error <span class="cov1" title="1">{
        // Send 100% progress first
        b.Report(100, "Processing complete")

        // Wait a bit for the batch to flush
        time.Sleep(b.interval * 2)

        return b.reporter.Complete(result)
}</span>

// Fail flushes any pending updates and marks as failed
func (b *Batcher) Fail(err error) error <span class="cov1" title="1">{
        // Flush any pending updates by signaling error
        update := &amp;Update{
                Error:     err,
                Timestamp: time.Now(),
        }

        select </span>{
        case b.updates &lt;- update:<span class="cov1" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }

        // Wait a bit for the batch to flush
        <span class="cov1" title="1">time.Sleep(b.interval * 2)

        return b.reporter.Fail(err)</span>
}

// Shutdown gracefully shuts down the batcher
func (b *Batcher) Shutdown(ctx context.Context) error <span class="cov5" title="14">{
        close(b.shutdownCh)

        // Wait for run goroutine to finish
        done := make(chan struct{})
        go func() </span><span class="cov5" title="14">{
                b.wg.Wait()
                close(done)
        }</span>()

        <span class="cov5" title="14">select </span>{
        case &lt;-done:<span class="cov5" title="13">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return ctx.Err()</span>
        }
}

// run is the main batching loop
func (b *Batcher) run() <span class="cov5" title="14">{
        defer b.wg.Done()

        ticker := time.NewTicker(b.interval)
        defer ticker.Stop()

        batch := make([]*Update, 0, b.maxBatch)

        for </span><span class="cov9" title="150">{
                select </span>{
                case update := &lt;-b.updates:<span class="cov9" title="122">
                        batch = append(batch, update)

                        // Check if we should flush immediately
                        shouldFlush := false

                        // Flush on error
                        if update.Error != nil </span><span class="cov1" title="1">{
                                shouldFlush = true
                        }</span>

                        // Flush on high percentage
                        <span class="cov9" title="122">if update.Percentage &gt;= b.flushThreshold </span><span class="cov4" title="7">{
                                shouldFlush = true
                        }</span>

                        // Flush if batch is full
                        <span class="cov9" title="122">if len(batch) &gt;= b.maxBatch </span><span class="cov5" title="11">{
                                shouldFlush = true
                        }</span>

                        <span class="cov9" title="122">if shouldFlush </span><span class="cov5" title="19">{
                                b.flush(batch)
                                batch = batch[:0]
                        }</span>

                case &lt;-ticker.C:<span class="cov5" title="14">
                        if len(batch) &gt; 0 </span><span class="cov2" title="2">{
                                b.flush(batch)
                                batch = batch[:0]
                        }</span>

                case &lt;-b.shutdownCh:<span class="cov5" title="14">
                        // Flush any remaining updates
                        if len(batch) &gt; 0 </span><span class="cov1" title="1">{
                                b.flush(batch)
                        }</span>
                        <span class="cov5" title="14">return</span>
                }
        }
}

// flush sends batched updates
func (b *Batcher) flush(updates []*Update) <span class="cov6" title="22">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Combine updates intelligently
        <span class="cov6" title="22">combined := b.combineUpdates(updates)

        // Send combined updates
        for _, update := range combined </span><span class="cov7" title="38">{
                if update.Error != nil </span><span class="cov1" title="1">{
                        // Don't report error updates as progress
                        continue</span>
                }
                <span class="cov7" title="37">b.reporter.Report(update.Percentage, update.Message)</span>
        }
}

// combineUpdates intelligently combines multiple updates
func (b *Batcher) combineUpdates(updates []*Update) []*Update <span class="cov6" title="26">{
        if len(updates) &lt;= 1 </span><span class="cov4" title="8">{
                return updates
        }</span>

        // If we have many updates, we want to:
        // 1. Always include the first update (shows initial progress)
        // 2. Always include the last update (most recent state)
        // 3. Include any error updates
        // 4. Include significant percentage jumps

        <span class="cov5" title="18">result := make([]*Update, 0, len(updates))

        // Always include first
        result = append(result, updates[0])
        lastPercentage := updates[0].Percentage

        // Process middle updates
        for i := 1; i &lt; len(updates)-1; i++ </span><span class="cov8" title="92">{
                update := updates[i]

                // Include errors
                if update.Error != nil </span><span class="cov1" title="1">{
                        result = append(result, update)
                        continue</span>
                }

                // Include significant jumps (&gt;10%)
                <span class="cov8" title="91">if update.Percentage-lastPercentage &gt;= 10.0 </span><span class="cov3" title="4">{
                        result = append(result, update)
                        lastPercentage = update.Percentage
                }</span>
        }

        // Always include last if different from what we have
        <span class="cov5" title="18">lastUpdate := updates[len(updates)-1]
        if len(result) == 0 ||
                lastUpdate.Percentage != result[len(result)-1].Percentage ||
                lastUpdate.Message != result[len(result)-1].Message </span><span class="cov5" title="18">{
                result = append(result, lastUpdate)
        }</span>

        <span class="cov5" title="18">return result</span>
}

// BatchedReporter wraps a Reporter with batching capabilities
type BatchedReporter struct {
        *Batcher
}

// NewBatchedReporter creates a new batched reporter
func NewBatchedReporter(requestID, connectionID string, connManager ConnectionManager, opts ...BatcherOption) *BatchedReporter <span class="cov1" title="1">{
        reporter := NewReporter(requestID, connectionID, connManager)
        batcher := NewBatcher(reporter, opts...)

        return &amp;BatchedReporter{
                Batcher: batcher,
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package progress

import (
        "context"
        "log"
        "sync"
        "time"
)

// Reporter provides progress reporting functionality for async requests
type Reporter interface {
        // Report sends a progress update with percentage and message
        Report(percentage float64, message string) error

        // SetMetadata adds metadata to the progress update
        SetMetadata(key string, value interface{}) error

        // Complete marks the request as complete with the result
        Complete(result interface{}) error

        // Fail marks the request as failed with an error
        Fail(err error) error
}

// ConnectionManager interface for sending WebSocket messages
type ConnectionManager interface {
        Send(ctx context.Context, connectionID string, message interface{}) error
        IsActive(ctx context.Context, connectionID string) bool
}

// DefaultReporter implements the Reporter interface
type DefaultReporter struct {
        requestID      string
        connectionID   string
        connManager    ConnectionManager
        metadata       map[string]interface{}
        lastUpdate     time.Time
        updateInterval time.Duration
        mu             sync.Mutex
}

// NewReporter creates a new progress reporter
func NewReporter(requestID, connectionID string, connManager ConnectionManager) *DefaultReporter <span class="cov9" title="16">{
        return &amp;DefaultReporter{
                requestID:      requestID,
                connectionID:   connectionID,
                connManager:    connManager,
                metadata:       make(map[string]interface{}),
                updateInterval: 100 * time.Millisecond, // Batch updates every 100ms
        }
}</span>

// Report sends a progress update
func (r *DefaultReporter) Report(percentage float64, message string) error <span class="cov10" title="21">{
        r.mu.Lock()
        defer r.mu.Unlock()

        // Rate limit updates
        if time.Since(r.lastUpdate) &lt; r.updateInterval &amp;&amp; percentage &lt; 100 </span><span class="cov8" title="11">{
                return nil
        }</span>

        // Check if connection is still active
        <span class="cov7" title="10">ctx := context.Background()
        if !r.connManager.IsActive(ctx, r.connectionID) </span><span class="cov1" title="1">{
                log.Printf("[Progress] Connection %s no longer active for request %s", r.connectionID, r.requestID)
                return nil // Don't fail the whole process
        }</span>

        <span class="cov7" title="9">update := map[string]interface{}{
                "type":       "progress",
                "request_id": r.requestID,
                "percentage": percentage,
                "message":    message,
                "timestamp":  time.Now().Unix(),
        }

        if len(r.metadata) &gt; 0 </span><span class="cov1" title="1">{
                update["metadata"] = r.metadata
        }</span>

        // Log the message being sent for debugging
        <span class="cov7" title="9">log.Printf("[Progress] Sending update for request %s: %.0f%% - %s", r.requestID, percentage, message)

        // Send via connection manager
        err := r.connManager.Send(ctx, r.connectionID, update)
        if err != nil </span><span class="cov1" title="1">{
                log.Printf("[Progress] Failed to send update for request %s: %v", r.requestID, err)
                // Don't return error to avoid failing the whole process
                return nil
        }</span>

        <span class="cov7" title="8">r.lastUpdate = time.Now()
        return nil</span>
}

// SetMetadata adds metadata to future progress updates
func (r *DefaultReporter) SetMetadata(key string, value interface{}) error <span class="cov8" title="12">{
        r.mu.Lock()
        defer r.mu.Unlock()

        r.metadata[key] = value
        return nil
}</span>

// Complete sends a completion notification
func (r *DefaultReporter) Complete(result interface{}) error <span class="cov4" title="3">{
        completion := map[string]interface{}{
                "type":       "complete",
                "request_id": r.requestID,
                "result":     result,
                "timestamp":  time.Now().Unix(),
        }

        ctx := context.Background()
        return r.connManager.Send(ctx, r.connectionID, completion)
}</span>

// Fail sends a failure notification
func (r *DefaultReporter) Fail(err error) error <span class="cov3" title="2">{
        failure := map[string]interface{}{
                "type":       "error",
                "request_id": r.requestID,
                "error": map[string]interface{}{
                        "message": err.Error(),
                        "code":    "PROCESSING_FAILED",
                },
                "timestamp": time.Now().Unix(),
        }

        ctx := context.Background()
        return r.connManager.Send(ctx, r.connectionID, failure)
}</span>

// contextKey is the type for context keys
type contextKey string

const reporterKey contextKey = "progress_reporter"

// WithReporter adds a progress reporter to the context
func WithReporter(ctx context.Context, reporter Reporter) context.Context <span class="cov3" title="2">{
        return context.WithValue(ctx, reporterKey, reporter)
}</span>

// FromContext retrieves the progress reporter from context
func FromContext(ctx context.Context) (Reporter, bool) <span class="cov5" title="4">{
        reporter, ok := ctx.Value(reporterKey).(Reporter)
        return reporter, ok
}</span>

// ReportProgress is a helper function to report progress from within handlers
func ReportProgress(ctx context.Context, percentage float64, message string) error <span class="cov3" title="2">{
        reporter, ok := FromContext(ctx)
        if !ok </span><span class="cov1" title="1">{
                // No reporter in context, silently ignore
                return nil
        }</span>
        <span class="cov1" title="1">return reporter.Report(percentage, message)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package streamer

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "time"

        "github.com/pay-theory/streamer/internal/store"
)

// RequestQueueAdapter adapts Team 1's RequestQueue to our RequestStore interface
type RequestQueueAdapter struct {
        queue store.RequestQueue
}

// NewRequestQueueAdapter creates a new adapter instance
func NewRequestQueueAdapter(queue store.RequestQueue) RequestStore <span class="cov4" title="3">{
        return &amp;RequestQueueAdapter{queue: queue}
}</span>

// Enqueue converts our Request to store.AsyncRequest and enqueues it
func (a *RequestQueueAdapter) Enqueue(ctx context.Context, request *Request) error <span class="cov4" title="3">{
        // Convert router.Request to store.AsyncRequest
        asyncReq := &amp;store.AsyncRequest{
                RequestID:    request.ID,
                ConnectionID: request.ConnectionID,
                Action:       request.Action,
                Status:       store.StatusPending,
                Payload:      make(map[string]interface{}),
                CreatedAt:    request.CreatedAt,
                Progress:     0,
                RetryCount:   0,
                MaxRetries:   3,                                         // Default retry count
                TTL:          time.Now().Add(7 * 24 * time.Hour).Unix(), // 7 days TTL
        }

        // Convert payload from json.RawMessage to map[string]interface{}
        if len(request.Payload) &gt; 0 </span><span class="cov3" title="2">{
                if err := json.Unmarshal(request.Payload, &amp;asyncReq.Payload); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("failed to unmarshal payload: %w", err)
                }</span>
        }

        // Add metadata to payload to preserve it
        <span class="cov3" title="2">if len(request.Metadata) &gt; 0 </span><span class="cov1" title="1">{
                asyncReq.Payload["_metadata"] = request.Metadata
        }</span>

        // Extract UserID and TenantID from request metadata if available
        <span class="cov3" title="2">if userID, ok := request.Metadata["user_id"]; ok </span><span class="cov1" title="1">{
                asyncReq.UserID = userID
        }</span>
        <span class="cov3" title="2">if tenantID, ok := request.Metadata["tenant_id"]; ok </span><span class="cov1" title="1">{
                asyncReq.TenantID = tenantID
        }</span>

        // Map error if enqueue fails
        <span class="cov3" title="2">if err := a.queue.Enqueue(ctx, asyncReq); err != nil </span><span class="cov0" title="0">{
                return mapStoreError(err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// ConvertAsyncRequestToRequest converts a store.AsyncRequest back to a Request
func ConvertAsyncRequestToRequest(asyncReq *store.AsyncRequest) (*Request, error) <span class="cov4" title="3">{
        request := &amp;Request{
                ID:           asyncReq.RequestID,
                ConnectionID: asyncReq.ConnectionID,
                Action:       asyncReq.Action,
                CreatedAt:    asyncReq.CreatedAt,
                Metadata:     make(map[string]string),
        }

        // Extract metadata from payload if it exists
        if metadata, ok := asyncReq.Payload["_metadata"].(map[string]interface{}); ok </span><span class="cov1" title="1">{
                for k, v := range metadata </span><span class="cov3" title="2">{
                        if str, ok := v.(string); ok </span><span class="cov3" title="2">{
                                request.Metadata[k] = str
                        }</span>
                }
                // Remove _metadata from payload before marshaling
                <span class="cov1" title="1">delete(asyncReq.Payload, "_metadata")</span>
        }

        // Add user and tenant IDs to metadata if they exist
        <span class="cov4" title="3">if asyncReq.UserID != "" </span><span class="cov3" title="2">{
                request.Metadata["user_id"] = asyncReq.UserID
        }</span>
        <span class="cov4" title="3">if asyncReq.TenantID != "" </span><span class="cov3" title="2">{
                request.Metadata["tenant_id"] = asyncReq.TenantID
        }</span>

        // Convert payload back to json.RawMessage
        <span class="cov4" title="3">if len(asyncReq.Payload) &gt; 0 </span><span class="cov4" title="3">{
                payloadBytes, err := json.Marshal(asyncReq.Payload)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal payload: %w", err)
                }</span>
                <span class="cov4" title="3">request.Payload = payloadBytes</span>
        }

        <span class="cov4" title="3">return request, nil</span>
}

// mapStoreError maps storage errors to streamer errors
func mapStoreError(err error) error <span class="cov10" title="14">{
        if err == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Check for specific store errors
        <span class="cov9" title="13">if store.IsNotFound(err) </span><span class="cov7" title="6">{
                return NewError(ErrCodeNotFound, "Request not found")
        }</span>

        <span class="cov7" title="7">if store.IsAlreadyExists(err) </span><span class="cov1" title="1">{
                return NewError(ErrCodeValidation, "Request already exists")
        }</span>

        // Check for validation errors
        <span class="cov7" title="6">var validationErr *store.ValidationError
        if errors.As(err, &amp;validationErr) </span><span class="cov1" title="1">{
                return NewError(ErrCodeValidation, validationErr.Error())
        }</span>

        // Default to internal error
        <span class="cov6" title="5">return NewError(ErrCodeInternalError, fmt.Sprintf("Storage error: %v", err))</span>
}

// GetAsyncRequest retrieves an async request and converts it to Request
func (a *RequestQueueAdapter) GetAsyncRequest(ctx context.Context, requestID string) (*Request, error) <span class="cov4" title="3">{
        asyncReq, err := a.queue.Get(ctx, requestID)
        if err != nil </span><span class="cov3" title="2">{
                return nil, mapStoreError(err)
        }</span>

        <span class="cov1" title="1">return ConvertAsyncRequestToRequest(asyncReq)</span>
}

// UpdateProgress updates the progress of an async request
func (a *RequestQueueAdapter) UpdateProgress(ctx context.Context, requestID string, progress float64, message string) error <span class="cov4" title="3">{
        details := map[string]interface{}{
                "timestamp": time.Now().Unix(),
        }

        if err := a.queue.UpdateProgress(ctx, requestID, progress, message, details); err != nil </span><span class="cov3" title="2">{
                return mapStoreError(err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// CompleteRequest marks a request as completed
func (a *RequestQueueAdapter) CompleteRequest(ctx context.Context, requestID string, result *Result) error <span class="cov5" title="4">{
        resultMap := map[string]interface{}{
                "success": result.Success,
                "data":    result.Data,
        }

        if result.Error != nil </span><span class="cov1" title="1">{
                resultMap["error"] = map[string]interface{}{
                        "code":    result.Error.Code,
                        "message": result.Error.Message,
                        "details": result.Error.Details,
                }
        }</span>

        <span class="cov5" title="4">if len(result.Metadata) &gt; 0 </span><span class="cov1" title="1">{
                resultMap["metadata"] = result.Metadata
        }</span>

        <span class="cov5" title="4">if err := a.queue.CompleteRequest(ctx, requestID, resultMap); err != nil </span><span class="cov3" title="2">{
                return mapStoreError(err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// FailRequest marks a request as failed
func (a *RequestQueueAdapter) FailRequest(ctx context.Context, requestID string, err error) error <span class="cov5" title="4">{
        var errMsg string
        if streamerErr, ok := err.(*Error); ok </span><span class="cov1" title="1">{
                errMsg = fmt.Sprintf("[%s] %s", streamerErr.Code, streamerErr.Message)
        }</span> else<span class="cov4" title="3"> {
                errMsg = err.Error()
        }</span>

        <span class="cov5" title="4">if err := a.queue.FailRequest(ctx, requestID, errMsg); err != nil </span><span class="cov3" title="2">{
                return mapStoreError(err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package streamer

import (
        "context"
        "encoding/json"
        "fmt"
        "time"
)

// BaseHandler provides common functionality for handlers
type BaseHandler struct {
        estimatedDuration time.Duration
        validator         func(*Request) error
}

// EstimatedDuration returns the expected processing time
func (h *BaseHandler) EstimatedDuration() time.Duration <span class="cov7" title="8">{
        return h.estimatedDuration
}</span>

// Validate validates the request
func (h *BaseHandler) Validate(req *Request) error <span class="cov10" title="16">{
        if h.validator != nil </span><span class="cov9" title="13">{
                return h.validator(req)
        }</span>
        <span class="cov4" title="3">return nil</span>
}

// HandlerFunc is an adapter to allow the use of ordinary functions as handlers
type HandlerFunc struct {
        BaseHandler
        ProcessFunc func(context.Context, *Request) (*Result, error)
}

// Process executes the handler function
func (h *HandlerFunc) Process(ctx context.Context, req *Request) (*Result, error) <span class="cov8" title="9">{
        return h.ProcessFunc(ctx, req)
}</span>

// NewHandlerFunc creates a new handler from a function
func NewHandlerFunc(
        processFunc func(context.Context, *Request) (*Result, error),
        estimatedDuration time.Duration,
        validator func(*Request) error,
) Handler <span class="cov7" title="7">{
        return &amp;HandlerFunc{
                BaseHandler: BaseHandler{
                        estimatedDuration: estimatedDuration,
                        validator:         validator,
                },
                ProcessFunc: processFunc,
        }
}</span>

// SimpleHandler creates a simple handler with minimal configuration
func SimpleHandler(name string, processFunc func(context.Context, *Request) (*Result, error)) Handler <span class="cov1" title="1">{
        return NewHandlerFunc(processFunc, 100*time.Millisecond, nil)
}</span>

// Example handlers for testing and demonstration

// EchoHandler echoes back the request payload
type EchoHandler struct {
        BaseHandler
}

// NewEchoHandler creates a new echo handler
func NewEchoHandler() *EchoHandler <span class="cov1" title="1">{
        return &amp;EchoHandler{
                BaseHandler: BaseHandler{
                        estimatedDuration: 10 * time.Millisecond,
                },
        }
}</span>

// Process echoes the request payload
func (h *EchoHandler) Process(ctx context.Context, req *Request) (*Result, error) <span class="cov4" title="3">{
        var payload interface{}
        if req.Payload != nil </span><span class="cov3" title="2">{
                if err := json.Unmarshal(req.Payload, &amp;payload); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal payload: %w", err)
                }</span>
        }

        <span class="cov3" title="2">return &amp;Result{
                RequestID: req.ID,
                Success:   true,
                Data: map[string]interface{}{
                        "echo":        payload,
                        "action":      req.Action,
                        "received_at": time.Now().Format(time.RFC3339),
                },
        }, nil</span>
}

// DelayHandler simulates a long-running operation
type DelayHandler struct {
        BaseHandler
        delay time.Duration
}

// NewDelayHandler creates a new delay handler
func NewDelayHandler(delay time.Duration) *DelayHandler <span class="cov6" title="6">{
        return &amp;DelayHandler{
                BaseHandler: BaseHandler{
                        estimatedDuration: delay,
                },
                delay: delay,
        }
}</span>

// Process simulates processing with a delay
func (h *DelayHandler) Process(ctx context.Context, req *Request) (*Result, error) <span class="cov3" title="2">{
        select </span>{
        case &lt;-time.After(h.delay):<span class="cov1" title="1">
                return &amp;Result{
                        RequestID: req.ID,
                        Success:   true,
                        Data: map[string]interface{}{
                                "message":  "Operation completed",
                                "duration": h.delay.String(),
                        },
                }, nil</span>
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return nil, ctx.Err()</span>
        }
}

// ProcessWithProgress implements processing with progress updates
func (h *DelayHandler) ProcessWithProgress(ctx context.Context, req *Request, reporter ProgressReporter) (*Result, error) <span class="cov4" title="3">{
        steps := 10
        stepDuration := h.delay / time.Duration(steps)

        for i := 1; i &lt;= steps; i++ </span><span class="cov9" title="14">{
                select </span>{
                case &lt;-time.After(stepDuration):<span class="cov9" title="13">
                        percentage := float64(i) / float64(steps) * 100
                        if err := reporter.Report(percentage, fmt.Sprintf("Step %d of %d completed", i, steps)); err != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("failed to report progress: %w", err)
                        }</span>
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return nil, ctx.Err()</span>
                }
        }

        <span class="cov1" title="1">return &amp;Result{
                RequestID: req.ID,
                Success:   true,
                Data: map[string]interface{}{
                        "message":  "Operation completed with progress tracking",
                        "duration": h.delay.String(),
                        "steps":    steps,
                },
        }, nil</span>
}

// ValidationExampleHandler demonstrates request validation
type ValidationExampleHandler struct {
        BaseHandler
}

// NewValidationExampleHandler creates a handler that validates specific payload fields
func NewValidationExampleHandler() *ValidationExampleHandler <span class="cov1" title="1">{
        handler := &amp;ValidationExampleHandler{
                BaseHandler: BaseHandler{
                        estimatedDuration: 50 * time.Millisecond,
                },
        }

        handler.validator = func(req *Request) error </span><span class="cov8" title="9">{
                if req.Payload == nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("payload is required")
                }</span>

                <span class="cov7" title="8">var payload map[string]interface{}
                if err := json.Unmarshal(req.Payload, &amp;payload); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid payload format: %w", err)
                }</span>

                // Validate required fields
                <span class="cov7" title="7">requiredFields := []string{"name", "email"}
                for _, field := range requiredFields </span><span class="cov9" title="12">{
                        if _, exists := payload[field]; !exists </span><span class="cov4" title="3">{
                                return fmt.Errorf("required field missing: %s", field)
                        }</span>
                }

                // Validate email format (simple check)
                <span class="cov5" title="4">if email, ok := payload["email"].(string); ok </span><span class="cov4" title="3">{
                        if len(email) &lt; 3 || len(email) &gt; 100 </span><span class="cov3" title="2">{
                                return fmt.Errorf("invalid email length")
                        }</span>
                } else<span class="cov1" title="1"> {
                        return fmt.Errorf("email must be a string")
                }</span>

                <span class="cov1" title="1">return nil</span>
        }

        <span class="cov1" title="1">return handler</span>
}

// Process handles the validated request
func (h *ValidationExampleHandler) Process(ctx context.Context, req *Request) (*Result, error) <span class="cov1" title="1">{
        var payload map[string]interface{}
        json.Unmarshal(req.Payload, &amp;payload)

        return &amp;Result{
                RequestID: req.ID,
                Success:   true,
                Data: map[string]interface{}{
                        "message": fmt.Sprintf("Hello, %s!", payload["name"]),
                        "email":   payload["email"],
                },
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package streamer

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/aws/aws-lambda-go/events"
)

// Router handles incoming WebSocket messages and routes them to appropriate handlers
type Router interface {
        // Handle registers a handler for a specific action
        Handle(action string, handler Handler) error

        // Route processes an incoming WebSocket event
        Route(ctx context.Context, event events.APIGatewayWebsocketProxyRequest) error

        // SetAsyncThreshold sets the duration threshold for async processing
        SetAsyncThreshold(duration time.Duration)

        // SetMiddleware adds middleware to the router
        SetMiddleware(middleware ...Middleware)
}

// Middleware defines a function that wraps handler execution
type Middleware func(Handler) Handler

// RequestStore defines the interface for storing async requests
type RequestStore interface {
        Enqueue(ctx context.Context, request *Request) error
}

// ConnectionManager defines the interface for managing WebSocket connections
type ConnectionManager interface {
        Send(ctx context.Context, connectionID string, message interface{}) error
}

// DefaultRouter implements the Router interface
type DefaultRouter struct {
        handlers       map[string]Handler
        asyncThreshold time.Duration
        requestStore   RequestStore
        connManager    ConnectionManager
        middlewares    []Middleware
        mu             sync.RWMutex
}

// NewRouter creates a new router instance
func NewRouter(store RequestStore, connManager ConnectionManager) *DefaultRouter <span class="cov10" title="17">{
        return &amp;DefaultRouter{
                handlers:       make(map[string]Handler),
                asyncThreshold: 5 * time.Second, // Default threshold
                requestStore:   store,
                connManager:    connManager,
                middlewares:    []Middleware{},
        }
}</span>

// Handle registers a handler for a specific action
func (r *DefaultRouter) Handle(action string, handler Handler) error <span class="cov8" title="12">{
        if action == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("action cannot be empty")
        }</span>
        <span class="cov8" title="11">if handler == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("handler cannot be nil")
        }</span>

        <span class="cov8" title="10">r.mu.Lock()
        defer r.mu.Unlock()

        if _, exists := r.handlers[action]; exists </span><span class="cov1" title="1">{
                return fmt.Errorf("handler already registered for action: %s", action)
        }</span>

        // Apply middlewares to the handler
        <span class="cov7" title="9">wrappedHandler := handler
        for i := len(r.middlewares) - 1; i &gt;= 0; i-- </span><span class="cov1" title="1">{
                wrappedHandler = r.middlewares[i](wrappedHandler)
        }</span>

        <span class="cov7" title="9">r.handlers[action] = wrappedHandler
        return nil</span>
}

// SetAsyncThreshold sets the duration threshold for async processing
func (r *DefaultRouter) SetAsyncThreshold(duration time.Duration) <span class="cov3" title="2">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.asyncThreshold = duration
}</span>

// SetMiddleware adds middleware to the router
func (r *DefaultRouter) SetMiddleware(middleware ...Middleware) <span class="cov4" title="3">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.middlewares = append(r.middlewares, middleware...)
}</span>

// Route processes an incoming WebSocket event
func (r *DefaultRouter) Route(ctx context.Context, event events.APIGatewayWebsocketProxyRequest) error <span class="cov7" title="9">{
        // Parse the incoming message
        var message map[string]interface{}
        if err := json.Unmarshal([]byte(event.Body), &amp;message); err != nil </span><span class="cov1" title="1">{
                return r.sendError(ctx, event.RequestContext.ConnectionID,
                        NewError(ErrCodeValidation, "Invalid message format"))
        }</span>

        // Extract action from message
        <span class="cov7" title="8">action, ok := message["action"].(string)
        if !ok || action == "" </span><span class="cov1" title="1">{
                return r.sendError(ctx, event.RequestContext.ConnectionID,
                        NewError(ErrCodeValidation, "Missing or invalid action"))
        }</span>

        // Create request object
        <span class="cov7" title="7">request := &amp;Request{
                ID:           generateRequestID(),
                ConnectionID: event.RequestContext.ConnectionID,
                Action:       action,
                CreatedAt:    time.Now(),
                Metadata:     make(map[string]string),
        }

        // Extract request ID if provided
        if id, ok := message["id"].(string); ok </span><span class="cov3" title="2">{
                request.ID = id
        }</span>

        // Extract metadata if provided
        <span class="cov7" title="7">if metadata, ok := message["metadata"].(map[string]interface{}); ok </span><span class="cov1" title="1">{
                for k, v := range metadata </span><span class="cov3" title="2">{
                        if str, ok := v.(string); ok </span><span class="cov3" title="2">{
                                request.Metadata[k] = str
                        }</span>
                }
        }

        // Extract payload
        <span class="cov7" title="7">if payload, exists := message["payload"]; exists </span><span class="cov1" title="1">{
                payloadBytes, err := json.Marshal(payload)
                if err != nil </span><span class="cov0" title="0">{
                        return r.sendError(ctx, event.RequestContext.ConnectionID,
                                NewError(ErrCodeValidation, "Invalid payload format"))
                }</span>
                <span class="cov1" title="1">request.Payload = payloadBytes</span>
        }

        // Get handler for action
        <span class="cov7" title="7">r.mu.RLock()
        handler, exists := r.handlers[action]
        r.mu.RUnlock()

        if !exists </span><span class="cov1" title="1">{
                return r.sendError(ctx, event.RequestContext.ConnectionID,
                        NewError(ErrCodeInvalidAction, fmt.Sprintf("Unknown action: %s", action)))
        }</span>

        // Validate request
        <span class="cov6" title="6">if err := handler.Validate(request); err != nil </span><span class="cov1" title="1">{
                return r.sendError(ctx, event.RequestContext.ConnectionID,
                        NewError(ErrCodeValidation, err.Error()))
        }</span>

        // Check if request should be processed async
        <span class="cov6" title="5">if handler.EstimatedDuration() &gt; r.asyncThreshold </span><span class="cov3" title="2">{
                // Queue for async processing
                if err := r.requestStore.Enqueue(ctx, request); err != nil </span><span class="cov1" title="1">{
                        return r.sendError(ctx, event.RequestContext.ConnectionID,
                                NewError(ErrCodeInternalError, "Failed to queue request"))
                }</span>

                // Send acknowledgment
                <span class="cov1" title="1">ack := map[string]interface{}{
                        "type":       "acknowledgment",
                        "request_id": request.ID,
                        "status":     "queued",
                        "message":    "Request queued for async processing",
                }
                return r.connManager.Send(ctx, event.RequestContext.ConnectionID, ack)</span>
        }

        // Process synchronously
        <span class="cov4" title="3">result, err := handler.Process(ctx, request)
        if err != nil </span><span class="cov1" title="1">{
                return r.sendError(ctx, event.RequestContext.ConnectionID,
                        NewError(ErrCodeInternalError, err.Error()))
        }</span>

        // Send response
        <span class="cov3" title="2">response := map[string]interface{}{
                "type":       "response",
                "request_id": request.ID,
                "success":    result.Success,
                "data":       result.Data,
        }
        if result.Error != nil </span><span class="cov0" title="0">{
                response["error"] = result.Error
        }</span>

        <span class="cov3" title="2">return r.connManager.Send(ctx, event.RequestContext.ConnectionID, response)</span>
}

// sendError sends an error response to the client
func (r *DefaultRouter) sendError(ctx context.Context, connectionID string, err *Error) error <span class="cov7" title="7">{
        response := map[string]interface{}{
                "type":  "error",
                "error": err,
        }
        return r.connManager.Send(ctx, connectionID, response)
}</span>

// generateRequestID generates a unique request ID
func generateRequestID() string <span class="cov7" title="9">{
        // In production, use a proper UUID generator
        return fmt.Sprintf("req_%d", time.Now().UnixNano())
}</span>

// LoggingMiddleware adds logging to handler execution
func LoggingMiddleware(logger func(format string, args ...interface{})) Middleware <span class="cov3" title="2">{
        return func(next Handler) Handler </span><span class="cov3" title="2">{
                return &amp;loggingHandler{
                        Handler: next,
                        logger:  logger,
                }
        }</span>
}

type loggingHandler struct {
        Handler
        logger func(format string, args ...interface{})
}

func (h *loggingHandler) Process(ctx context.Context, request *Request) (*Result, error) <span class="cov3" title="2">{
        start := time.Now()
        h.logger("Processing request: %s, action: %s", request.ID, request.Action)

        result, err := h.Handler.Process(ctx, request)

        duration := time.Since(start)
        if err != nil </span><span class="cov1" title="1">{
                h.logger("Request failed: %s, duration: %v, error: %v", request.ID, duration, err)
        }</span> else<span class="cov1" title="1"> {
                h.logger("Request completed: %s, duration: %v, success: %v", request.ID, duration, result.Success)
        }</span>

        <span class="cov3" title="2">return result, err</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package streamer provides the core interfaces and types for async request processing
package streamer

import (
        "context"
        "encoding/json"
        "time"
)

// Request represents an incoming request from a WebSocket connection
type Request struct {
        ID           string            `json:"id"`
        ConnectionID string            `json:"connection_id"`
        Action       string            `json:"action"`
        Payload      json.RawMessage   `json:"payload"`
        Metadata     map[string]string `json:"metadata,omitempty"`
        CreatedAt    time.Time         `json:"created_at"`
}

// Result represents the response from processing a request
type Result struct {
        RequestID string            `json:"request_id"`
        Success   bool              `json:"success"`
        Data      interface{}       `json:"data,omitempty"`
        Error     *Error            `json:"error,omitempty"`
        Metadata  map[string]string `json:"metadata,omitempty"`
}

// Error represents a structured error response
type Error struct {
        Code    string                 `json:"code"`
        Message string                 `json:"message"`
        Details map[string]interface{} `json:"details,omitempty"`
}

// ProgressUpdate represents a progress notification for async operations
type ProgressUpdate struct {
        RequestID  string                 `json:"request_id"`
        Percentage float64                `json:"percentage"`
        Message    string                 `json:"message"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
        Timestamp  time.Time              `json:"timestamp"`
}

// Handler defines the interface for request handlers
type Handler interface {
        // Validate checks if the request is valid
        Validate(request *Request) error

        // EstimatedDuration returns the expected processing time
        // Used to determine if the request should be processed sync or async
        EstimatedDuration() time.Duration

        // Process executes the handler logic
        Process(ctx context.Context, request *Request) (*Result, error)
}

// ProgressReporter allows handlers to report progress during async execution
type ProgressReporter interface {
        // Report sends a progress update
        Report(percentage float64, message string) error

        // SetMetadata adds metadata to the progress update
        SetMetadata(key string, value interface{}) error
}

// HandlerWithProgress extends Handler to support progress reporting
type HandlerWithProgress interface {
        Handler

        // ProcessWithProgress executes the handler with progress reporting capability
        ProcessWithProgress(ctx context.Context, request *Request, reporter ProgressReporter) (*Result, error)
}

// Common error codes
const (
        ErrCodeValidation    = "VALIDATION_ERROR"
        ErrCodeNotFound      = "NOT_FOUND"
        ErrCodeUnauthorized  = "UNAUTHORIZED"
        ErrCodeInternalError = "INTERNAL_ERROR"
        ErrCodeTimeout       = "TIMEOUT"
        ErrCodeRateLimited   = "RATE_LIMITED"
        ErrCodeInvalidAction = "INVALID_ACTION"
)

// NewError creates a new Error instance
func NewError(code, message string) *Error <span class="cov10" title="24">{
        return &amp;Error{
                Code:    code,
                Message: message,
                Details: make(map[string]interface{}),
        }
}</span>

// WithDetail adds a detail to the error
func (e *Error) WithDetail(key string, value interface{}) *Error <span class="cov8" title="15">{
        if e.Details == nil </span><span class="cov1" title="1">{
                e.Details = make(map[string]interface{})
        }</span>
        <span class="cov8" title="15">e.Details[key] = value
        return e</span>
}

// Error implements the error interface
func (e *Error) Error() string <span class="cov8" title="16">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package types defines shared message types for WebSocket communication
package types

import (
        "time"
)

// MessageType defines the type of WebSocket message
type MessageType string

const (
        // Request message types
        MessageTypeRequest MessageType = "request"

        // Response message types
        MessageTypeResponse       MessageType = "response"
        MessageTypeAcknowledgment MessageType = "acknowledgment"
        MessageTypeProgress       MessageType = "progress"
        MessageTypeError          MessageType = "error"

        // Control message types
        MessageTypePing MessageType = "ping"
        MessageTypePong MessageType = "pong"
)

// Message is the base structure for all WebSocket messages
type Message struct {
        Type      MessageType            `json:"type"`
        ID        string                 `json:"id,omitempty"`
        Timestamp int64                  `json:"timestamp"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// RequestMessage represents an incoming WebSocket request
type RequestMessage struct {
        Message
        Action  string                 `json:"action"`
        Payload map[string]interface{} `json:"payload,omitempty"`
}

// ResponseMessage represents a synchronous response
type ResponseMessage struct {
        Message
        RequestID string      `json:"request_id"`
        Success   bool        `json:"success"`
        Data      interface{} `json:"data,omitempty"`
        Error     *ErrorInfo  `json:"error,omitempty"`
}

// AcknowledgmentMessage is sent for async requests
type AcknowledgmentMessage struct {
        Message
        RequestID string `json:"request_id"`
        Status    string `json:"status"` // "queued", "processing"
        Text      string `json:"message,omitempty"`
}

// ProgressMessage represents async processing progress
type ProgressMessage struct {
        Message
        RequestID  string                 `json:"request_id"`
        Percentage float64                `json:"percentage"` // 0-100
        Text       string                 `json:"message,omitempty"`
        Details    map[string]interface{} `json:"details,omitempty"`
}

// ErrorMessage represents an error response
type ErrorMessage struct {
        Message
        RequestID string     `json:"request_id,omitempty"`
        Error     *ErrorInfo `json:"error"`
}

// ErrorInfo contains structured error information
type ErrorInfo struct {
        Code    string                 `json:"code"`
        Message string                 `json:"message"`
        Details map[string]interface{} `json:"details,omitempty"`
        Retry   *RetryInfo             `json:"retry,omitempty"`
}

// RetryInfo provides retry guidance for errors
type RetryInfo struct {
        Retryable bool      `json:"retryable"`
        After     time.Time `json:"after,omitempty"`
        MaxTries  int       `json:"max_tries,omitempty"`
}

// Standard error codes
const (
        // Client errors (4xx equivalent)
        ErrorCodeValidation       = "VALIDATION_ERROR"
        ErrorCodeInvalidAction    = "INVALID_ACTION"
        ErrorCodeNotFound         = "NOT_FOUND"
        ErrorCodeUnauthorized     = "UNAUTHORIZED"
        ErrorCodeForbidden        = "FORBIDDEN"
        ErrorCodeRateLimited      = "RATE_LIMITED"
        ErrorCodeDuplicateRequest = "DUPLICATE_REQUEST"

        // Server errors (5xx equivalent)
        ErrorCodeInternal           = "INTERNAL_ERROR"
        ErrorCodeTimeout            = "TIMEOUT"
        ErrorCodeServiceUnavailable = "SERVICE_UNAVAILABLE"
        ErrorCodeStorageError       = "STORAGE_ERROR"
        ErrorCodeProcessingFailed   = "PROCESSING_FAILED"

        // Connection errors
        ErrorCodeConnectionClosed = "CONNECTION_CLOSED"
        ErrorCodeInvalidMessage   = "INVALID_MESSAGE"
        ErrorCodeProtocolError    = "PROTOCOL_ERROR"
)

// NewMessage creates a base message with timestamp
func NewMessage(msgType MessageType) Message <span class="cov9" title="23">{
        return Message{
                Type:      msgType,
                Timestamp: time.Now().Unix(),
                Metadata:  make(map[string]interface{}),
        }
}</span>

// NewRequestMessage creates a new request message
func NewRequestMessage(action string, payload map[string]interface{}) *RequestMessage <span class="cov4" title="4">{
        msg := &amp;RequestMessage{
                Message: NewMessage(MessageTypeRequest),
                Action:  action,
                Payload: payload,
        }
        return msg
}</span>

// NewResponseMessage creates a new response message
func NewResponseMessage(requestID string, success bool, data interface{}) *ResponseMessage <span class="cov4" title="4">{
        msg := &amp;ResponseMessage{
                Message:   NewMessage(MessageTypeResponse),
                RequestID: requestID,
                Success:   success,
                Data:      data,
        }
        return msg
}</span>

// NewAcknowledgmentMessage creates a new acknowledgment message
func NewAcknowledgmentMessage(requestID, status, message string) *AcknowledgmentMessage <span class="cov4" title="4">{
        msg := &amp;AcknowledgmentMessage{
                Message:   NewMessage(MessageTypeAcknowledgment),
                RequestID: requestID,
                Status:    status,
                Text:      message,
        }
        return msg
}</span>

// NewProgressMessage creates a new progress message
func NewProgressMessage(requestID string, percentage float64, message string) *ProgressMessage <span class="cov6" title="7">{
        msg := &amp;ProgressMessage{
                Message:    NewMessage(MessageTypeProgress),
                RequestID:  requestID,
                Percentage: percentage,
                Text:       message,
                Details:    make(map[string]interface{}),
        }
        return msg
}</span>

// NewErrorMessage creates a new error message
func NewErrorMessage(requestID string, errorInfo *ErrorInfo) *ErrorMessage <span class="cov3" title="3">{
        msg := &amp;ErrorMessage{
                Message:   NewMessage(MessageTypeError),
                RequestID: requestID,
                Error:     errorInfo,
        }
        return msg
}</span>

// NewErrorInfo creates a new error info structure
func NewErrorInfo(code, message string) *ErrorInfo <span class="cov8" title="14">{
        return &amp;ErrorInfo{
                Code:    code,
                Message: message,
                Details: make(map[string]interface{}),
        }
}</span>

// WithDetail adds a detail to the error info
func (e *ErrorInfo) WithDetail(key string, value interface{}) *ErrorInfo <span class="cov8" title="14">{
        if e.Details == nil </span><span class="cov1" title="1">{
                e.Details = make(map[string]interface{})
        }</span>
        <span class="cov8" title="14">e.Details[key] = value
        return e</span>
}

// WithRetry adds retry information to the error
func (e *ErrorInfo) WithRetry(retryable bool, after time.Time, maxTries int) *ErrorInfo <span class="cov5" title="5">{
        e.Retry = &amp;RetryInfo{
                Retryable: retryable,
                After:     after,
                MaxTries:  maxTries,
        }
        return e
}</span>

// IsClientError checks if the error code represents a client error
func IsClientError(code string) bool <span class="cov10" title="28">{
        switch code </span>{
        case ErrorCodeValidation, ErrorCodeInvalidAction, ErrorCodeNotFound,
                ErrorCodeUnauthorized, ErrorCodeForbidden, ErrorCodeRateLimited,
                ErrorCodeDuplicateRequest:<span class="cov8" title="16">
                return true</span>
        default:<span class="cov7" title="12">
                return false</span>
        }
}

// IsServerError checks if the error code represents a server error
func IsServerError(code string) bool <span class="cov9" title="25">{
        switch code </span>{
        case ErrorCodeInternal, ErrorCodeTimeout, ErrorCodeServiceUnavailable,
                ErrorCodeStorageError, ErrorCodeProcessingFailed:<span class="cov7" title="11">
                return true</span>
        default:<span class="cov8" title="14">
                return false</span>
        }
}

// IsRetryableError checks if an error code indicates a retryable condition
func IsRetryableError(code string) bool <span class="cov7" title="11">{
        switch code </span>{
        case ErrorCodeTimeout, ErrorCodeServiceUnavailable, ErrorCodeRateLimited:<span class="cov4" title="4">
                return true</span>
        default:<span class="cov6" title="7">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "os"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/pay-theory/streamer/internal/store"
)

func main() <span class="cov0" title="0">{
        var (
                endpoint = flag.String("endpoint", "http://localhost:8000", "DynamoDB endpoint")
                region   = flag.String("region", "us-east-1", "AWS region")
                profile  = flag.String("profile", "", "AWS profile to use")
                destroy  = flag.Bool("destroy", false, "Delete tables instead of creating them")
        )
        flag.Parse()

        // Create AWS config
        opts := []func(*config.LoadOptions) error{
                config.WithRegion(*region),
        }

        // Use local endpoint if specified
        if *endpoint != "" </span><span class="cov0" title="0">{
                opts = append(opts,
                        config.WithEndpointResolverWithOptions(aws.EndpointResolverWithOptionsFunc(
                                func(service, region string, options ...interface{}) (aws.Endpoint, error) </span><span class="cov0" title="0">{
                                        return aws.Endpoint{URL: *endpoint}, nil
                                }</span>)),
                        config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider("dummy", "dummy", "")),
                )
        } else<span class="cov0" title="0"> if *profile != "" </span><span class="cov0" title="0">{
                opts = append(opts, config.WithSharedConfigProfile(*profile))
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadDefaultConfig(context.Background(), opts...)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load AWS config: %v", err)
        }</span>

        // Create DynamoDB client
        <span class="cov0" title="0">client := dynamodb.NewFromConfig(cfg)

        ctx := context.Background()

        if *destroy </span><span class="cov0" title="0">{
                fmt.Println("Deleting DynamoDB tables...")
                if err := store.DeleteTables(ctx, client); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to delete some tables: %v", err)
                }</span>
                <span class="cov0" title="0">fmt.Println("Tables deleted successfully")
                os.Exit(0)</span>
        }

        // Create tables
        <span class="cov0" title="0">fmt.Println("Creating DynamoDB tables...")
        if err := store.CreateTables(ctx, client); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create tables: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("✅ All tables created successfully!")
        fmt.Println("\nCreated tables:")
        fmt.Println("  - streamer_connections")
        fmt.Println("  - streamer_requests")
        fmt.Println("  - streamer_subscriptions")
        fmt.Println("\nYou can now run the application or tests.")</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
        "github.com/google/uuid"
)

func main() <span class="cov0" title="0">{
        ctx := context.Background()

        // Load AWS config
        cfg, err := config.LoadDefaultConfig(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load AWS config: %v", err)
        }</span>

        // Create DynamoDB client
        <span class="cov0" title="0">svc := dynamodb.NewFromConfig(cfg)

        // Create test connection
        connectionID := "demo-conn-" + uuid.New().String()[:8]
        userID := "demo-user"
        tenantID := "demo-tenant"

        // Insert test connection
        connectionItem := map[string]types.AttributeValue{
                "connection_id": &amp;types.AttributeValueMemberS{Value: connectionID},
                "user_id":       &amp;types.AttributeValueMemberS{Value: userID},
                "tenant_id":     &amp;types.AttributeValueMemberS{Value: tenantID},
                "created_at":    &amp;types.AttributeValueMemberS{Value: time.Now().Format(time.RFC3339)},
                "last_ping":     &amp;types.AttributeValueMemberS{Value: time.Now().Format(time.RFC3339)},
                "metadata": &amp;types.AttributeValueMemberM{
                        Value: map[string]types.AttributeValue{
                                "demo": &amp;types.AttributeValueMemberBOOL{Value: true},
                        },
                },
        }

        _, err = svc.PutItem(ctx, &amp;dynamodb.PutItemInput{
                TableName: aws.String("streamer_connections"),
                Item:      connectionItem,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create test connection: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Demo setup complete!\n")
        fmt.Printf("Connection ID: %s\n", connectionID)
        fmt.Printf("User ID: %s\n", userID)
        fmt.Printf("Tenant ID: %s\n", tenantID)
        fmt.Printf("\nUse this connection ID in your WebSocket client\n")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
